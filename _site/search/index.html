<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>Search</title>
<script src="https://cdn.levelaccess.net/accessjs/YW1wX3V2YTExMDA/access.js" type="text/javascript"></script>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="Neatline allows scholars, students, and curators to tell stories with maps and timelines.">
<link rel="canonical" href="https://neatline.org//search/">

<link rel="icon" type="image/png" href="https://neatline.org//assets/images/favicon.png" >
<link rel="apple-touch-icon" type="image/png" href="https://neatline.org//assets/images/apple-touch-icon.png">

<!-- Style sheets -->
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css" integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf" crossorigin="anonymous">
<link href="//fonts.googleapis.com/css?family=Crimson+Text:400,600,400italic,600italic|Cabin:400,600,400italic" rel="stylesheet" type="text/css" />
<link href="https://fonts.googleapis.com/css?family=Lato:300,300i,400,400i,700" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Oswald:400,500,700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://neatline.org//assets/css/style.css">




    <!-- https://jekyllcodex.org/without-plugin/search-lunr/# -->
    <script src="https://neatline.org//assets/js/lunr.min.js"></script>
    <script>
    
    var documents = [{
        "id": 0,
        "url": "https://neatline.org//404.html",
        "title": "",
        "body": " 404 Page not found :(  The requested page could not be found. "
        }, {
        "id": 1,
        "url": "https://neatline.org//about/",
        "title": "What is Neatline?",
        "body": "Neatline is what you get when you cross archives and artifacts with timelines, modern and historical maps, and an appreciation for the interpretive aims of humanities scholarship. Why use Neatline?: Neatline is a geotemporal exhibit-builder that allows you to create beautiful, complex maps, image annotations, and narrative sequences from Omeka collections of archives and artifacts, and to connect your maps and narratives with timelines that are more-than-usually sensitive to ambiguity and nuance. Neatline lets you make hand-crafted, interactive stories as interpretive expressions of a single document or a whole archival or cultural heritage collection. You can import these documents (georeferenced historical maps, manuscripts, high-res photographs, etc. ) from an existing collection, or create a new digital archive, yourself. Every Neatline exhibit is your contribution to humanities scholarship, in the visual vernacular. The Scholars’ Lab designed Neatline as a suite of plugins for the open-source Omeka framework, which provides a powerful platform for management and publication of the collection on which your exhibit is built. Through Neatline, you can create create rich representations of places, objects, events, narratives, and documents — like these demo exhibits. What makes it different?: How does Neatline fit into the existing ecosystem of geospatial and annotation tools? Neatline sits in the space between consumer-grade mapping applications like the Google custom map-maker and heavyweight, analytical GIS tools like ArcGIS. It’s not Google Maps or Google Earth: if you just need to drop some labelled pins on a map, Neatline may be overkill for your project. Neatline is designed to be simple enough that college undergraduates can easily use it for class assignments, but also sufficiently flexible, scalable, and feature-rich that it can be used for professional scholarship, journalism, and art. Neatline keeps things simple and provides sensible defaults, but it’s careful never to make intellectual or aesthetic decisions on your behalf. Neatline Project Examples: Neatline works best when you’re using it to tell a story or create an interpretive lens to better understand a collection of artifacts, documents, or richly-described concepts. Do you have a collection to build on, or do you want to create a searchable Omeka collection while you’re mapping and annotating? Is the aesthetic dimension of your visualization important? Do you want to show that contested, conflicting readings of the same dataset are possible? Neatline is for you. Here are some examples of the kinds of projects that could be built (or have been built!) with Neatline:    Wordsworth in the Alps: In Book Sixth of The Prelude, “Cambridge and the Alps,” Wordsworth describes his 1790 grand tour of Europe, culminating in the famous description of the crossing of Simplon Pass in the Alps. You want to create an interactive edition of the poem that traces Wordsworth’s journey from Cambridge across the channel to Calais, south through France, into the Alps, and along the Stockalper trail over the pass. How does Wordsworth’s description of the sequence of towns and landmarks map onto the actual geography of the area?     The Declaration of Independence: The signatures at the bottom of the Declaration of Independence are iconic - we can all recognize John Hancock and Thomas Jefferson, but what about the rest? You want to create an interactive edition of the document that traces out visual annotations around each of the signatures that connects it to a short biography - who they were, where they came from, and how they ended up signing the declaration. With the signatories in place, you then provide a transcription of the declaration itself, and link the individual sentences or words in the text to the corresponding locations on the high-resolution scan of the original document.     Minard’s Napoleon Infographic: Charles Minard’s 1869 diagram showing the gradual depletion of the French army over the course of Napoleon’s 1812 invasion of Russia is a seminal work in the history of information design. You want to take high-resolution scan of Minard’s original graphic, overlay it on top of modern satellite geography, and layer on an interactive reimagination of the original material - trace out the components of Minard’s flowchart, add background information about each of the cities and rivers marked along the route, and link individual objects on the map to paragraphs and sentences in a narrative that describes the history of the invasion.     Whitman’s “Salut au Monde”: “Salut au Monde” is an index of Whitman’s geographic imagination, an expansive catalog of cities, countries, regions, landmarks, oceans, rivers, and cultures. You want to create a rich interactive edition of the poem by layering the actual text on top of modern satellite imagery and connecting each of the of geospatial references to hand-selected (and at times highly interpretive) focus locations on the map - the “Amazon” to the expansive, dark green rainforests in Brazil, the “northern blasts” to the glaciers in the Brooks Range, etc.     Hotchkiss at Chancellorsville: Jedediah Hotchkiss, a military cartographer for the Confederacy during the Civil War, spent the rest of his life revisiting maps he made during the war, sketching in marginalia and marking off troop locations. In one instance, he printed a series of three identical engravings of the area around Chancellorsville and Fredericksburg and sketched in the positions of the Union and Confederate armies on each of the three days of the Battle of Chancellorsville with colored pencils. You want to create an exhibit that positions the three maps on top of modern satellite imagery of the battle field and layers on a second layer of visual annotation about the maps - the movement of the armies in the weeks leading up to the battle, Lee’s risky decision to split his army and leave half of his force behind at Fredericksburg, and why Jackson decided to perform a risky flanking maneuver on the morning of the first day.     The Chelyabinsk Meteor: On February 15, 2013, a 10,000-ton meteor streaked over the city of Chelyabinsk in the Ural Mountains, producing a massive airburst that shattered windows and collapsed buildings. The explosion occurred during the morning rush hour, and the event was captured by dozens of commuters with dashboard-mounted video cameras. You want to create an exhibit that traces out the trajectory of the meteor as it enters the atmosphere and traverses the airspace over the city, and plot out the exact position and orientation of each of the recordings relative to the location of the airburst.     A geographic and institutional map of 20th century literary theory: We tend to identify clusters of literary critics with universities, cities, and countries – the Yale school, Russian formalism, Marxism and the Frankfurt School, etc. You want to plot the institutional affiliations and career arcs of ~100 prominent 20th century literary theorists, grouped by critical school, to explore to what extent the real-world locations and temporal overlaps of various critics do or do not correspond with the conceptual connections that emerge in their work. Use Neatline’s map and timeline features, and import relevant pieces of evidence into Omeka.     An interactive narrative of the early British Mount Everest expeditions: Did George Mallory and Andrew Irvine make it to the summit on June 8th, 1924? Use contemporary satellite imagery, built into Neatline. as you create a map showing the climbing lines that the parties followed on their summit attempts, the conjectured routes that Mallory may have taken, and the location of his body when it was discovered in 1999. The phases of the climb can be plotted as spans on the timeline, and minute-by-minute accounts from the Odell diaries, brought into Omeka as discrete objects, can be captured as points on the map and timeline.     A visualization of the movements of characters and concepts in The Tempest: Shakespeare’s play takes place in a indeterminate aesthetic space, an island outside the moving world — and yet the literal, spatial movements of its characters are described in significant detail. You can draw and scan your own map, or import a Renaissance-era map of an island in the Mediterranean (or the West Indies, or the Carribean) to create a speculative, playful plotting of the spatial dimension of the text — Prospero’s lair, the shipwreck, the carousing of Caliban and Trinculo, Ariel’s errands, and the journey back to Italy.  I’m ready to play. Let’s get started!: Swell! Check out our Exhibit Showcase to see what others have built using Neatline. Read the full documentation: Neatline Classic GuideNeatline S Guide Download Neatline for your own Omeka installation: Download for Omeka ClassicDownload for Omeka S Go straight to the source:  Neatline Classic Neatline S "
        }, {
        "id": 2,
        "url": "https://neatline.org//credits/",
        "title": "Credits and History",
        "body": " Neatline is an ongoing project that emerged from a long process of research and prototyping at the Scholars’ Lab, a digital center at the University of Virginia Library.  Its story is characteristic of digital humanities work, but uncommon in more traditional modes of humanities scholarship.  Large-scale software development is an inherently collaborative process, in which final products draw on thousands of conceptual, technical, and aesthetic decisions made by dozens of people over the course of years. We have therefore chosen to represent our project in phases, and augment a traditional, role-oriented list of credits with a narrative that traces the intellectual lineage of Neatline from concept to working code.  If you'd like to know more about authorship and credit in the digital humanities, we recommend the following resources:   Where Credit Is Due: Preconditions for the Evaluation of Collaborative Digital Scholarship The FairCite initiative and a related DH Answers thread The Collaborators' Bill of Rights Our Praxis Program charter and related posts by Praxis students and collaborators  And if you were a contributor to the Neatline project and we have overlooked or misrepresented your work, please let Jeremy Boggs and Ronda Grizzle know immediately!           Current Neatline Team:             Jeremy Boggs       Ronda Grizzle       Zoe LeBlanc       Shane Lin       Elizabeth Mitchell               Funding:             NEH Office of Digital Humanities       Institute for Museum and Library Services       Library of Congress              Partners:             Performant Software Solutions, LLC       Roy Rosenzweig Center for History and New Media              Special Thanks:         University of Virginia Library     Bethany Nowviskie     Wayne Graham        David McClure     Adam Soroka        Joe Gilbert        David Rumsey      Past Advisors:       Ellen Dunlap. President, American Antiquarian Society    N. Turk McCleskey. Professor of History, Virginia Military Institute    Jerome McGann. John Stewart Bryan Professor of English, University of Virginia    Michael Plunkett. Director Emeritus of Special Collections, University of Virginia Library    Daniel Pitti. Associate Director, Institute for Advanced Technology in the Humanities       Phase 1: Scholars’ Lab R&amp;D (2008-2009):         In 2008, the Scholars' Lab (with the technical guidance of Bess Sadler, Chris Gist, and Kelly Johnston, and the assistance of Dave Richardson) began developing a new infrastructure for delivering library-managed GIS data and georeferenced historical maps.  Adam Soroka served as lead developer in that effort.  As all Scholars' Lab staff are allotted 20% of their time to independent research and development (otherwise devoted to collaborations with UVa faculty and graduate students or the development of core tools and systems for scholarship), Soroka had the freedom to think and to tinker.    One of his chief questions in building this infrastructure was,  What next?  In other words, what might scholars be able to do if they had access to 'streaming' historical maps via a modern, open, webservice-based GIS infrastructure? That's a PDF link -- and the title of the workshop Soroka ultimately offered on this subject at the 2009 code4lib conference in Providence, Rhode Island.    Soroka began to consult with Scholars' Lab director Bethany Nowviskie about the possibilities.  Because code4lib was to be held in Providence, he quickly prototyped a map-and-timeline exhibit based on Special Collections metadata from Brown University Library (graciously provided by Patrick Yott).  The prototype exhibit plotted a letters sent and received by H. P. Lovecraft, a 20th-century writer of the Gothic whose work makes heavy reference to the urban geography of Providence. Soroka's experiment explored the concept of geo-temporal mapping as a methodology for creating interpretive views of archival collections expressed in EAD (encoded archival description) format. Nowviskie contextualized their thinking in a talk on  New World Ordering: Shaping Geospatial Information for Scholarly Use,  at the University of Maryland.    Through this work, faculty and staff of the Scholars' Lab began to imagine strategies not just for public access to library holdings of maps, but for annotative, scholarly interfaces to collections of maps and manuscripts.        Contributors:    Adam Soroka: developer  Bethany Nowviskie: interlocutor, distractor in chief     Bess Sadler: GIS infrastructure project manager  Chris Gist: user requirements consultation.   Kelly Johnston: user requirements consultation.   Dave Richardson: GIS research assistant.      Phase 2: NEH Start-Up Grant (2009-2010):       Building on growing interest in the concept of geo-temporal mapping in the DH community, Soroka's code4lib prototype became the basis for a Phase II Digital Humanities Start-Up Grant awarded to the Scholars' Lab by the National Endowment for the Humanities and the IMLS in late 2009.  Bethany Nowviskie and Adam Soroka served as primary investigators on the $34,656 grant, which benefited from a strong board of outside advisors, including:    Ellen Dunlap: President, American Antiquarian Society  N. Turk McCleskey: Professor of History, Virginia Military Institute  Jerome McGann: John Stewart Bryan Professor of English, University of Virginia  Michael Plunkett: Director Emeritus of Special Collections, University of Virginia Library  Daniel Pitti: Associate Director, Institute for Advanced Technology in the Humanities  With NEH support, the project entered into its first stage of major development as a standalone, Java-based application with code commits from Adam Soroka and Sam Eberspacher, design by Joe Gilbert and Bethany Nowviskie, and research contributions by Dave Richardson, Matt Munson, and Richard Miller.  However, around this time Wayne Graham joined the Scholars' Lab, and he and Nowviskie began to experiment with Omeka, a digital-collections building and publishing framework developed by CHNM, the Center for History and New Media at George Mason University, for other SLab projects.  As work on Neatline continued, the design requirements and solution space of the application became more fully understood. Soroka, Graham, and Nowviskie decided that the underlying collections required as a foundation for Neatline projects could be better served by Omeka (provided the Scholars' Lab also developed a number of other data import and management plugins) -- thus leaving Neatline developers free to focus on the specialized task of geo-temporal interpretation. (Ethan Gruber contributed significantly to this work. ) Furthermore, they realized that a plugin-based approach would allow many of the discrete functions of Neatline to be atomized -- so that users could to mix and match software features of their choosing.  As Soroka transitioned to another position at the UVa Library, Wayne Graham led the restructuring of Neatline as a suite of modular plugins that could extend the functionality of Omeka. This change in approach had the added benefit of moving Neatline onto an accessible technology stack (PHP and MySQL) with a significant installation base and developer community, making it easier for end users to install, configure, and deploy Neatline exhibits.  Nowviskie and Soroka drafted a white paper describing this change in approach and outlining Neatline's design philosophy, which is centered in hand-craftedness and graphesis.     Contributors:    Adam Soroka: PI and lead developer.   Bethany Nowviskie: PI and project director.      Wayne Graham: Project manager and developer.   Ethan Gruber: Omeka plugin developer.   Joe Gilbert: UX designer.   Sam Eberspacher: Student developer.   Matt Munson: Research assistance.   Rich Miller: Research assistance.      Phase 3: Omeka + Neatline (2011-2016):        In 2011, the Scholars' Lab and the Roy Rosenzweig Center for History and New Media entered into a new partnership centered around Neatline. This work, supported by $665,248 in funding from the Library of Congress (split evenly between the two centers), is led by co-investigators Bethany Nowviskie and Tom Scheinfeldt.  The  Omeka + Neatline  project is not only meant to push Neatline development to a public release and strengthen the Omeka codebase, but also to explore grassroots, open source, developer-driven collaboration between two digital centers on issues of cultural heritage interpretation. The project concludes in August of 2012.    New Scholars' Lab R&amp;D staff contributed significantly to the design and development of Neatline and related plugins in this phase.  These include David McClure, Eric Rochester, and Jeremy Boggs. Ronda Grizzle helped to create a logo and assisted with other communications needs.    Building on the work of previous contributors, major development of the Neatline 1. 0 codebase was undertaken by Wayne Graham, McClure, Rochester, and Boggs starting in the summer of 2011. Rochester concentrated on Neatline Features.  Boggs developed Neatline Time and created our informational website.  Graham served as project manager, but also contributed code and oversaw code packaging and quality assurance.  Nowviskie helped to test the software, offered design direction, and wrote and spoke about and wrote and wrote many things. Ray Johnson managed the money. Graham and McClure collaborated with outside testers, including Elijah Meeks of Stanford University.    During this phase, David McClure emerged as our lead project developer, designing and implementing the Neatline exhibit-building interface and finalizing feature specifications and user workflows for the entire family of Neatline plugins.    However, Neatline has been and remains a family affair for the whole Scholars' Lab team, including Becca Peters, Eric Johnson, Kelly Johnston, Chris Gist, and our student workers and Graduate and Praxis Program fellows. The core Neatline team is deeply grateful to all our friends at the SLab. We'd also like to thank our UVa Library colleagues (including Special Collections and Digital Curation Services, who provided images for sample exhibits), and many scholars and cultural heritage professionals at Virginia and elsewhere who have offered us their encouragement and advice.        Contributors:    David McClure: Lead Neatline developer and software architect.   Eric Rochester: Developer of the Neatline Features plugin.   Jeremy Boggs: Web designer, developer of Neatline Time.   Wayne Graham: Project manager and lead engineer.   Bethany Nowviskie: PI and project director.      Paul Mawyer: Research assistance.      Ronda Grizzle: Communications and outreach.      Raylon Johnson: Grants management.      Tom Scheinfeldt:  Omeka + Neatline  co-PI.      Omeka collaborators at RRCHNM: Sharon Leon, Sheila Brennan, John Flatness, Patrick Murray-John, Kim Nguyen, Jim Safley, and Roberto Sanchez     Phase 4: Neatline Implementation NEH Grant (2016-present):               In late 2016, the Scholars’ Lab was awarded funding from the Office       of Digital Humanities at the NEH for Neatline development aimed at increasing sustainability - not only of the code base - but also of the communities that have grown around the use of Neatline.       During this phase we partnered with       Performant Software Solutions LLC, as major development partners on the Neatline codebase.          In mid-2017 we released Neatline 2. 5. 2, an      update to our existing plugin for Omeka Classic, in large thanks to Jamie Folsom and Andy Stuhl from      Performant Software. This release fixed some bugs related to changes in the Google Maps API and errors with WMS layers. In addition to      these fixes, we also incorporated accessibility functionality in Neatline for the first time, in thanks to Neatline community member Adam      Doan (@doana on Github) from the University of Guelph.         In 2018, we started work on a Neatline module for Omeka S, continuing our development partnership      with Performant Software. We've built the Neatline module from the ground up, implementing LeafletJS as its mapping component.      In this phase, we're focused on ensuring Neatline's continued compatibility with the     Omeka platform, streamlining the editing interface to make creating exhibits faster, creating a compelling     interface for integrating long-form text content with the geotemporal aspects of a Neatline exhibit, and     developing tools for better conveying humanistic concerns related to speculative and ambiguous time events     within Neatline exhibits.            Contributors:    Jeremy Boggs: Grant PI and project director  Eric Rochester: Grant PI  Nicholas Laiacona: Performant Software solutions, Developement Partner  Jamie Folsom: Performant Software Solutions, Developement Partner  Andy Stuhl: Performant Software Solutions, Developement Partner  Makoto Kobayashi: Performant Software Solutions, Developement Partner  Dave Hennigan: UVA Library Grants Manangement  Zoe LeBlanc: Humanities Developer  Shane Lin: Humanities Developer  Ronda Grizzle: Communications and outreach  Elizabeth Mitchell: Research assistance, community advocate   "
        }, {
        "id": 3,
        "url": "https://neatline.org//demos/",
        "title": "Demos - Redirect",
        "body": "This page has moved to https://neatline. org/showcase/. If you are not automatically redirected, please click here. : "
        }, {
        "id": 4,
        "url": "https://neatline.org//docs-s/",
        "title": "Neatline for Omeka S",
        "body": "Neatline for Omeka S: Development Release v0. 3. 0Here’s our most recent development release of Neatline for Omeka S: version 0. 3. 0 Major updates include:  Compatibility with Omeka S 2. 0 Requires Omeka S 2. 0 or higherNeatline for Omeka S is still in development, and this version is not yet ready for production use. We are continuing work on the module, and will do incremental 0. x releases until we’re ready to offer a stable, production-ready 1. 0 version. Currently, we are on schedule to release Neatline for Omeka S by September 2020. Please continue to check here for any updates. If you’re interested and willing to test out some beta software, check out our most recent release:  Neatline for Omeka S Development Release v0. 3. 0Alternatively, if you like Docker, you can clone this Docker example, follow the README, and have a fresh Omeka S instance with the Neatline module referenced.  Omeka S + Neatline 3 DockerWe still have plenty of issues on Github to address. If you find an issue that is not already listed, we’d be grateful if you let us know about it by submitting a new issue on Github. "
        }, {
        "id": 5,
        "url": "https://neatline.org//docs/",
        "title": "Neatline for Omeka Classic",
        "body": "Welcome to Neatline!This guide is designed to be a comprehensive introduction to the Neatline project for Omeka Classic. We’ll walk through the basic steps of installing and configuring Neatline, creating exhibits and records, importing items from your Omeka collection, and publishing your projects to the web. Start with our introduction, browse the documentation, or search for specific topics. Looking for documentation for Neatline for Omeka S? Visit our Neatline S guide, here. Help us improve this guide: As you read through the documentation, if you find anything that’s unclear, incomplete, or incorrect be sure to file a support ticket on the project’s issue tracker on GitHub, and we’ll do our best to fix the problem! "
        }, {
        "id": 6,
        "url": "https://neatline.org//",
        "title": "Home",
        "body": "Neatline allows scholars, students, and curators to tell stories with maps, images and timelines. As a suite of add-on tools for Omeka, it opens new possibilities for hand-crafted, interactive spatial and temporal interpretation.                                                    A (Digital) Declaration of Independence:     Use Neatline to connect texts, images, and maps. :                                Mapping the “White, Marmorean Flock”: Anne Whitney Abroad, 1867–1868:     Use Neatline as a tool for digital scholarship. :                                          Mapping the Catalogue of Ships:      Use Neatline to interconnect text with geography. :                                     Minard + Napoleon:     Use Neatline to interpret diagrams. :                              Jeddah: Gateway to the Hajj:      Use Neatline for student projects. :             Previous      Next       Neatline for Omeka Classic:     Download    Documentation     Github        Neatline for Omeka S (Development Release):     Download    Documentation     Github      &lt;/div&gt;&lt;/div&gt; "
        }, {
        "id": 7,
        "url": "https://neatline.org//news/",
        "title": "News",
        "body": "	Keep up to date with Neatline news and blog posts. Follow us on Twitter @neatline. 						02. 26. 2020			February 26, 2020						Neatline for Omeka S: Development Release v0. 3. 0				Here’s our most recent development release of Neatline for Omeka S: version 0. 3. 0Major updates include: Compatibility with Omeka S 2. 0 Requires Omeka. . . 							06. 04. 2019			June 4, 2019						Neatline 2. 6. 2 Release				Neatline 2. 6. 2 is a security release for all previous versions of Neatline for Omeka Classic, and we strongly encourage you to update to this version. . . 							07. 05. 2017			July 5, 2017						Neatline 2. 5. 2				New release!First, a huge thank you to Jamie Folsom and Andy Stuhl from Perfomant Software Solutions LLC, who did the heavy lifting on. . . 							08. 12. 2016			August 12, 2016						Neatline Implementation Grant				You may have noticed on Twitter or elsewhere that the NEH announced funding for almost. . . 		Previous Posts: 									2015: 							Neatline 2. 4. 0									2014: 							Minard + Napoleon + Neatline							Upgrading Neatline and Omeka							Omeka, Neatline, Mac, development, oh my!							Neatline 2. 3							A (Digital) Declaration of Independence							Creating themes for individual Neatline exhibits							NeatlineText: Connect Neatline exhibits to documents							Project Gemini over Baja California							The “Nicolay copy” of the Gettysburg Address							Neatline release-apalooza: Neatline 2. 2. 0, Neatscape, Astrolabe									2013: 							Neighborhoods of San Francisco							NITLE Presentation on Geotemporal Storytelling with Neatline							“The Song of Wandering Aengus,” Neatline, and negotiation with the machine							More fun with interactive typesetting: “A Coat,” by Yeats							Experimental typesetting with Neatline and Shakespeare							Neatline 2. 1. 0							Displaying Recent Neatline Exhibits on your Omeka Home Page							Announcing Neatline 2. 0. 2!							Announcing Neatline 2. 0. 0! A stable, production-ready release							Neatline 1. 1. 3 Maintenance Release							Interactive CSS in Neatline 2. 0							Announcing Neatline 2. 0-alpha2!							Announcing Neatline 2. 0-alpha2!							Neatline 1. 1. 3 Maintenance Release							Interactive CSS in Neatline 2. 0							Announcing Neatline 2. 0-alpha1!							Restarting Marionette applications							Neatline and Omeka 2. 0							SVG-to-WKT: Converting vector graphics into spatial coordinates							Neatline Feature Preview &#8211; Importing SVG documents from Adobe Illustrator							Neatline Feature Preview – Importing SVG documents from Adobe Illustrator							Neatline Feature Preview – 1,000,000 records in a single exhibit							Neatline 1. 2 Feature Preview &#8211; 1,000,000 records in a single exhibit									2012: 							Populating MySQL tables with Node. js							Neatline Release Omnibus Edition							Neatline Omeka Theme Name Winners!							Neatline Omeka Theme Name Contest							Geocoding for Neatline &#8211; Part I							Geocoding for Neatline – Part I							Omeka + Neatline Metadata Survey							Using Neatline with historical maps :: Part 3 &#8211; GeoServer							Using Neatline with historical maps :: Part 2 &#8211; Transparency							Using Neatline with historical maps :: Part 1 &#8211; Georeferencing							Translating Neatline							Neatline 1. 0. 1							Parent-child relationships in Neatline							Neatline and the framework challenge							Announcing Neatline!							Neatline Sneak-Peek							Neatline workshop podcast									2011: 							Scholars&#8217; Lab and the Center for History and New Media Partner on &#8220;Omeka + Neatline&#8221;									2010: 							WMS vs. tile-caching							Fringe benefits							Omeka plugins burning like meteors									2009: 							An update: the shift to Omeka							Neatline notes							And we&#8217;re off!			"
        }, {
        "id": 8,
        "url": "https://neatline.org//plugins/",
        "title": "Plugins & Modules",
        "body": "  Directory of Neatline add-ons to extend the functionality of your Omeka installation. Filter for Neatline plugins for Omeka Classic and modules for Omeka S.       Omeka Classic    Omeka S            Neatline for Omeka Classic    :     Plot your course in space and time                       Neatline is a lightweight, extensible framework for creating interactive editions of visual materials – maps, paintings, photographs, and anything else that can be captured as an image.       Download      Documentation              NeatlineText for Omeka Classic    :     Connect text documents to Neatline exhibits                   NeatlineText is a extension to the Neatline plugin that makes it possible to connect paragraphs, sentences, and words in text documents with annotations in Neatine exhibits.     Download    Documentation              NeatlineSimile for Omeka Classic    :     Add SIMILE Timeline to Neatline exhibits                   Neatline Simile makes it possible to add the SIMILE Timeline widget to Neatline exhibits. Once the timeline has been added, records can be plotted as points and spans on the timeline, and the timeline can be used to control the visibility of records on the map (and in other viewports added by sub-plugins, like the Waypoints list).     Download    Documentation              NeatlineWaypoints for Omeka Classic    :     Adds a list of waypoints to Neatline exhibits                   NeatlineWaypoints makes it possible to add an list of clickable “waypoints” to an exhibit. Waypoints can be put into a specific order, making it possible to guide users through an exhibit in a linear sequence.     Download    Documentation              Neatline for Omeka S    :     Module in Development         Note: this module is still under initial development and does not yet provide the full functionality of Neatline 2. 6. 3 for Omeka Classic.     Download    Documentation  "
        }, {
        "id": 9,
        "url": "https://neatline.org//publications/",
        "title": "Publications",
        "body": "Bruzelius, Caroline and Hannah Jacobs. “Wired! Full Immersion: Neatline and the Digital Syllabus. ” Duke Media Arts + Sciences Rendezvous, March 19, 2015. Evans, Courtney and Ben Jasnow. “Mapping Homer’s Catalogue of Ships. ” Literary and Linguistic Computing 29:3 (2014): 317-325. Fischer, Susanne. “Once Upon a Place: Telling Stories with Maps”, The Atlantic, July 2012. Jentleson, Katherine. “‘Not as rewarding as the North:’ Holger Cahill’s Southern Folk Art Expedition. ” Smithsonian Achives of American Art, 2013 Archives of American Art Graduate Research Essay Prize winner. Musacchio, Jacqueline Marie, Jenifer Bartle, David McClure, Kalyani Bhatt. “Mapping the “White, Marmorean Flock”: Anne Whitney Abroad, 1867–1868. ” Nineteenth-Century Art Worldwide 13:2 (Autumn 2014). Web. This article features two Neatline exhibits, which can be accessed, along with instructions for use, here. Nowviskie, Bethany, David McClure, Wayne Graham, Adam Soroka, Jeremy Boggs, and Eric Rochester. “Geo-Temporal Interpretation of Archival Collections with Neatline. ” Literary and Linguistic Computing 28:4 (2013): 692-699. Posthumus, Stephanie and Stéfan Sinclair. “Reading environment(s): digital humanities meets ecocriticism. ” Green Letters: Studies in Ecocriticism 18:3 (2014): 254-273. Reilly, Lisa A. “Change over Time: Neatline and the Study of Architectural History. ” Artl@s Bulletin 4, no. 1 (2015): Article 2. Van Remoortel, Marianne. “A Poem’s Flight: Reprints of Dante Gabriel Rossetti’s ‘Sunset Wings’ in the American Newspaper Press. ” Scholarly Editing, 34 (2013). "
        }, {
        "id": 10,
        "url": "https://neatline.org//search/",
        "title": "Search",
        "body": "  Site Search            "
        }, {
        "id": 11,
        "url": "https://neatline.org//showcase/",
        "title": "Exhibit Showcase",
        "body": "  We've gathered a number of Neatline exhibits to help stretch your imagination. Look below for projects in history, literature, and contemporary space and place. Do you have a public Neatline exhibit you'd like to share? Please use our  submission form, and we'll include your work in our Exhibit Showcase. We're always eager to see what the Neatline community is building.     Omeka Classic   Timelines   NeatlineText   Waypoints          The Nicolay Copy of the Gettysburg Address:     The Nicolay Copy of the Gettysburg Address:                           Launch Exhibit:               Neatline for Omeka Classic    By David McClure | Gettysburg Address -  Nicolay Copy . Library of Congress.           &lt;a href= {{  /2014/02/04/the-nicolay-copy-of-the-gettysburg-address/  | prepend: site. url }} &gt;Read more about this project on our blog. &lt;/a&gt;            Black Liberation 1969 Archive:     Black Liberation 1969 Archive:              Neatline for Omeka Classic    By Nabil Kashyap, Alison Roseberry-Polier, John Gagnon, and Maria Mejia | Link with permission of the Black Liberation 1969 Archive. | Map: Google Satellite           The Black Liberation 1969 Archive is an Omeka archive  designed in support of Black Liberation 1969: Black Studies in History Theory and Praxis taught at Swarthmore College by Professor Allison Dorsey,  and produced through the joint efforts of Nabil Kashyap, a librarian, and several students. This Neatline exhibit, a part of the larger archive, maps the 1969 sit-ins at Swarthmore, creatively using custom annotations to provide a timeline for the events.             The Possibility of an Island:     The Possibility of an Island:         Neatline for Omeka Classic  By Stephanie Posthumus and Amy Goh | Maps: Google Physical and Streets         Stephanie Posthumus and Amy Goh, of McGill University, use Neatline to map the life of one of the characters from Michel Houellebecq's novel, The Possibility of an Island, in this exhibit, making impressive use of custom point images.           Anne Whitney Abroad, 1867–1868: The Continental Perspective:      Mapping the “White, Marmorean Flock”: Anne Whitney Abroad, 1867–1868:           Neatline for Omeka Classic   by Jacqueline Marie Musacchio, with Jenifer Bartle and David McClure, assisted by Kalyani Bhatt. This project was made possible through generous funding from the Andrew W. Mellon Foundation’s Digital Humanities and Art History series. Link provided with the permission of the author.         The article, maps, and timeline components of this project illustrate the first sixteen months of Anne Whitney’s life abroad in a macro and micro fashion. In the language of the Neatline plugin used to generate the interactive features, the maps and timeline constitute two “exhibits”; where relevant, these exhibits are linked to the article in both the main text and endnotes. Although the article tells a complete narrative on its own, readers seeking more information, or the manuscript sources for my analysis, can link to precise points in the exhibits. While I hope readers will use text and tools together for the most complete experience, they can be accessed independently. In fact, doing so will yield even more information, since there are many records in the exhibit that are not linked to in the article, but which provide a broader and richer context for Whitney’s experience and indeed that of other female artists abroad of this era.    Anne Whitney Abroad, 1867–1868: The Continental Perspective    This exhibit provides a broad look at Whitney’s travels across the European continent. A brief narrative description of her activities during this period, found in the column on the right, links the names of the cities and towns Whitney visited to the appropriate places on the map and timeline as well as to contemporary or near-contemporary images. The user can move through the exhibit by clicking on the highlighted text on the right, the points on the map, or the timeline entries. These first sixteen months include two distinct journeys: Whitney’s trip from New York to Rome (March–April 1867) and her movement around Europe that summer and fall (June–October 1867); she remained in Rome from April to June 1867, and again from October 1867 to July 1868. The first two links in the article, indicated by a globe icon, correspond to these two journeys, which Jenifer visualized by creating lines and arrows on the map between each city or town.    Anne Whitney Abroad, 1867–1868: The First Sixteen Months     The second exhibit provides a more detailed view of Whitney’s life abroad. It has additional layers that allow users to zoom into and explore historical maps not only of Europe but also of Massachusetts, Switzerland, Paris, Rouen, Florence, Bologna, and Rome. This exhibit has a five-track timeline with links to individual records that contain excerpted texts from Whitney’s letters, as well as related photographs—some of which were collected by Whitney herself—to tell a more complete story.     Jacqueline Marie Musacchio,  Mapping the 'White, Marmorean Flock': Anne Whitney Abroad, 1867–1868,  Nineteenth-Century Art Worldwide 13, no. 2 (2014).            Mapping the Catalogue of Ships:     Mapping the Catalogue of Ships:              Neatline for Omeka Classic   By Jenny Strauss Clay, Courtney Evans, and Ben Jasnow | Maps: Google Physical         In collaboration with the Scholars' Lab, Jenny Strauss Clay, Courtney Evans, and Ben Jasnow created  Mapping the Catalogue of Ships  to visually demonstrate the link between the Catalogue of Ships in Homer's Iliad and the natural geography of Greece.           The Whiskey Rebellion: An Interactive Mapping Project:     The Whiskey Rebellion: An Interactive Mapping Project:              Neatline for Omeka Classic    By Stephanie Krom | Link with permission of Stephanie Krom. | Map: OpenStreetMap             This digital history project explores the Whiskey Rebellion through time and space. This site includes an interactive map, a responsive timeline, and an audio tour of the major sites of the Whiskey Rebellion. Locations of important sites of the Whiskey Rebellion have been found through original, on-the-ground research and appear together for the first time in this user-focused digital space.   (Text from the project's About page. )            Minard + Napoleon + Neatline:     Minard + Napoleon + Neatline:           Neatline for Omeka Classic   By David McClure | Map tiles by Mapbox | Map from Wikipedia. Built for the NEH Workshop Digital Methods for Military History at Northeastern University.         Charles Minard’s 1869 diagram showing the gradual depletion of the French army over the course of Napoleon’s 1812 invasion of Russia is a seminal work in the history of information design. This exhibit was built by georeferencing a scan of Minard’s diagram, and then vector annotations were traced out on top of each of the individual segments that represent the deteriorating size of the Grande Armée over the course of the invasion.    The small interactive chart was made using d3, that plots out the size of the French army over the course of the ~5-month interval of time between when Napoleon crossed the Neman on June 24 and when that last little bit of the army stumbled back out of Russia in December 14.          A (Digital) Declaration of Independence:     A (Digital) Declaration of Independence:           Neatline for Omeka Classic   By David McClure | Map tiles by Mapbox         &lt;a href= {{  /2014/07/02/a-digital-declaration-of-independence-with-text-painting-and-map/  | prepend: site. url }} &gt;Read more about this project on our blog. &lt;/a&gt;             Perspectives on the Haram:     Perspectives on the Haram:              Neatline for Omeka Classic         By Virginia Harness, Jody Lahendro, Kelly Schantz, and David Sherdil | Map: Google Satellite | Link provided with the permission of the authors.                Perspectives on the Haram  is an exhibit created by a group of University of Virginia undergraduate students for a course in the School of Architecture, taught by Professor Lisa Reilly. The exhibit uses images and texts from travel accounts to details the changes of the Haram Mosque over a thousand years.             Jeddah: Gateway to the Hajj:     Jeddah: Gateway to the Hajj:        Neatline for Omeka Classic  By Deniz Berk, Maggie Friedman, Blake McDonald | Map: Google Satellite | Link provided with the permission of the authors.        Jeddah: Gateway to the Hajj  is an exhibit created by a group of University of Virginia undergraduate students for a course in the School of Architecture, taught by Professor Lisa Reilly. The exhibit uses first hand accounts to depict the experience of the Hajj as it has been shaped by changing modes of travel in three different time periods.       &lt;/div&gt; "
        }, {
        "id": 12,
        "url": "https://neatline.org//themes/",
        "title": "Custom Neatline Themes for Omeka",
        "body": "      We've created several custom Omeka themes specifically for use with Neatline exhibits. Follow the links below to download theme files for your project. See our Theme Tutorials for guides on installing and customizing themes for your Neatline exhibits. Neatline does not require custom theming, you're welcome to use the themes provided by Omeka for your site.               Omeka Classic      Omeka S            NeatLight:                     NeatLight is a minimal theme for Omeka Classic that foregrounds Neatline exhibits and narratives.         It was designed specifically for use with the NeatlineText plugin, to position the narrative text next to the exhibit inside of a         scrollable container element.     Download        Astrolabe:                     Astrolabe theme for Omeka Classic designed by the Scholars' Lab     Download          "
        }, {
        "id": 13,
        "url": "https://neatline.org//tutorials/",
        "title": "Neatline Tutorials",
        "body": "  Using Historic and Custom Map Layers:           &lt;a href= {{  /2012/08/20/using-neatline-with-historical-maps-part-1-georeferencing/  | prepend: site. url }} &gt;Part 1 – Georeferencing&lt;/a&gt;              &lt;a href= {{  /2012/08/23/using-neatline-with-historical-maps-part-2-transparency/  | prepend: site. url }} &gt;Part 2 – Transparency&lt;/a&gt;              &lt;a href= {{  /2012/08/29/using-neatline-with-historical-maps-part-3-geoserver/  | prepend: site. url }} &gt;Part 3 – GeoServer&lt;/a&gt;          Using Neatline Plugins:           &lt;a href= {{  /docs/working-with-the-text-widget  | prepend: site. url }} &gt;NeatlineText&lt;/a&gt;            &lt;a href= {{  /docs/working-with-the-waypoints-plugin  | prepend: site. url }} &gt;Waypoints&lt;/a&gt;            &lt;a href= {{  /docs/working-with-the-simile-timeline-widget  | prepend: site. url }} &gt;SIMILE Timeline&lt;/a&gt;        Working with Public Themes:           &lt;a href= {{  /tutorials/installing-themes  | prepend: site. url }} &gt;Installing a Custom Neatline Theme&lt;/a&gt;            &lt;a href= {{  /2014/04/01/creating-themes-for-individual-neatline-exhibits/  | prepend: site. url }} &gt;Creating Themes for Individual Neatline Exhibits&lt;/a&gt;            Modifying Themes      "
        }, {
        "id": 14,
        "url": "https://neatline.org//use-cases/",
        "title": "Neatline Use Cases",
        "body": "     &lt;a href= {{  /use-cases/educators/  | prepend: site. url }} &gt;Educators&lt;/a&gt;      &lt;a href= {{  /use-cases/scholars/  | prepend: site. url }} &gt;Scholars&lt;/a&gt;         &lt;a href= {{  /use-cases/librarians/  | prepend: site. url }} &gt;Librarians&lt;/a&gt;       &lt;a href= {{  /use-cases/professionals/  | prepend: site. url }} &gt;Cultural Heritage Professionals&lt;/a&gt;        &lt;a href= {{  /use-cases/students/  | prepend: site. url }} &gt;Students&lt;/a&gt;      &lt;a href= {{  /use-cases/creators/  | prepend: site. url }} &gt;Community Creators&lt;/a&gt;   "
        }, {
        "id": 15,
        "url": "https://neatline.org//docs/communitydocs/",
        "title": "Neatline User Community Documentation",
        "body": "Neatline User Community DocumentationDukeWired. org’s Neatline guide The Michelle Smith Collaboratory for Visual Culture at the University of Maryland’s Omeka + Neatline Best Practices Guide Matthias Lang, head of the eScience-Center at the University of Tübingen, created a video documenting the use of the SIMILETimeline subwidget. Jacob Heil has gathered all the currently available youtube videos documenting Neatline 2. x and its features into a playlist. Kristen Mapes has put together a Tutorial: Neatline for Historical Maps. "
        }, {
        "id": 16,
        "url": "https://neatline.org//docs/creating-exhibits/",
        "title": "Creating Exhibits",
        "body": "Creating ExhibitsAt a glance:  Click “Create an Exhibit” to add a new exhibit.  Use the form to define basic, high-level information about a project.  You can always go back and edit any of the default settings. Exhibit Settings: To start a new project, click on the “Create an Exhibit” button at the top of the main “Browse Exhibits” page. Use the form to define basic information about your project. Setting fields marked with an asterisk (*) are required for saving your new exhibit. Save your exhibit settings by clicking “Save Exhibit” at the bottom of the page. You can return to Exhibit Settings at any time to edit any of the default settings.  Title* URL Slug* Narrative Accessible Alternative URL Widgets Enabled Spatial Layers Default Spatial Layer* Image Layer Zoom Levels* WMS Address and Layers Spatial Querying PublicTitle: A top-level identifier for the exhibit, used to label the project in listings of exhibits on the public site.  URL Slug: A string of letters, numbers, and hyphens used to form the last part of the public-facing URL for the exhibit. For example, if your site is at http://www. neatline-site. org and the URL slug for an exhibit is wordsworth-in-the-alps, the URL for the public-facing version of the exhibit would be http://www. neatline-site. org/neatline/show/wordsworth-in-the-alps. Tip: As a convenience, the URL slug field is linked to the “Title” field, since you’ll often want the slug to “resemble” the title - as you type text into the “Title” input, a corresponding value will be automatically generated and inserted into the “Slug” field. For example, if you type “Wordsworth in the Alps” for the title, the slug will automatically read wordsworth-in-the-alps. If you want to change the automatic slug (for example, if the title for the exhibit is really long, and you want something shorter for the URL), just manually edit text in the slug field. Once you manually change the automatic value, Neatline assumes that you want to use the value that you entered, and the slug will stop auto-generating if you go back later and make a change to the “Title. ” Narrative: A piece of text to introduce, narrate, accompany, or otherwise generally support the exhibit. This could be anything from a short blurb up to a long-format scholarly essay or a monograph. How you use this field will often depend on how the site theme lays out the public-facing exhibit views - if the narrative is positioned below the exhibit, you might just want a snippet of introductory content; if it’s placed to the side of the exhibit and given more room, it might make sense to add more content.  In practice, it often makes sense to modify the theme according to the needs of the project - if you need a lot of supporting text, build the theme to accommodate it.  If needed, you can click on the ‘Source’ button in the formatting box to view and make edits to the html source code: Tip: The “Narrative” field integrates tightly with the NeatlineText widget, which makes it possible to connect individual paragraphs, sentences, and words in the “Narrative” content with records in the exhibit. For example, if “Narrative” contained markup like this: . . . &lt;span data-neatline-slug= paris &gt;Paris&lt;/span&gt; . . . And you had a record in your Neatline exhibit with a slug of paris, the word “Paris” in the narrative would be interactively linked with the location on the map, and vice versa. Accessible Alternative URL: An optional field for an alternate public-facing url for the exhibit. This public-facing site should be accessible for screen readers, and provide a complete textual description of the Neatline exhibit.  Widgets: The combination of user-interface widgets that are “activated” for the exhibit. Since widgets are installed as separate “sub-plugins” in Omeka, there won’t be any options available for selection by default. If you’ve installed the NeatlineWaypoints and NeatlineSimile sub-plugins, though, you’ll see two options in the menu that appears when you click the field: “SIMILE Timeline” and “Waypoints. ” Just click one or both of the options (or neither), and a block will appear in the box, indicating that the widget has been enabled for the exhibit. To remove, click the “x” to the left of the widget name.  For more, see Working with Neatline Plugins: SIMILE Timeline, Waypoints, Neatline Text Enabled Spatial Layers: The base layers that are available in the exhibit. All of these layers will be accessible by way of the “layer switcher” tool displayed in the top right corner of the map in the editing environment and public view. Like with the Widgets field, click on the input to display a list of layers, any of which can be clicked and added to the list of selections. To remove, click the “x” to the left of the layer name.  Default Spatial Layer: The default base layer that’s displayed when an exhibit is first accessed. This is an important selection, since the default layer will often strongly influence the visual aesthetic of the exhibit. The default layer selection is OpenStreetMap For more details on creating map-based exhibits, see here. Image Layer: The image url for a static image background layer. For more details on creating image-based exhibits, see here.  Zoom Levels: The total number of available zoom levels for your exhibit when using a static image background layer. The default zoom level is 20. You can further adjust related exhibit view settings from the Styles Tab within the Exhibit Editor.  Tip: Consider the size of your static image file when determining zoom levels, as your image may appear pixelated if more zoom levels are provided than the image can handle. WMS Address: The location of a web-accessible Web Map Service server like Geoserver. This field has to link directly to the WMS API endpoint on the server, such as: http://libsvr35. lib. virginia. edu/geoserver/hotchkiss/wms Note: When using the WMS Address and WMS Layer fields, select the option ‘None (Image or WMS as Deafult)’ for the “Default Spatial Layer. ” For more details on using these settings to create a custom map default layer, see here. WMS Layers: The specific WMS layer that you want assigned as the exhibit default spatial layer.  Note: Only one WMS Layer can be included in the Exhibit Settings, see Editing Imagery for including multiple custom map layers in your exhibit. Spatial Querying: This is selected by default, to continually render you map orientation and visible records.  Public: If left unchecked, the exhibit will be visible in the Omeka administrative interface, but not on the public site. Check the box to publish the exhibit to the web. This selection is unchecked (not public) by default. For more, see Publishing Exhibits.  Related: Map-based Exhibits, Image-based Exhibits, Managing Exhibits, Managing User Permissions, Publishing Exhibits "
        }, {
        "id": 17,
        "url": "https://neatline.org//docs/creating-records/",
        "title": "Creating Records",
        "body": "Creating RecordsAt a glance:  Records can be created directly inside of a Neatline exhibit.  Existing Neatline records can be individually linked to (and unlinked from) Omeka items at any point.  Omeka items can be bulk-imported into Neatline exhibits. Manually creating records inside of exhibits: The simplest way to add a new record is just to create one directly inside of the Neatline editor.    Open the editor for an exhibit by clicking on the exhibit’s title in the main browse view.     Click the “New Record” link just below the search bar.  This will open up an empty editing form for the new record. Important: Keep in mind that the record won’t actually be saved to the database until you click the “Save” button at the bottom of the form.  Connecting a Neatline record with an Omeka item: Once a record has been created in an exhibit, it can be “linked” back to an item in the Omeka collection:    Open the editing form for the record that you want to tie to an Omeka item (or click “New Record” if you want to start from scratch).     In the “Omeka ID” field, start typing the title (or any text that appears in any of the other elements) of the Omeka item that you want to associate the record with. As you type, a list of matching search results will autocomplete below the input.     Click on the name of the item that you want to link the record with. As soon as you click on the listing, the “Omeka ID” field will be populated with the item’s id, and the title will be inserted into the “Title” field.     Click the “Save” button at the bottom of the form. The “Body” field of the record will be populated by the compiled metadata output of the parent item (similar to the content that’s displayed on the default item “show” pages in Omeka).  Once the association is established, the Neatline record will update automatically whenever the Omeka item is changed. For example, if you changed the title of the record, or added a new file upload, the “Title” and “Body” fields would automatically reflect the new information when you view the Neatline exhibit. Important: Once you’ve associated a record to an Omeka item, you can’t make custom changes to the “Title” or “Body” fields. For example, if you change the title to something else, and then saved the record, the new value would be overridden by the Dublin Core “Title” field on the item. This is a deliberate restriction - if you find yourself wanting to tweak the content of the record - but don’t want to change the elements directly on the parent item - it may be an indication that the record shouldn’t be associated with an item, and should just be an unaffilliated record in the exhibit. That said, it’s quite possible that you might want to change the structure or layout of the compiled metadata output in the “Body” field. For example, imagine that you’re working with items that represent photographs - in the Neatline exhibit, you might want to hide some of the more nitty-gritty element texts on the items (eg, “Date” or “Published”), and just show the title, thumbnail, and description. To address this, Neatline makes it possible to completely customize the structure of the compiled “Body” fields at the level of the theme in the same way that you create a custom show. php template for the regular item pages. Head over to the “Theming Exhibits” guide for detailed instructions about how to do this. Related: Bulk-importing Omeka items, Searching Records, Adding Text Content, Drawing Geometry "
        }, {
        "id": 18,
        "url": "https://neatline.org//docs/docs-toc/",
        "title": "Docs Toc",
        "body": "Table of Contents - Neatline for Omeka ClassicGetting Started:  Welcome to Neatline! Neatline Architecture     Omeka: Standards-compliant Metadata   Neatline: Interactive Map-making Environment   Geoserver: High-performance Map Server    Installing Neatline     Before you start   Installing Omeka   Installing Neatline         Configuring the Neatline Plugin (for version 2. 5. 2 and above)     Google Maps API Settings          Installing Geoserver    Upgrading Neatline to 2. 0     What’s new   What’s different   Upgrading   Working with Exhibits:  Exhibits Overview     Exhibits Overview    Creating New Exhibits     Exhibit Settings   Title   URL Slug   Narrative   Accessible Alternative URL   Widgets   Enabled Spatial Layers   Default Spatial Layer   Image Layer   Zoom Levels   WMS Address and Layers   Spatial Querying   Public    Map-based Exhibits     Using the Provided Spatial Layers   Using a Custom Map Default Layer    Image-based Exhibits     Creating an Image-based Exhibit         Spatial Layers     Method 1: Using a Static Image     Method 2: Using WMS Layers           Managing Exhibits     Exhibit Title   Public View   Fullscreen View   Exhibit Settings   Import Items   Duplicate   Delete    Managing User Permissions     User Levels and Access   Working with User “Groups”    Publishing ExhibitsWorking with Neatline Plugins:  SIMILE Timeline     Definition   Enabling SIMILE Timeline for an Exhibit   Plugin Settings         Default Date     Interval Unit     Interval Pixels     Track Height     Tape Height          Adding an Item Record to the Timeline   Dates         Start and End Dates     After and Before Dates     Date Formatting     CE Dates     BCE Dates          Removing a Neatline Item from the Timeline   Disabling SIMILE Timeline for an Exhibit    Waypoints     Definition   Enabling Waypoints for an Exhibit   Adding a Waypoint For a Record   Removing a Waypoint For a Record   Waypoint Settings   Disabling Waypoints for an Exhibit    Neatline Text     Definition   Installation   Usage         Step 1: Create the Neatline records     Step 2: Create the Narrative             Editing a Shorter Text within the Built-in Editor       Editing Longer Texts with a Text Editor                     Theming   Working with the Neatline Editor:  Editor Overview     Records Tab   Styles Tab   Plugins Tab    Exhibit Styles Tab     Stylesheet Overview   Default Map Focus   Default Map Zoom   Restricted Map Extent   Minimum Map Zoom   Maximum Map Zoom    Using Neatline Stylesheets     Quick reference   Rationale: Why use stylesheets?   Getting started with stylesheets   Auto-updating stylesheet values   Records:  Records Overview Creating New Records Importing Omeka Items Searching RecordsEditing Neatline Records: Text Tab:  Adding Text ContentMap Tab:  Drawing Vector Annotations Editing Vector Annotations Importing SVG DocumentsStyle Tab:  Editing Groups Editing Colors Editing Opacities Editing Dimensions Editing Dates Editing Imagery Editing Visibility"
        }, {
        "id": 19,
        "url": "https://neatline.org//docs/editor-overview/",
        "title": "Editor Overview",
        "body": "Neatline Editor: An OverviewAt a glance:  The Neatline editor is the interactive application that allows users to build the content of their Neatline exhibit.  The Records tab within the editor is where you create and search for Neatline records, the content of your exhibit.  The Styles tab is where you can set an exhibit’s default focus and zoom and use the Neatline stylesheet.  The Plugins tab allows you to access settings for the enabled Neatline widgets in the exhibit. Editor Overview: The Neatline editor is the interface where you build the content of your exhibit. Access the editing enviroment by clicking on the exhibit title in the “Browse Exhibits” view. The left panel within the editor includes tabs for Records, Styles, and Plugins. If there are no plugins (/docs/widgets) enabled for the exhibit, the Plugins tab will not be displayed.  On opening the exhibit editor, your selected Default Spatial Layer will appear. For map layers, the default location is set at the coordinates 0° N, 0° E (/docs/to change your exhibit’s default location, see here. ) To view the Enabled Spatial Layers in your exhibit, click on the layers icon on the right side of the page, and select a layer option to change the visible map base layer:   Note: The Default Spatial Layer and Enabled Spatial Layers can only be set in the Exhibit Settings. Records: Select the Records tab to create, search and edit the Neatline records in your exhibit. Records are the primary content of the Neatline exhibit, including any vector annotations, timeline and waypoint context, WMS overlay layers, and text annotations in the exhibit narrative. For more on Records, see the related documentation: Records Overview, Creating New Records, Importing Omeka Items, Searching Records Styles: Select the Styles tab to edit higher-level settings for your exhibit. This section includes the following settings:  The Neatline Stylesheet, a code editor that uses a simplified, Neatline-inflected dialect of CSS to perform bulk updates on large groups of related records clustered together by tags (/docs/see Editing Record Groups for more information about tags).  Default Map Focus and Zoom Restricted Map Extent Minimum Map Zoom Maximum Map ZoomFor details on these settings, see Exhibit Styles Tab and Using Neatline Stylesheets. Plugins: Select the Plugins tab to display a drop-down list of the enabled widgets in your exhibit. Select a widget name to edit it’s higher-level settings. If this tab is not visible, there are no widgets enabled in your exhibit. For details on these settings, see documentation on Neatline plugins: SIMILE Timeline, Waypoints "
        }, {
        "id": 20,
        "url": "https://neatline.org//docs/exhibit-styles-tab/",
        "title": "Exhibit Styles Tab",
        "body": "Neatline Editor: Styles TabAt a glance:  Click the Styles tab in the editor to edit higher-level settings for your exhibit.  These fields define over-all view settings for your exhibit.  You can return to these settings at any time to make changes.  Jump to:     Stylesheet Overview   Default Map Focus   Default Map Zoom   Restricted Map Extent   Minimum Map Zoom   Maximum Map Zoom   Styles Tab: Stylesheet Overview: The Neatline Stylesheet is a code editor that uses a simplified, Neatline-inflected dialect of CSS to perform bulk updates on large groups of related records clustered together by tags (see Editing Record Groups). Instead of manually changing individual records, one by one, the stylesheet allows for updates to made automatically to grouped records. Neatline CSS treats record tags as “classes”, which allows for the use of a set of style properties to be defined in the stylesheet. For example, if you have a set of records tagged with the year 2012, and want to make changes to their fill color, include the following in the stylesheet: . 2012 {fill-color: #08c;}Instead of regular CSS rules, the Neatline stylesheet uses a specific set of rules that directly relate to the fields in the Record Style Tab, listed here:  widgets presenter fill-color fill-color-select stroke-color stroke-color-select fill-opacity fill-opacity-select stroke-opacity stroke-opacity-select stroke-width point-radius zindex weight start-date end-date after-date before-date point-image wms-address wms-layers min-zoom max-zoom map-focus map-zoomFor a more detailed information, see Using Neatline Stylesheets. Default Map Focus and Default Map Zoom: The Default Map Focus and the Default Map Zoom are the settings that determine the initial view of your exhibit, that is, the view seen when first opening the exhibit (in both the editor and in the Public View). A simple way to use this setting is to move the map to the exact location and zoom level, using your mouse to drag and zoom, or by using the navigation icons in the left-top corner of the map. Once you find your view, click “Use Current Viewport as Default” and the data will auto-fill. Click the blue “Save” button at the bottom of the panel to save the settings.  Restricted Map Extent: This setting controls how far your map or image extends, effectively restricting a viewer’s ability to change the exhibit’s focus. Restricted Map Extent does not control zoom levels (a viewer can still zoom in and out as far as allowed). This setting can be particularly useful if your exhibit has a specifc geographic setting, and you’d like to keep viewers within a region, and keep from getting lost elsewhere on the world map. Like the Default Map Focus and Default Map Zoom, this setting can be auto-filled by clicking “Use Current Map Bounds as Max Extent,” creating set boundaries for your exhibit. Click the blue “Save” button at the bottom of the panel to save the setting.  Minimum Map Zoom: This setting controls how far you can “zoom out” in your exhibit. Like the Restricted Map Extent, this setting is useful for creating boundaries for your exhibit, and can make the viewer’s experience better by limiting where they can move the map, effectively keeping the focus on the setting of your exhibit. Adjust your map to the furthest zoom level you want a viewer to experience, and click “Set Minimum Zoom to Current” to set. Click the blue “Save” button at the bottom of the panel to save the setting.  Maximum Map Zoom: Similar to Minimum Map Zoom, this setting controls how far a viewer can “zoom in” on your exhibit. To set, adjust your map to the closest, “zoomed-in” view you want a viewer to experience, and click “Set Maximum Zoom to Current. ” Click the blue “Save” button at the bottom of the panel to save the setting.  Related: Editor Overview, Using Neatline Stylesheets, Editing Record Groups, Editing Record Visibility "
        }, {
        "id": 21,
        "url": "https://neatline.org//docs/exhibits-overview/",
        "title": "Exhibits Overview",
        "body": "Neatline Exhibits: An OverviewAt a glance:  An exhibit is the “canvas” for a Neatline project, the environment in which the content is displayed.  Exhibit-level settings define basic, high-level defaults for the project (title, base layers, prose narrative, etc).  Each exhibit has its own editing environment, where you can create a collection of records (the contents of the exhibit).  Likewise, each exhibit has a separate page on the public-facing version of the website.  Each installation of Neatline can contain an indefinite number of exhibits. Exhibits Overview: Each Neatline project has its own exhibit, which can be thought of as the “canvas” or “environment” for the project - the set of base maps or images on top of which the content is displayed, the text narrative that introduces or describes the project, and the combination of user-interface widgets and components that are enabled for the project (timelines, lists of waypoints, etc). These high-level configuration options are defined using the Exhibit Settings form, which is used to both create new exhibits and edit existing exhibits. Once an exhibit has been created and configured, you can add content to the exhibit by opening the editing environment for the exhibit (generally called “the editor”), a specialized, interactive map-making application that makes it possible to create and manipulate a collection of records, which make up the actual content of the exhibit. Most of the work happens in the editor. You might spend just a couple minutes in the Exhibit Settings form, and a couple months building out the content in the editing environment. Continue reading documentation on Neatline exhibits:  Creating New Exhibits Map-based Exhibits Image-based Exhibits Managing Exhibits Managing User Permissions Publishing Exhibits"
        }, {
        "id": 22,
        "url": "https://neatline.org//docs/image-based-exhibits/",
        "title": "Image-based Exhibits",
        "body": "Image-based ExhibitsAt a glance:  Exhibits can be built on top of any static, web-accessible image (. jpg, . png, etc).  This makes it possible to use Neatline to create interactive editions of paintings, drawings, photographs, documents, and anything else that has some kind of two-dimensional, visual instantiation. Creating an Image-based Exhibit: To create an exhibit using an image base layer, follow the instructions for Creating New Exhibits, using the following Exhibit Settings: Spatial Layers: Leave the Enabled Spatial Layers selection empty, and select the option ‘None (Image or WMS as Deafult)’ for the Default Spatial Layer: There are two methods of creating image-based exhibits, depending on your needs:    Using a regular, static image: This method is easy to set up and doesn’t require any additional server infrastructure. However, there’s a fundamental limitation - since the entire image has to be loaded in bulk into the in-browser application (as compared to the spatial layers, which are loaded dynamically depending on the focus and zoom of the map), the performance of the exhibit will get worse as the image gets larger. Things work well if you’re working with a more or less normally-sized image (up to around 2-3000 pixels in height/width), but after that things start to get unacceptably sluggish.     Creating a custom WMS layer: If you need to use a really high-resolution image, there’s an effective workaround that involes essentially tricking Neatline into thinking the image is a spatial layer - you can “faux-georeference” the static image (just assign it random, meaningless spatial coordinates), load it into Geoserver as a WMS layer, and then import it into an exhibit as the sole base layer, with no map underneath. The image will be presented just as if you were using a regular static file, but you’ll have all the scability that comes with a dedicated tile server.  Method 1: Using a Static Image: To use a static image background layer, your image must be web-accessible. If you need a place to host an image file, add it as an item within your Omeka collection. Enter your image url into the Image Layer field: Provide a value for Zoom Levels. Consider the size of your static image file when determining zoom levels, as your image may appear pixelated if more zoom levels are provided than the image can handle. The default zoom level is 20.  Method 2: Using WMS Layers: Load your “faux-georeferenced” static image into Geoserver as a WMS (Web Map Services) layer. In the Neatline Exhibit Settings, fill in the the top-level WMS address for the GeoServer installation (this always ends with /wms, and might look something like localhost:8080/GeoServer/wms). In the field for WMS Layers, enter the layer that you want assigned as the exhibit base layer: Related: Creating New Exhibits, Editing Record Imagery, Editing Record Visibility, Installing Geoserver "
        }, {
        "id": 23,
        "url": "https://neatline.org//docs/importing-omeka-items/",
        "title": "Importing Omeka Items",
        "body": "Bulk-importing Omeka itemsSo far, we’ve manually created individual Neatline records and associated them with items in the Omeka collection. But what if you already have an existing collection of hundreds or thousands of items? Instead of manually creating Neatline records for each of the items individually, you can just bulk-import part or all of the collection into a Neatline exhibit:    Go to the main exhibits browse page and find the listing for the exhibit.     Click the “Import Omeka Items” link under the exhibit title.  Defining an item query: This takes you to the item import form. Think of this as a “search” form - you can use any of the available inputs to define a “query” on the Omeka archive that determines which items will be imported into the exhibit. For example, if you have a large archive with multiple collections, you might just be interested in working with one individual collection, and don’t want to clutter up the Neatline exhibit with all of the other unrelated items. The fields here work just like the corresponding options in the Omeka advanced search form:    Use Search by a Range of IDs to specify an individual ID (not so useful) or a range of IDs (more useful), and all items with IDs that fall within the specified range will be imported. This is a good way to import the entire collection all at once - just enter in an indiscriminate query like “1-1000,” which, as long as you have fewer than 1,000 items in your collection, will import all the items on the site. This is fine for experimentation, but in the long run, we generally recommend slicing and dicing the items into groups with collections or tags, which often prevents content management problems down the road.     Use Search By Collection to import to items in a given collection.     Use Search By Type to import items of a given type     Use Search By Tags to constrain the import to items that are tagged with all of the listed tags.  (Keep in mind that the fields are AND‘ed together, not OR‘ed - so, if you select a collection and enter a tag, the import will only match items that are both in the collection and have the tag. ) Once you’ve defined a search query, click “Import Items” to kick off the import. You’ll be taken back to the exhibit’s browse page, and you’ll see a success notification saying that “The item import was successfully started!” Important: Behind the scenes, this actually kicks off a “background process” that does the heavy lifting of importing the items. This is necessary because it can sometimes take up to 30-40 seconds to import really large collections of items (many thousands), and the process can fail if the web request times out (smaller imports, up to about 1,000 items, will generally finish in just a couple of seconds). When you’re first redirected to the exhibits browse view, though, the “# Items” counter for the exhibit will probably still be the same as it was before, since the import was started at the same moment that you were redirected. Refresh the page, though, and you’ll see the effect of the background process as it fills in the items. What happens if you add new items?: When the import is finished, open the editor for the exhibit. You’ll see new listings for all of the records that were matched by the import. When you open the edit form for one of the records, you’ll see that the “Omeka ID” field is populated with the ID of a corresponding Omeka item and that the “Title” and “Body” fields are populated with the item title and metadata output. Just as if the records had been manually linked to their parent items, any change to the items will be propagated to the imported records. But what if you then continue to add new Omeka items to the collection that would have been matched by the original import, and want to synchronize the Neatline exhibit with the new collection of items? Neatline expects this, and makes it easy - if you go back to the “Import Omeka Items” form for the exhibit, you’ll see that the original query has been saved, making it possible to re-run the identical query over and over again. When you run the query, Neatline will never duplicate an existing item-backed record in an exhibit, meaning that only the newly-added items will be imported. For example, imagine you import a collection that has 100 items. Later, you add another 20 items to the collection. If you want to vacuum up those new items into the Neatline exhibit, you can just re-run the same import query, and Neatline will only import the 20 new records and ignore the other 100 items that already have corresponding records in the collection. "
        }, {
        "id": 24,
        "url": "https://neatline.org//docs/installing-neatline/",
        "title": "Installing Neatline",
        "body": "Installing NeatlineAt a glance:  Installing Neatline is a two-step process - first install Omeka, then install Neatline as a plugin for Omeka.      Before you start   Installing Omeka   Installing Neatline         Configuring the Neatline Plugin (for version 2. 5. 2)     Google Maps API Settings           For projects that incorporate custom imagery, a third piece of software called Geoserver is necessary.      Installing Geoserver   Before you start: Omeka is a web application written with PHP and MySQL that runs on the “LAMP stack” (Linux, Apache, MySQL, and PHP), a ubiquitous set of technologies supported by almost any commercial or institutional hosting provider - many web hosts even provide an automatic “one-click” installer.  See the Hosting Suggestions guide in the Omeka documentation for a list of recommended providers. Alternatively, if you just want to experiment with Neatline in an offline setting, your can also install Omeka on a sandbox server environment running on your own computer using software packages like MAMP, WampServer, or XAMPP, with the option of migrating the site to a public-facing web host at any point in the future. Either way, you’ll need the following:  A server environment with PHP (5. 2. 11 or greater), MySQL (5. 0 or greater), and Apache.  Credentials for a MySQL user and the name of a database for the Omeka installation.  Permission to add and edit files to the server. For more detailed system requirements, see the Preparing to Install guide in the Omeka documentation. Installing Omeka: First, install Omeka by following the instructions in the Installation guide. Installing Neatline: Once Omeka is up and running, install the Neatline plugin:    Download the most recent version of Neatline, unpack the . zip archive, and move the Neatline folder into /plugins.     In the Omeka administrative interface, click on the Plugins link on the top navigation bar and find the listing for Neatline.     Click the Install button.  You’ll be redirected back to the list of plugins and see a notification saying that “The Neatline plugin was successfully installed. ” Over in the main vertical navigation on the left side of the screen, you’ll see a new listing for Neatline - click there to get started. Configuring the Neatline Plugin (for versions 2. 5. 2 and above):: Neatline users must now specify a Google Maps API Key to use the Google Map layers as a configuration step after installing the Neatline plugin. Neatline for Omeka Classic also comes with open source map options, Open Street Map and Stamen maps, which do not require an API key. Google Maps API Settings:    On the Plugins Screen, click the Configure button.      Click the link to open the Google Maps Developer’s page, and then click the Get a Key button.      On the Enable Maps Web APIs popup, enter a project name or click the down arrow to select the default name, My Project.      Once your Project Name has been entered, or the default My Project has been selected, click the Enable API button to generate your API key.      Copy the API Key and paste it into the Neatline plugin configuration text box.      Click the green Save Changes button. Your installation is now properly configured to use any of the Google base maps that are packaged with the Neatline plugin.  Installing Geoserver: With Omeka and Neatline installed, you can get started building exhibits on top of modern-geography base layers (OpenStreetMap, Google Maps, and Stamen Maps). For many use-cases, the default layers are more than sufficient, and no other action is necessary. For projects that need to incorporate custom imagery - for example, historical projects that want to overlay georeferenced maps on top of the default layers, or art history projects that need to use scans of paintings as base layers in exhibits - a third piece of software called Geoserver is necessary. Geoserver is a high-performance, open-source geospatial server that runs in a Java Servlet Container like Tomcat, Jetty, or JBoss. Basically, Geoserver is responsible for taking high-resolution GeoTIFF’s - images that are keyed onto spatial coordinates - and selectively doling out just the section of the image that’s necessary to fill the viewport as a user pans and zooms the map in Neatline. This is such a computationally-intensive task that it requires a separate, standalone piece of software. The OpenGeo Suite (community edition) maintains packages for several of the more popular operating systems to ease the management of upgrading and configuring GeoServer. That said, the process of installing and maintaining a Java server environment generally requires quite a bit more technical expertise than what’s needed to get up and running with Omeka and Neatline. Geoserver is built on top of a more complicated suite of technologies, and tends to need a higher level of ongoing maintenance. If you don’t have the resources to manage your own installation, there are a couple of options. First, if you’re associated with a a college or university, check to see if your institution could provide assistance - managing complex software like Geoserver is often the sort of thing that falls under the purview of central IT services. Second, you can always purchase Geoserver hosting from a commercial provider - we’ve had good experiences with AcuGIS, which actually provides all-in-one Geoserver, Omeka, and Neatline hosting (they have a one-click Neatline installer, and offer discounts for academic users). Check out their FAQ for more information. "
        }, {
        "id": 25,
        "url": "https://neatline.org//docs/managing-exhibits/",
        "title": "Managing Exhibits",
        "body": "Managing ExhibitsAt a glance:  In the “Browse Exhibits” view, click an exhibit’s Title to open the Neatline editor.  Click Public View to open the public-facing version of the exhibit visible to anonymous users.  Click Fullscreen View to open the fullscreen public-facing view.  Click Exhibit Settings to edit the default values entered when you created the exhibit.  Click Import Items to bulk-import Omeka items into the exhibit.  Click Duplicate to create a copy of the exhibit.  Click Delete to permanently remove the exhibit. Once you’ve created one or more exhibits, the “Browse Exhibits” view makes it possible to find, filter, edit, and display them. There are a list of options available for managing individual exhibits: Exhibit Title: Click on the exhibit title to open up the editing environment for the exhibit, which makes it possible to edit exhibit styles and enabled plugins, and to create the collection of records that constitutes the exhibit’s content. For more information, see documentation on the Neatline Editor and Records. Public View: Click here to view the exhibit as it appears on the public-facing version of the website. This view displays your exhibit’s Narrative, if included in the Exhibit Settings. You can preview the public view of your Neatline exhibit even if your exhibit is not published. For more on publishing your Neatline exhibit, see here. Fullscreen View: Click here to view the public-facing fullscreen version of your exhibit. Unlike the Public Vew, the Fullscreen View does not include the aesthetics of your Omeka Theme, or your exhibit’s Narrative. Exhibit Settings: Click here to re-display the form for the basic configuration settings that were defined when the exhibit was created (e. g. : Title, URL Slug, Base Layers). These values can be edited at any point after the exhibit has been created. For more on the Exhibit Settings, see here. Import Items: Click here to open the form that makes it possible to populate the exhibit with content by bulk-importing Omeka items. For more information, see Importing Omeka Items. Duplicate: Click here to create a duplicate of the Neatline exhibit. A copy of the exhibit will be created, and can be found in the “Browse Exhibits” view. The title of the duplicate exhibit will default as the original exhibit’s title, followed by “([your Omeka user name] copy)”. You can change the exhibit title any time in Exhibit Settings. Once created, the duplicate exhibit will exisit as a completely separate exhibit to the original. Any changes made to the original exhibit will not appear in the duplicate, or vice versa. Delete: Click here to permanently delete the exhibit. You’ll get a pop-up message asking for confirmation. Important: When an exhibit is deleted, it is completely removed from the database - along with all the records that belonged to it - and cannot be recovered. Related: Creating New Exhibits, Managing User Permissions, Publishing Exhibits, Importing Omeka Items "
        }, {
        "id": 26,
        "url": "https://neatline.org//docs/map-based-exhibits/",
        "title": "Map Based Exhibits",
        "body": "Map-based ExhibitsAt a glance:  Map-based exhibits are built on top of geospatial layers.  Neatline comes with a core collection of general-purpose spatial layers (OpenStreetMap, Google API layers, Stamen Design layers) that you can use as the base of your exhibit:     Using the Provided Spatial Layers    Neatline exhibits can also be customized, using completely custom tile sets delivered as WMS layers, MBTiles, or any other layer format supported by the OpenLayers mapping library:     Using a Custom Map Default Layer   Using the Provided Spatial Layers:: To create a map-based exhibit, follow the instructions for Creating New Exhibits, using the following Exhibit Settings: Enabled Spatial Layers: This field lists all geospatial layers available to your exhibit by default. These layers are accessible by way of the “layer switcher” tool displayed in the top right corner of the map in the editing environment and public view of your exhibit. Click on the input to display a list of layers, and click on a selection to add: Default Spatial Layer: Select a default spatial layer for your exhibit by clicking on the input to display the list of available layers, and click to select. This will be the layer that’s displayed when an exhibit is first accessed. This is an important selection, since the default layer will often strongly influence the visual aesthetic of the exhibit.  Using a Custom Map Default Layer:: Neatline exhibits can be customized using georectified historical maps or custom base layers, by publishing the layers to the web using a piece of software called Geoserver, an open-source geospatial server that does the computationally-intensive work of piping the georeferenced image tiles into the Neatline exhibits. See Installing Geoserver for more details. This option is especially useful for historic exhibits, where the contemporary default map layers may not accurately depict historic conditions. Georeferenced spatial layers also provide a method of bringing in other types of geographic spatial data you may have for your exhibit. See also: Tutorial: Neatline for Historical Maps by Kristen Mapes. Note: Using this method produces an exhibit with your custom WMS layer as the default layer, with a blank (white) background beyond the boundaries of your custom map. If your exhibit uses multiple historic or custom map layers, and/or you prefer to view your custom map as an overlay to the provided spatial layers (like OpenStreetMap), see the documentation section for Editing Imagery Enabled Spatial Layers: You may still want one or more of the provided spatial layers to be available in your exhibit, if so, follow the instructions above to add these. Default Spatial Layer:    Select the option ‘None (Image or WMS as Deafult)’ for the Default Spatial Layer.     Load your georeferenced map into Geoserver as a WMS (Web Map Services) layer. In the Neatline Exhibit Settings, fill in the the top-level WMS address for the GeoServer installation (this always ends with /wms, and might look something like localhost:8080/GeoServer/wms). In the field for WMS Layers, enter the layer that you want assigned as the exhibit default spatial layer.  (Note: only one WMS Layer can be included in the Exhibit Settings, see Editing Imagery for including multiple custom map layers in your exhibit. ) Related: Creating New Exhibits, Installing Geoserver, Image-based Exhibits, Editing Record Imagery, Editing Record Visibility "
        }, {
        "id": 27,
        "url": "https://neatline.org//docs/map-tab-drawing-geometry/",
        "title": "Map Tab Drawing Geometry",
        "body": "Drawing Geometry on the MapAt a glance:  The drawing controls under the “Map” tab make it possible to add vector annotations to the map.  There are three basic types of geometry - points, lines, and polygons.  The built-in tools are best suited for simple shapes that don’t require large numbers of points.  Activate the different drawing modes by selecting the corresponding radio buttons.  When you’re done drawing, switch back to the “Navigate” mode to avoid accidentally drawing more shapes. Navigate: Select the “Navigate” radio button to enable the default panning interaction with the map - click and drag to move the map in one direction or another, and use the scroll wheel on your mouse to zoom in and out. Tip: Think of Navigate as your “home base” - after sketching in new geometry with one of the drawing tools, it’s usually easiest to reactivate “Navigate” mode, which has the effect of turning off any of the drawing or modification tools. This means that you don’t accidentally add unwanted geometry the next time you click on the map.  Draw Point: Use this control to lay down individual points on the map.    Select the “Draw Point” radio button, move the cursor to the location on the map where you want to place the point, and click down once to drop the point.     To add multiple points, just click multiple times in different places.  Important: Points are displayed as circles on the map, but, in the underlying data, they’re actually represented as dimensionless pairs of lat/lon coordinates. Since they’re infinitely small and have no measurable “size” that can be correlated to the scale of the map, the points will always stay the same size, regardless of the zoom level of the map (the size of the circles can be controlled by the “Point Radius” field in the “Style” tab). Depending on the situation, this can be good or bad. For example, if you’re using points in conjunction with the “Point Image” feature to plot thumbnails of photographs onto the map, you might want the points to stay the same size at different zoom levels so that the preview images never become too big or too small. If you want a real geometric circle that changes size with the zoom level, use the “Draw Regular Polygon” tool.  Draw Line: Just like the “Draw Point” radio button, except that the points are connected by a line. To draw a line:    Select the “Draw Line” tool, move your cursor to the place on the map where you want the line to start, and click down once. Now, when you move the mouse, a line will connect the cursor to the location of the first point.     Click again to lay a second point. Keep on clicking to add multiple points. You can also draw a smooth line that automatically follows the movement of the cursor. Hold down the Shift key and then click and drag on the map. This lays down a new point for each individual pixel movement registered by the browser.     When you’re ready to lay down the final point, move your cursor to the place where you want the line to end and double click. This “completes” the line.  Tip: This feature has the effect of creating extremely dense geometry, which is very difficult to maintain (eg, if you decide later on that you want to change the shape of the line, you would have to manually move hundreds or thousands of individual points). If you need smooth, curvy shapes, always see if you can use the “Draw SVG” feature, which makes it possible to import easily-maintained vector graphics created in programs like Adobe Illustrator and Inkscape.  Draw Polygon: Just like “Draw Line,” except that the shape defined by the points is “closed” into a polygon as soon as you put down more than two points. To draw a polygon:    Select the “Draw Polygon” radio button, move your cursor to the place on the map where you want to place the starting “corner” of the polygon, and click down once.     Click again to lay a second point. Keep on clicking until to add multiple points. Like with the point tool, you can draw smooth shapes by holding down Shift, clicking down on the map, and dragging the cursor.     When you’re ready to lay down the final point, move your cursor to the place where you want the last corner of the shape and double click. This “closes” the polygon.   Draw Regular Polygon: “Draw Regular Polygon” creates closed shapes just like the regular “Draw Polygon” tools, but it doesn’t let you manually position the individual points - instead, it automatically creates a polygon with a given number of sides. This is useful if you want to create consistently-shaped geometric primitives (triangles, squares, circles, etc. ), and it can also be a good way to sketch in basic components of more complex shapes:    Select the “Draw Polygon” radio button and move your cursor to the place on the map where you want to position the center of the polygon.     Click down and, while still holding down on the mouse button, move the cursor in any direction away from the center point. As you drag the mouse, a polygon will be dynamically rendered on the map with a radius equal to the distance between the cursor and the center point. Rotate the cursor around the center point to change the orientation of the polygon.     When the polygon is positioned correctly, release the mouse button to lock the shape in place.  There are a couple of configuration options for the regular polygon tool:    Sides: The number of sides on the polygon. For example, 3 will draw triangles, 4 squares, etc. As this number gets higher, the resulting shape will smooth out into a circle/ellipse. This is a good way to create circular shapes with “real” diameters that will expand and shrink with the zoom level of the map (as opposed to the circles used to represent points, which are “dimensionless” and always stay the same size - see the “Draw Point” section). Don’t go overboard with the number of sides - in most cases, 30-50 sides is more than enough to create a smooth shape.     Snap Angle: As you drag the cursor away from the center point, the rotation of the polygon will “snap” into a series of fixed angles. This makes it possible to create a series of shapes with the exact same orientation on the map (eg, a series of rectangles with sides that are all perfectly aligned with the cardinal directions). This field controls the size of the angle between each of the consecutive rotations.  For example, if you set a snap angle of 30 degrees, it will only be possible to orient the shape in a couple of different ways; as you decrease the angle, the rotation becomes more granular, and at 0 the snapping is completely disabled.  Irregular: By default, all of the sides of the polygon are equal in length (eg, a 3-sided shape is always an equilateral triangle, a 4-sided shape is always a square, etc). Check this box to make it possible to create “skewed” shapes with sides of different lengths - rectangles instead of squares, ellipses instead of circles. Tip: This setting can have strange interactions with certain “Snap Angle” values - if you need to create an irregular shape, it’s generally easiest to set the snap angle to 0, drag out the shape, and then rotate it as needed with the “Rotate Shape” tool.  "
        }, {
        "id": 28,
        "url": "https://neatline.org//docs/map-tab-editing-geometry/",
        "title": "Map Tab Editing Geometry",
        "body": "Editing Vector GeometryAt a glance:  The editing controls under the “Map” tab make it possible to modify existing geometries on the map.  Annotations can be reshaped, rotated, resized, dragged, and deleted.  Activate the different editing modes by selecting the corresponding radio buttons.  When you’re done editing, switch back to the “Navigate” mode to avoid accidentally editing other shapes.  Use the “Clear all Geometry” button to delete all of the geometries for the record. Modify Shape: Use this mode to change the shape of lines or polygons created with any of the drawing modes. It can also be used to change the position of stand-alone points.    Select the “Modify Shape” radio button and click on the shape that you want to modify. Once the shape is selected, you should see a set of circular drag handles appear on top of each of the vertices in the shape.     To change the position of an existing vertex, just click down on the point’s drag handle, move the cursor to a different location, and release the mouse button to lock in the new location.     To add new vertices to the shape, click and drag on any of the translucent points that are displayed in the middle of each of the sides of the shape. This has the effect of bisecting the vertex - as soon as you release the mouse button, the drag handle will be converted into a regular point, and you can then continue to progressively add detail to the shape by re-bisecting the new edges.   Rotate Shape: Rotate an existing line or polygon.    Select the “Rotate Shape” radio button and click on the shape that you want to resize. Once the shape is selected, you should see a new “control point” appear to the bottom right of the shape.     Click and drag on the control point to rotate the shape.   Resize Shape: Expand or shrink an existing line or polygon.    Select the “Resize Shape” radio button and click on the shape that you want to resize. Once the shape is selected, you should see a new “control point” appear to the bottom right of the shape.     Click and drag on the control point to scale the shape.  Tip: If you want to change the size of the circle used to represent an individual point, head over to the “Style” tab and change the “Point Radius” option.  Drag Shape: Change the location of an existing point, line, or polygon.    Select the “Drag Shape” radio button and click on the shape that you want to drag. You should see a new “control point” appear right in the middle of the shape. If you’re dragging an individual point, the point will just change color to indicate that it has been highlighted.     Click and drag on the control point to change the center position of the shape.   Delete Shape: Delete an existing point, line, or polygon.    Select the “Delete Shape” radio button.     To delete a shape, just click once on the shape, and it will immediately be removed from the map.   Clear all Geometry: This button is similar to “Delete Shape,” but it deletes all vector annotations for the record. This can be useful when you’ve made a mistake of some sort (for example, when experimenting with different ways of positioning an imported SVG document) and want to just completely clear out your work.  "
        }, {
        "id": 29,
        "url": "https://neatline.org//docs/map-tab-importing-svg/",
        "title": "Map Tab Importing Svg",
        "body": "Importing SVG DocumentsAt a glance:  The basic drawing controls (points, lines, polygons) aren’t suitable for really complex illustrations.  Instead, it’s better to create the graphics in specialized vector editors and import them into Neatline.  Neatline can import SVG, a common format that can be generated by programs like Adobe Illustrator.  Once a SVG document has been imported, the geometry has all the same characteristics as hand-drawn shapes. Draw SVG: The standard “Draw Point/Line/Polygon” tools are good for simple, diagrammatic shapes - dots, rectangles, circles, simple arrows, etc. The problem, though, is that they don’t really scale well - what if you want to create a really smooth, intricate shape? Neatline exhibits are always exercises in information design, and there’s a class of “illustrative” annotation that doesn’t fit well into the blocky aesthetic supported by the standard-issue GIS tools. You could painstakingly sketch out complex illustrations using the line and polygon tools, but the resulting geometry is brittle and difficult to maintain. What if you decide later on that you want to change the drawing? You’d have to manually reposition hundreds or thousands of points. To address this problem, Neatline 2. 0 introduced the “Draw SVG” tool, which makes it possible to create high-fidelity, easily-maintained illustrations in specialized vector editing programs like Adobe Illustrator or Inkscape (and even in-browser tools like SVG-Edit) and import them directly into the Neatline editor. This way, you can do the difficult work of vector illustration in tools that are specifically designed for that task, and then drop the final products into Neatline exhibits. Later on, if you want to change something about the drawing, you can just go back to the original source file, make the change, and then update the Neatline exhibit with the new content. Neatline reads a commonly-used serialization format called SVG (Scalable Vector Graphics), a form of XML that encodes geometric information. To start, you’ll need to save off your vector file as an SVG document. Generating the SVG document: Using Adobe Illustrator:    Click File &gt; Save As.     In the “Format” drop-down menu, select “SVG (svg). ” The “SVG Options” modal should be displayed.     In the “Fonts” fieldset, set “Type” to Convert to outline. This ensures that text elements in the document will be saved as raw geometric paths, not abstract &lt;text&gt; elements that can’t be parsed by Neatline.     Click OK to save.  Using Inkscape:    Before saving, if you have any text elements in the document, first convert them to raw path elements by selecting them and entering Ctrl+Shift+C (see the documentation for more information. )     Click File &gt; Save As.     In the dropdown menu for the format, select Plain SVG.     Click Save.  Importing the SVG into Neatline: Once the SVG document is saved off, we can import it into Neatline:    Find the . svg file that was created in the previous step. Open it with a plain text editor or a code editor by right clicking on the file and choosing a program from the list of options in “Open With. ” It doesn’t matter what you use - as long as you can get at the raw SVG output.     You should see a soup of dense XML markup with lots of numbers. Copy the content of the entire document to the clipboard.     Go back to the Neatline editor and click on the Enter Markup link next to the Draw SVG option.     Paste the SVG markup into the “SVG” box.     Optionally, set a custom “Density” value. This field controls the number of points that Neatline will generate when converting SVG &lt;path&gt; elements to hard-coded spatial coordinates - low numbers produce “blocky” shapes, high numbers produce “smooth” shapes.     Click Parse. Behind the scenes, Neatline converts the SVG markup into geospatial coordinates.     Now, you can drag the SVG document onto the map in the same way that you would drag out a regular polygon shape. Move the cursor to the location on the map where you want the bottom left corner of the illustration to be located, click down, and move the cursor in any direction. The illustration will scale and rotate according to the position of the mouse.     When the illustration is positioned correctly, release the mouse button to lock the geometry into place.   Tip: It’s easy to make mistakes when doing this, and it often takes a couple tries to get things right. If you mess up, it’s easiest just to totally wipe out the previous attempt by clicking the “Clear all Geometry” button at the bottom of the form. "
        }, {
        "id": 30,
        "url": "https://neatline.org//docs/neatline-from-10000-meters/",
        "title": "Neatline Architecture",
        "body": "Neatline from 10,000 MetersAt a glance:  Neatline is built as a set of plugins for Omeka, a web publishing framework designed for scholars and archivists.  Neatline adds an interactive map-making environment that makes it possible to create Neatline exhibits, each of which is populated with its own collection of records, which can optionally be synchronized with items in the underlying Omeka collection.  Neatline can be used out-of-the-box with modern geography base layers like OpenStreetMap or the Google API layers. If you want to add custom base layers or overlays, you’ll need to host them using a piece of software called Geoserver. Omeka: Standards-compliant Metadata: Neatline is built as a suite of modular plugins for Omeka, a digital collection-management and web-publishing framework developed by the Roy Rosenzweig Center for History and New Media at George Mason University. Omeka is similar to other popular content management systems like Wordpress or Drupal, but it’s designed specifically around the needs of scholars and archivists. Omeka makes it posible to create and curate a collection of “items” (the rough equivalent of a Wordpress “post” or a Drupal “node”), each of which is a fully-qualified Dublin Core metadata record. Once you’ve built out a collection of items using the Omeka administrative interface, the collection is automatically published as a public-facing website, which can be tailored to the needs of specific projects with custom themes and plugins. Neatline: Interactive Map-making Environment: Building on the foundation provided by Omeka, Neatline is a plugin that grafts new functionality onto the core Omeka feature set. Neatline adds an interactive map-making environment that makes it possible to create Neatline exhibits, each of which is populated with its own collection of records, which can optionally be synchronized with items in the underlying Omeka collection. Think of exhibits as the “canvas” for a project, records as the “paint strokes. ” Exhibit-level settings control basic defaults like the starting base layer, the focus location of the map, and which of the mix-and-match UI widgets are enabled for the exhibit. Meanwhile, content inside the exhibits is represented as a collection of records, each of which corresponds to some kind of visual or textual entity in the environment - vector annotations on the map, events on the timeline, overlayed historical maps, textual annotations in the exhibit narrative, or clickable waypoints. Geoserver: High-performance Map Server: Out of the box, Neatline can be used to build exhibits on top of a collection of modern-geography base layers - the OpenStreetMap tile set, the Google Maps API, and a collection of stylized layers created by a design firm in San Francisco called Stamen Design. If you want to use Neatline with georectified historical maps or custom base layers, you’ll need to publish the layers to the web using a third piece of software called Geoserver, an open-source geospatial server that does the computationally-intensive work of piping the georeferenced image tiles into the Neatline exhibits. For more, see Installing Geoserver. "
        }, {
        "id": 31,
        "url": "https://neatline.org//docs/neatline-stylesheets/",
        "title": "Neatline Stylesheets",
        "body": "Styling Exhibits with Neatline-Flavored CSSAt a glance:  Neatline 2. 0 makes it possible to use a dialect of CSS to perform bulk updates on large groups of records.  Neatline-inflected CSS uses a custom set of rules that correspond to the properties on the record data model.  Groups of records are selected using the CSS class syntax, with record tags providing the class names. Quick reference (for the impatient): Neatline 2. 0 makes it possible to use a simplified, Neatline-inflected dialect of CSS - integrated directly into the editing environment - to perform bulk updates on large groups of related records clustered together by tags (see the “Editing Record Groups” guide for more information about tags). All exhibits have a built-in stylesheet:  Open the editing environment for an exhibit.  Click on the Styles tab. Right under the tab, you’ll see a code editor labelled “Stylesheet. ”Neatline CSS is syntactically identical to regular CSS, but semantically a bit different:  Instead of using DOM selectors, Neatline CSS just treats tags on records as “classes. ” So, if you have a group of records that are tagged with democrat, you can select them as if “democrat” were a class on an HTML element: . democrat {   fill-color: #08c;   stroke-width: 5; }  To match all records in the exhibit, use the special . all tag: . all {   fill-color: #08c;   stroke-width: 5; }  You can’t match multiple tags with the same selector (we’re hoping to add this soon). For now, this won’t work: . democrat, . republican {   fill-color: #08c;   stroke-width: 5; }    Instead of using regular CSS rules, use a special set of rules that map onto properties in the Neatline data model (and, by extension, to the fields in the “Style” tab in the record edit form):      widgets   presenter   fill-color   fill-color-select   stroke-color   stroke-color-select   fill-opacity   fill-opacity-select   stroke-opacity   stroke-opacity-select   stroke-width   point-radius   zindex   weight   start-date   end-date   after-date   before-date   point-image   wms-address   wms-layers   min-zoom   max-zoom   map-focus   map-zoom   Rationale: Why use stylesheets?: Neatline 2. 0 makes it possible to work with really large collections of records - as many as about 1,000,000 in a single exhibit. That level of scalability is liberating, but it also introduces some interesting new content management challenges. If the map can display that many records, there also need to be new tools that make it possible to effectively update and maintain content at that scale. For example, imagine you’re plotting returns from the last four presidential elections. You import a big collection of about 800,000 records, 200,000 for each of the four elections. Each record represents an individual precinct somewhere in the country with a dot on the map, scaled according to how many votes were cast at the location and shared red or blue depending on which party won more votes. Once the data is loaded into Neatline, you realize that you want to change the shade of blue used to represent the democratic precincts. How do you do that, short of manually making the change on all ~400,000 democratic records? This is obviously a problem with really massive data sets, but, as you work with Neatline, you’ll find that this type of problem rears its head surprisingly quickly, even with quite small exhibits in the 50- to 100-record range. The essence of the problem is this - records are almost never “unique snowflakes” in the exhibit. They almost always exist as part of some kind of general taxonomy or grouping in the exhibit - democratic, 2012, northeast, etc. And, in almost every case, those groupings should share some common attributes. All democratic records should be the same shade of blue; all precincts from 2004 should be visible on the map during the same range of dates; all precinct records should have the same basic opacity settings; ad infinitum. But, as you can see, they shouldn’t share all of their attributes - all 2004 precincts should share the same range of dates (the “After Date” and “Before Date” fields), but they most definitely should not share the “Fill Color” field, since that would clobber out the all-important distinction between the blue democratic records and the red republican precincts. In other words, different groups of records need to share different sets of attributes. We can map this out schematically. Here’s a list of all the “categories” in the exhibit, and the fields that should be shared for each of the categories:  All Precincts: Fill Opacity, Stroke Width Democratic: Fill Color Republican: Fill Color 2000: After Date, Before Date 2004: After Date, Before Date 2008: After Date, Before Date 2012: After Date, Before DateHow do we keep the groups synchronized? Really, this is a familiar problem - it’s almost exactly the same task as styling web pages with CSS (Cascading Style Sheets), a simple styling language that makes it possible to “select” specific parts of a page and apply a set of rules to those elements. In Neatline 2. 0, it’s possible to use a simplified dialect of CSS - integrated directly into the editing environment - to model these kinds of relationships among records and keep them in sync. In Neatline, the stylesheet system is closely tied to the tagging system. Tags are just comma-delimited lists of identifiers that can be added to each individual record under the “Style” tab in the record edit form. In this example, individual records in the collection might have tag strings that look like this:  precinct, democrat, 2000 precinct, republican, 2000 precinct, democrat, 2012 state, republican, 2008Getting started with stylesheets: Let’s start by defining some basic, generic styles for the each of the precincts, which are all represented as dots on the map: . precinct { fill-opacity: 0. 5; stroke-width: 0;}Now, when I click “Save” at the bottom of the form, Neatline will update the “Fill Opacity” and “Stroke Width” of all 800,000 records tagged as precincts with 0. 5 and 0. Next, let’s add the date visibility settings for each of the three election-season tags: . 2000 { after-date: 2000; before-date: 2004;}. 2004 { after-date: 2004; before-date: 2008;}. 2008 { after-date: 2008; before-date: 2012;}. 2012 { after-date: 2012; before-date: 2016;}Likewise, when I click “Save,” Neatline will update the “After Date” and “Before Date” fields on each record depending on which election-season is assigned to it. Auto-updating stylesheet values: This is all fine and well, but what if we don’t actually know what value we want to use? In each of these cases, we’re working with fields that have fairly “semantic” values that we can reason about in the abstract (eg, 2004 just means what it means). This isn’t always true, though, notably in the case of colors, where it’s impossible to reason in the abstract about which specific hexadecimal value you want to use. For example, I know that I want the democratic precincts to be “blue” and the republican precincts to be “red,” but I don’t know that I want to use #206bbf and #9d0000. You could always just open one of the individual record forms, use the built-in color pickers to find a color that works well, and copy and paste it back into the stylesheet. This is sort of awkward, though. To fix this, Neatline makes it possible to just “activate” a set of styles for a tag in the stylesheet without providing a concrete value, and then set the value for the entire group of tagged records by making a change to an individual record. We do this with the special auto value: . democrat { fill-color: auto;}. republican { fill-color: auto;}Once this is in place, I can just open up any of the individual republican precinct records and pick a shade of red for that specific record. When I click “Save,” Neatline recognizes that the “Fill Color” style has been enabled for the republican tag, and that the record being saved is tagged as republican. When this happens, Neatline does two things. First, it updates the stylesheet with the new value: . republican { fill-color: #9d0000;}And, second, it immediately propagates the new value to all of the other republican records, just as if the stylesheet had been directly saved. This actually works for all styles, even ones that already have concrete values in the stylesheet (as opposed to auto). For example, if I opened up one of the precinct records and changed the value of “Fill Opacity” to 0. 7, and then saved that individual record, the fill-opacity rule under the precinct tag in the stylesheet would be updated with the new value and all of the precincts would be updated with the new value of 0. 7. Effectively, this means that it’s impossible for the records and the stylesheet to get out of sync - changes made to the stylesheet are immediately propagated out to the records, and changes made to individual records are immediately pushed back into the stylesheet. Here’s the complete stylesheet: . precinct { fill-opacity: 0. 5; stroke-width: 0;}. 2000 { after-date: 2000; before-date: 2004;}. 2004 { after-date: 2004; before-date: 2008;}. 2008 { after-date: 2008; before-date: 2012;}. 2012 { after-date: 2012; before-date: 2016;}. democrat { fill-color: #206bbf;}. republican { fill-color: #9d0000;}"
        }, {
        "id": 32,
        "url": "https://neatline.org//docs/publishing-exhibits/",
        "title": "Publishing Exhibits",
        "body": "Publishing Neatline ExhibitsBy default, Neatline projects are not accessible to the public unless you choose to publish to the web. To make your exhibit public, check the box in Exhibit Settings for Public and click “Save Exhibit”: Your project is now available for the public to explore online! To see the public view of your exhibit, return to the main “Browse Exhibits” page, and under the title of your exhibit, select either Public View or Fullscreen View. Take note that you can preview both of these views even if your exhibit is not public.  Within the Exhibit Settings, you can also create a custom URL Slug for the public-facing site, or provide an Accessible Alternative URL for screen readers. The over-all look of the public site for your Neatline exhibit is determined by your selected Omeka Theme. Related: Creating New Exhibits, Managing Exhibits "
        }, {
        "id": 33,
        "url": "https://neatline.org//docs/records-overview/",
        "title": "Records Overview",
        "body": "Neatline Records: An OverviewAt a glance:  All pieces of content in a Neatline exhibit are records.  Records can appear in multiple contexts (map, timeline, etc).  Optionally, records can be associated with Omeka items. Everything is a record: Records are the fundamental unit of content in Neatline exhibits. In Neatline, everything is a record - vector annotations on the map, plottings on the timeline, listings in the waypoints tray, WMS overlay layers, text annotations in the exhibit narrative, and any other content displayed by sub-plugins. Depending on the type of information that’s entered into the record metadata, the same record could be displayed more than once in the same exhibit. For example, if a record has both a geometric annotation value in the coverage field and a defined value for the start_date, it will be displayed both as a shape on the map and a point on the timeline. When this is the case, Neatline will automatically link all instantiations of the record - when the user clicks on the span on the timeline, the map will zoom to the corresponding location, and vice versa. The record data model: All records share a common data model. Similar to elements on Omeka items, all fields are optional.  Title: A top-level, human-readable identifier. Used as a label for the record. Eg: “War and Peace” Slug: A plain-text ID for the record, used to reference the record from TEI or HTML. Eg: war-and-peace Body: The main content of the record. Could be a short blurb, a long-format essay, a video, etc.  Coverage: A WKT string that defines a geometric annotation on the map (point, line, polygon, etc).  Tags: A string of comma-delimited tags used to slice and dice the collection into related subgroups.  Presenter: The mechanism by which the record content is displayed (static bubble, floating bubble, etc).  Widgets: Which of the “viewports” the record is visible in (timeline, waypoints browser, etc).  Fill Color: The color of polygons on the map. Also used as the default color in other contexts.  Fill Color (Selected): The color of map polygons when the record is highlighted or selected.  Stroke Color: The color of the lines running around the edges of polygons on the map.  Stroke Color (Selected): The color of the lines when the record is highlighted or selected.  Fill Opacity: The opacity (translucency) of the polygons on the map.  Fill Opacity (Selected): The opacity of map polygons when the record is highlighted or selected.  Stroke Opacity: The opacity of lines running around the edges of polygons on the map.  Stroke Opacity (Selected): The line’s opacity when the record is highlighted or selected.  Stroke Width: The thickness, in pixels, of the lines around polygons.  Point Radius: The size of individual points on the map.  Z-Index: The “stacking” order of records when displayed on the map.  Order / Weight: Used to determine the display order of a record in relation to other records.  Start Date: The beginning of the event that the record describes.  End Date: The end of the event that the record describes.  After Date: The date after which the record should be displayed in the exhibit.  Before Date: The date before which the record should be displayed in the exhibit.  Point Image: A web-accessible image used to display individual points on the map.  WMS Address: The location of a WMS server (eg, an installation of Geoserver).  WMS Layers: A comma-delimited collection of layers (hosted on the WMS server) to be overlayed on the map.  Min Zoom: The map zoom level above which the record is visible (where zooming “in” is “higher”).  Max Zoom: The map zoom level below which the record is visible.  Default Focus: The lat/lon coordinates that the map zooms to when the record is selected.  Default Zoom: The zoom level that the map zooms to when the record is selected. Neatline records vs. Omeka items: Even though all records share the same data model, they can be divided into two basic categories - exhibit-specific records that exist just inside of a single exhibit, and item-backed records that link back to items in the Omeka collection. The two types behave exactly the same, with one exception - if a Neatline record is associated with an Omeka item, the record’s “Title” and “Body” fields will be automatically compiled from the content in the Omeka item. The title will be filled in with the item’s Dublin Core “Title” field, and the “Body” will be populated with the compiled metadata output of the entire item. Once the association is established, the content in the Neatline record will be automatically updated whenever the Omeka record is changed. Why does Neatline make this distinction? Why aren’t records just the same thing as items? In the early stages of development, there actually was a one-to-one correspondence between Omeka items and Neatline records - records were just the direct instantiations of Omeka items in a specific Neatline exhibit. The problem, though, is that Neatline exhibits often require a body of “annotative” or “supporting” information that doesn’t really fit well in the context of an archival collection. For example, imagine you’re working with a collection of correspondence - each letter in the collection is represented by a canonical Dublin Core record in Omeka. Then, when you pull the letters into a Neatline exhibit, you start to sketch in arrows, brackets, flowcharts, and other little bits of presentational information to support the core archival objects. This supporting information is essential in the context of the exhibit, but almost meaningless in isolation, and it often doesn’t make sense to formalize all of these elements as first-class archival entities - it’s not the best practice to have items like “Blue Arrow 4” or “Outline of New York” mixed heterogeneously into the collection of letters. To get around this problem, Neatline makes it possible to create these exhibit-specific, “unaffiliated” records can be used to formalize this type of annotative information, while also making it possible to create records that link back to the durable archival resources in the Omeka collection. This way, we get the best of both worlds - we can integrate seamlessly with the content in Omeka, and also choose not to integrate with it when doing so would degrade the integrity of the collection. "
        }, {
        "id": 34,
        "url": "https://neatline.org//docs/searching-records/",
        "title": "Searching Records",
        "body": "Searching for RecordsAt a glance:  Use the forward and backward arrows to page through the records.  Enter plain-text queries to search in the “Title,” “Body,” and “Slug” fields.  Type tags: &lt;tag1&gt;, &lt;tag2&gt;, . . . to search by tags.  Type map: to make the record list mirror the currently-visible records on the map.  Clear the search box to show all records. When there are just a handful of records in an exhibit, it’s easy to keep track of everything. But what if there are 1,000 records, or 100,000? In Neatline 2. 0, it’s possible to work with really large collections of records - as many as about 1,000,000 in a single exhibit. If the exhibit can display that quantity of information, though, there need to be tools to effectively manage information at that scale. To help with this, Neatline provides some useful searching and filtering tools: Tip: As you use the pagination and searching tools, you’ll notice that the URL is dynamically updated to represent the current “query” on the collection. For example, you’ll see URL’s like:  /neatline/editor/1#records/search/start=100 /neatline/editor/1#records/search/query=keywords /neatline/editor/1#records/search/query=keywords/start=100These are all “durable” links, meaning that they’ll point back to the same set of results if you copied and pasted into a different browser window. Pagination buttons: To make it easier to browse through the content of an exhibit, Neatline splits apart large collections of records into a series of “pages,” each containing a fixed number of records (by default, 50). When you first start building an exhibit, the pagination buttons will be hidden, since there aren’t enough records yet to spill over onto a second page. As soon as you go over the paging limit, though, you’ll see the forward and backwards buttons to page back and forth through the content. Search for keywords: To find records by regular, plain-text search queries, just enter search terms into the “Search” box at the top of the content management pane in the editor. As you type, Neatline will immediately query the underlying collection and update the list with the set of matching records. Fulltext search looks for the terms in each of the three text-based fields - the “Title,” “Body,” and “Slug. ” When you’re finished searching, just empty the search box to go back to complete, unfiltered list of records. Search for tags: If you’ve added tags to your records (for more information about Neatline’s tagging system, see the “Editing Groups” guide), there’s a special search syntax you can use to search for records that have a given tag. For example, if you want to find all records that are tagged with tag1, enter: tags: tag1 To search for records with multiple tags, just enter a comma-delimited list: tags: tag1, tag2, tag3, . . . Search by location: Sometimes, the map itself is the best mechanism for finding records - if you know where the records are that you’re interested in, you can enter a special query that will cause the records in the left panel to automatically synchronize with the collection of records that’s currently visible on the map. Just enter: map: As soon as you enter this query, the previous list of records will be replaced by the exact set of records that are currently visible on the map. When you pan or zoom the viewport on the map and a fresh batch of records is loaded, the list of records in the editing pane will automatically update to display the new collection from the map. To disable the search-by-location mode, just clear out the search box. "
        }, {
        "id": 35,
        "url": "https://neatline.org//docs/style-tab-colors/",
        "title": "Style Tab Colors",
        "body": "Editing Record ColorsAt a glance:  Color values are stored as hexadecimal values.  To change a color field, click anywhere on the input and use the interactive color picker widget.  As you change the color, new value will be automatically previewed on the map.  If you want to use a specific value, just paste the value into the text input below the color picker. Examples::  #ffffff #000000 #c4d243 #08cFill Color: The hexadecimal color value of the “body” or “area” of points and polygons on the map (the area inside the lines, not including the lines themselves). Also used as a default color for the record in other contexts. For example, if the record has date information, the fill color is used to render the plotting that represents the record on the timeline.  Fill Color (Selected): The hexadecimal color value of the “body” or “area” of points and polygons on the map when the record is highlighted or selected (eg, when the cursor hovers or clicks on the shape).  Stroke Color: The hexadecimal color value of the lines that run around the edges of a shape on the map.  Stroke Color (Selected): The hexadecimal color value of the lines that run around the edges of a shape on the map when the record is highlighted or selected (eg, when the cursor hovers or clicks on the shape).  "
        }, {
        "id": 36,
        "url": "https://neatline.org//docs/style-tab-dates/",
        "title": "Style Tab Dates",
        "body": "Editing Record DatesAt a glance:  If a record represents an event, these fields store when the event occurred and how long it lasted.  They can also be used to control when a record is be visible in the exhibit.  Important: All dates must be entered in a portable, standards-compliant format called ISO 8601.  To display temporal information, you’ll need to install a widget like NeatlineSimile. Examples:: CE Dates  1564 - The year 1564.  1564-04 - April, 1564.  1564-04-23 - April 23, 1564.  1564-04-23T08:30 - 8:30 AM on April 23, 1564.  1564-04-23T08:30:15 - 15 seconds after 8:30 AM on April 23, 1564. BCE Dates  -001563 - The year 1564 BCE.  -000563 - The year 564 BCE.  -000063 - The year 64 BCE.  -000003 - The year 4 BCE.  -001563-04 - April, 1564 BCE.  -001563-04-23 - April 23, 1564 BCE. Start Date: The “first” or “beginning” date for an event. If the event is an instant (it happened exactly once, and did not occupy any kind of duration or interval of time), enter the date of the instant in this field. If you’re working with NeatlineSimile: If you just enter a “Start Date” and leave “End Date” blank, the record will be displayed as point on the timeline. End Date: The “last” or “finishing” date for an event. If you’re working with NeatlineSimile: If you enter a “Start Date” and an “End Date” date, the record will be displayed as a span (line) on the timeline. If you enter the same date for the “Start Date” and “End Date,” the span will have width = 0 and will, therefore, be invisible on the timeline.  After Date: The date after which the record should be displayed in the exhibit. If you’re working with NeatlineSimile: If an “After Date” is defined, then the record will only be displayed on the map when the timeline is centered on a date that falls after this date. For example, imagine you’re working with a record that’s plotted as a point on the map. If you set the “After Date” to 2000, then the point will disappear when you scroll the timeline back to 1999, and reappear when you scroll forward to 2001. Before Date: The date before which the record should be displayed in the exhibit. If you’re working with NeatlineSimile: If a “Before Date” is defined, then the record will only be displayed on the map when the timeline is centered on a date that falls before this date. Again, imagine you’re working with a record that’s plotted as a point on the map. If you set “Before Date” to 2000, then the point will disappear when you scroll the timeline forward to 2001, and reappear when you scroll back to 1999. If both a “After Date” and a “Before Date” are defined, then the record will only be visible when the timeline is within the duration between the two dates. For example, if “After Date” is 2000, and “Before Date” is 2010, the record would be visible between those two dates, but not before 2000 or after 2010. By stringing together collections of records with different after- and before-dates, it’s possible to create complex time-series animations "
        }, {
        "id": 37,
        "url": "https://neatline.org//docs/style-tab-dimensions/",
        "title": "Style Tab Dimensions",
        "body": "Editing Record DimensionsAt a glance:  These fields control the size of different aspects of the presentation of the record.  And (a) the sequence or ordering of a record in relation to other records in the exhibit.  Dimension values are stored as natural numbers (integers greater than 0).  To change a dimension, you can type directly into the field.  Or you can click on the field and drag up or down on the page, causing the value to change smoothly.  When the “Stroke Width” and “Point Radius” fields are changed, the new value will automatically preview on the map. Stroke Width: The width, in pixels, of the lines that run around the edges of a shape on the map. Generally, it makes sense to keep this value in the range of 0-10 - anything more and the lines will start to “clump” together and blot out the shape of the polygon, especially when the map is zoomed back away from the vectors. In some cases, it can be aesthetically pleasing to completely hide the lines, and just display the “area” of points and polygons on the map. To do this, just set the stroke width to 0.  Point Radius: The radius of individual points on the map. You’ll almost always want this value to be greater than 0 - otherwise, points will be invisible, in which case they should probably just be deleted. If you’re making use of the “Point Image” field to change the visual representation of points (see the “Editing Record Imagery” guide), this field will also determine the size of the image graphics overlayed on the map. Important: The point radius is a static value, meaning that the size of the points on the map won’t change with the zoom level of the map, as a polygon or line would. This is because points are actually just dimensionless pairs of lat/lon coordinates. Since they’re infinitely small and have no measurable “size” that can be correlated to the scale of the map, the points will always stay the same size, regardless of the zoom level of the map Z-Index: The “stacking” order of vector annotations and WMS layers on the map. For example, imagine you have one record that includes a polygon that traces the shape of Manhattan, and another record that traces the shape of Central Park. Since Central Park is contained inside of Manhattan, you’ll want the Central Park polygon to be displayed “on top of” the Manhattan polygon - otherwise, it would be impossible for the user to click on Central Park. Z-indexes are just relative numbers that control the display order, with higher numbers stacking above lower numbers. So, in this case, you could set the Z-Index on Manhattan to 1, and the Z-Index on Central Park to 2, and Central Park would always be displayed on top of Manhattan.  Order / Weight (Experimental, subject to change): The display order of a record relative to other records. This is similar to the “Z-Index,” but designed to be used in situations where records need to be put into a specific, unambiguous sequence (ie, where no two records can be in the same position in the sequence, as opposed to stacking order, in which multiple records can exist on the same “layer” or “level”). For example, this field is automatically populated by the Neatline Waypoints plugin to store the display order of records in the waypoints panel, a list of clickable record titles displayed on the map. Important: For now, this is an abstract field that has no direct effect on out-of-the-box Neatline exhibits. It’s included in the current version to make it possible for sub-plugins to store ordering information about records. Unless you’re using a sub-plugin that makes use of the field, it usually makes sense just to leave it blank.  "
        }, {
        "id": 38,
        "url": "https://neatline.org//docs/style-tab-groups/",
        "title": "Style Tab Groups",
        "body": "Editing Record GroupsAt a glance:  The Tag and Presenter options are on the Style tab of the Neatline editor.  Use tags to slice and dice large collections into subsets of related records.  Tags can be used as the “selectors” for Neatline’s stylesheet system, which uses a simplified dialect of CSS.  Each record is assigned to a “Presenter,” which controls how the record’s content is displayed. Tags: The tags field takes a comma-delimited list of one or more tags. For example:  virginia precinct, democrat, 2004 precinct, republican, 2012 confederate, may_3 union, may_4Neatline’s tagging system provides a powerful and flexible way to slice and dice records into groups of related subsets. This can be useful for a number of reasons:  Tags provide the “selectors” that makes it possible for the Neatline styling system to apply bulk updates to large collections of records. For example, you could do something like: . virginia {   fill-color: #08c; } This automatically updates the “Fill Color” of all records in the exhibit tagged with virginia, even if there are hundreds of thousands of them. For more information about this, head over to the “Styling Exhibits with Neatline CSS” guide.  You can filter the list of records in the content management pane in the editor with a query syntax. For example, you could search for:tags: precinct, democrat And just show the records that are tagged with both precinct and democrat.  If you’re developing a custom theme or sub-plugin for an exhibit, you can use tags to toggle on and off different portions of the exhibit. For example, imagine you’re mapping presidential election results, and you want to add a little widget that makes it possible for the user to check on or off different batches of data from 2000, 2004, etc. If all the data points are tagged to one of the election cycles, you could just run simple API queries like: Neatline. execute('MAP:load', { tags: ['2004', 'democrat'] }); Tag requirements: In order for the tags to work correctly, there are a couple important requirements:    Tags can contain letters, numbers, and underscores (_), but no spaces or hyphens (-). Technically, it’s actually possible to use spaces and hyphens in tags, but it’s strongly discouraged, because it effectively results in multiple taggings. For example, if you had a tag called democrat-2012, Neatline would consider the record to be tagged with democrat, 2012, and democrat-2012. So, if you were to start using a more generalized tag called just democrat, queries for democrat would match the record, even though it’s tagged with the more specific democrat-2013. This is confusing, but, unfortunately, the issue lies at the level of the fulltext searching system in the underlying MySQL database that we use to implement the feature. We’re working on a fix for this - for now, if you need “spaces” in the tags, just use underscores (eg, democrat_2012).     Tags must be at least 4 characters in length. Again, this is actually a requirement that’s built in to the fulltext searching system in MySQL. Really, though, this is a healthy constraint - tag names should be semantic and descriptive, so most tags should be longer than three letters anyway.     Tags must be separated by commas, or else Neatline won’t know where one tag stops and another starts.  Presenter: Each record is assigned to a “presenter,” which determines the mechanism by which the record’s content is displayed (the “Title” and “Body” fields). Out of the box, Neatline comes with two simple presenters - the “Static Bubble,” which displays the pop-up bubbles that appear when the cursor hovers or clicks on a record, and the “None” presenter, which, as you might guess, does nothing (this is useful for purely-visual annotations that don’t need any kind of text content - arrows, brackets, etc). The Neatline plugin API makes it easy for developers to implement completely new presenters, which would then be available for selection in this field. For example, it would be easy to write a presenter that would add a “floating” bubble that would track the location of the cursor on the page, or a presenter that would open up a full-screen modal view. See the developer documentation for more information about creating new presenters. "
        }, {
        "id": 39,
        "url": "https://neatline.org//docs/style-tab-imagery/",
        "title": "Style Tab Imagery",
        "body": "Editing Record ImageryAt a glance:  These fields make it possible to layer images on top of the map base layer - thumbnails, historical maps, etc.  The “Point Image” field replaces the default circular graphic for points with any web-accessible image.  The “WMS Address/Layers” fields make it possible to overlay a WMS layer hosted by software like Geoserver. Point Image: By default, points on the map are represented with circle graphics, the size of which can be configured by the “Point Radius” field in the “Dimensions” field set. This field makes it possible to replace this default representation of the points with any random, web-accessible image. This makes it possible to place effectively any kind of graphic on the map - pins, icons, image thumbnails, etc. Once a “Point Image” is provided, the points continue to behave just like regular points in all other ways. For example, you can change the size of the point-images by changing the “Point Radius” field, and you can configure the opacities by changing the “Fill Opacity” and “Fill Opacity (Selected)” fields. Point images can be the web-accessible location of any image. For example, to use the Neatline logo: /assets/wp-content/themes/neatline-wp-theme/images/neatline-logo-rgb. png Important: Since we’re really just changing the cosmetic appearance of the points, there are some restrictions:    Like regular points, point-images will always stay the same size (the value of “Point Radius”), no matter what the zoom level of the map. If you need an image to scale depending on the zoom level, you’ll need to use a WMS overlay hosted by Geoserver (see below).     Point-images can’t be “rotated” - they will always have the exact orientation of the source image. Again, if you find yourself wanting to pivot the image to make it line up with something on the underlying base layer, you’re probably looking for the type of functionality provided by a WMS overlay.  Tip: When preparing images for use as point-images, try to use image types like *. png that support transparency. Otherwise, you’ll have unsightly white or black boxes filling in the negative space surrounding the graphics. WMS Address: The location of a web-accessible Web Map Service server like Geoserver. This field has to link directly to the WMS API endpoint on the server, such as: http://libsvr35. lib. virginia. edu/geoserver/hotchkiss/wms See also: Tutorial: Neatline for Historical Maps by Kristen Mapes. WMS Layers: A comma-delimited list of layers on the served defined by “WMS Layers,” such as: hotchkiss:fredericksburg,hotchkiss:chancellorsville Once a WMS address and layer name has been entered, Neatline will automatically overlay the requested layers on top of the base layer. WMS layers react to many of the same styling, visibility, ordering settings that can be used to configure the behavior of regular vector annotations:    Use the “Fill Opacity” field to control the opacity of the WMS overlay.     If an “After Date” or “Before Date” is defined for the record, the WMS layers will appear and disappear as the timeline is dragged in and out of the visibility interval defined by the date fields. For example, if the “After Date” is set to 2000, the WMS layer will be invisible when the timeline is focused at 1999.     If a “Min Zoom” or “Max Zoom” is defined for the record, the WMS layer will appear and disappear as the map is zoomed in and out of the visibility interval defined by the zoom fields. For example, if “Min Zoom” is set to 10, the WMS layer will be invisible when the map is at zoom level 9.  "
        }, {
        "id": 40,
        "url": "https://neatline.org//docs/style-tab-opacities/",
        "title": "Style Tab Opacities",
        "body": "Editing Record OpacitiesAt a glance:  Opacities are stored as 3-digit decimal values between 0. 00 (completely translucent) and 1. 00 (completely opaque).  To change an opacity value, you can type directly into the field.  Or you can click on the field and drag up or down on the page, causing the value to change smoothly.  As an opacity is changed, the new value will be automatically previewed on the map. Examples::  0. 00 1. 00 0. 56Fill Opacity: The opacity of the “body” or “area” of points and polygons on the map (the area inside the lines, not including the lines themselves).  Fill Opacity (Selected): The opacity of the “body” or “area” of points and polygons on the map when the record is highlighted or selected (eg, when the cursor hovers or clicks on the shape).  Stroke Opacity: The opacity of the lines that run around the edges of a shape on the map.  Stroke Opacity (Selected): The opacity of the lines that run around the edges of a shape on the map when the record is highlighted or selected (eg, when the cursor hovers or clicks on the shape).  "
        }, {
        "id": 41,
        "url": "https://neatline.org//docs/style-tab-visibility/",
        "title": "Style Tab Visibility",
        "body": "Editing Record Visibility SettingsAt a glance:  Use “Min Zoom” and “Max Zoom” to hide or display the record depending on the zoom level of the map.  Use the “Use Current” buttons to insert the current zoom level as the value for “Min/Max Zoom. ” Use “Default Focus/Zoom” to set the location and zoom level that the map “snaps” to when the record is selected.  Use the “Use Current Viewport as Default” to use the current focus/zoom as the record default. Min Zoom: The zoom level “above” which the record will be visible, with zooming “in” being “higher” (eg, focusing on Spain is “higher” than focusing on Europe). For example, if the record has a point on the map and “Min Zoom” is 10, then the point will be invisible when the map at zoom level 9, and will become visible as soon as the map zooms to 10. To set the value, just zoom the map to the level that you want to use for the value, and click the “Use Current” button next to the field title to automatically insert the current zoom offset into the input. Max Zoom: The zoom level “below” which the record will be visible, with zooming “out” being “lower” (eg, focusing on Europe is “lower” than focusing on Spain). For example, if the record has a point on the map and “Max Zoom” is 10, then the point will be invisible when the map at zoom level 11, and will become visible as soon as the map zooms to 10. Like with “Min Zoom,” click the “Use Current” button next to the field title to automatically insert the current zoom level into the input. Default Focus and Default Zoom: These two fields define the focus location and zoom level that the map “snaps” to when the record is selected. For example, if the record is represented by a vector annotation on the map, and the user clicks on the title of the record in the Waypoints panel, the map will move to the location and zoom level defined by these fields. Think of these fields as a related pair that work together to set the record’s “framing” or “home base” in the exhibit. To set a default focus and zoom, just move the map to the exact location and zoom level that you want to use, and click the “Use Current Viewport as Default” to insert the current values into the inputs. Or, you can also set the values of the fields individually by clicking the “Use Current” links next to the field labels. If a zoom is set but the focus is left empty, Neatline will apply the custom zoom level when the record is selected, and auto-center the map to frame the record’s geometry on the map. Or, vice versa, if a focus is set but the zoom is empty, Neatline will apply the custom focus and auto-zoom the map to the “closest” level at which all of the record’s geometry is visible in the viewport. If no values are provided for these fields, Neatline will use automatically-computed values for both fields. This can often work well without any modification, but there are a couple of cases when you might want to explicitly set a custom focus:    If the record is represented with a single point, Neatline will always zoom in to the highest possible zoom level, since points are effectively dimensionless, infinitely-small dots. This is often undesirable. To fix, just zoom the map back to a reasonable level and click “Use Current Viewport as Default. ”     Even when the record is represented by lines or polygons that result in a fairly reasonable automatic focus, there are times when you want to tweak the default viewport, perhaps to situate the record in the context of some other nearby feature on the map. For example, imagine that the record represents the location of a battle that was affected by the presence of a hill to the north of the battle site. You might want the default focus of the record to be zoomed back a bit and moved up to the north so that the hill appears in the default viewport of the record for the battle.  "
        }, {
        "id": 42,
        "url": "https://neatline.org//docs/text-tab/",
        "title": "Text Tab",
        "body": "Adding Text ContentAt a glance:  Text content for records is entered in the “Title” and “Body” fields in the “Text” tab.  The title should be short, and generally shouldn’t contain complex HTML or formatting.  The body can be anything from a short blurb up to a long-format narrative essay.  Any kind of HTML-embeddable media can be put in the body - audio, video, etc.  Use the “Edit HTML” links to open a fullscreen WYSWYG editor for either of the fields.  All text fields are optional, but it’s recommended to at least enter a title. Slug (optional): The slug is a plain-text identifier for the record - think of it as a human-readable ID that can be used to reference the record from without. Specifically, the NeatlineText plugin - which makes it possible to connect text documents to Neatline exhibits - makes it possible to connect individual paragraphs, sentences, or words in a text with individual Neatline records. For example, in the exhibit “Narrative” field, you might have something like this: . . . &lt;span data-neatline-slug= paris &gt;Paris&lt;/span&gt; . . . If you had a record in your Neatline exhibit with a slug of paris, the word “Paris” document would be interactively linked with the location on the map. The slug isn’t actually displayed anywhere in the public-facing version of the exhibit - if you’re not using the Narratives plugin, it fine to just leave it blank. Title (optional, recommended): The title is the top-level snippet of text used to label the record in pop-up bubbles, on timelines, and in vertical listings of waypoints. Try to keep it short and simple, and avoid using complex formatting. A title isn’t strictly required, but if you leave it blank you’ll likely end up with some odd visual artifacts in your exhibit (empty preview bubbles, unlabelled points and spans on the timeline, etc). If you want to add special formatting to the title (eg, make it bold, increase the size), click the “Edit HTML” link next to the field label. This will open a full-screen WYSWYG editor with a full load-out of formatting options. When you’re done with the editor, click the Minimize button to return to the regular editing interface.  Body (optional): The body is a catch-all field designed to house the main textual content for the record. Depending on what kind of content you’re working with and how you’re structuring the user-interface for the exhibit, it might make sense to enter anything from a short little blurb all the way up to a 10,000-word scholarly essay.  Like with the title, click on the “Edit HTML” link to open up a full-screen WYSWYG editor for the field. Although it’s generally a good idea to keep the formatting pretty minimal for the title, it fine to use much more elaborate and structural styling in the body - bullets and numbered lists, images, tables, etc.  Also, you can use the body as a space to include any kind of embeddable third-party multimedia content - videos from YouTube or Vimeo, audio from SoundCloud, etc. Just click on the “Source” button at the top left of the editor to activate view-HTML mode, and paste in the embed code. To close the full-screen editor, click the Minimize/Maximize button. "
        }, {
        "id": 43,
        "url": "https://neatline.org//docs/troubleshooting/",
        "title": "Troubleshooting",
        "body": "TroubleshootingMigrating to new versions of MySQL: Spatial data in MySQL can sometimes be quite fragile and it can also be difficult to determine what data is invalid or why it is invalid. Different versions of MySQL also implement more or less stringent checks for such values. Migrating MySQL versions will sometimes result in errors such as: Cannot get geometry object from data you send to the GEOMETRY field. One common case where these errors occur is upgrading from a pre-5. 7 version of MySQL using null or empty geometry values in the coverage column in the omeka_neatline_records table, which does not allow null or empty values. Replacing these values with valid data (even placeholder, unmeaningful data such as “Point(0 0)”) will get around this error. Check whether this applies to your data by selecting for null astext(coverage) values: use {database name};select astext(coverage) from omeka_neatline_records where astext(coverage) is null;If these values exist, replace them with Point(0 0) using: update omeka_neatline_records set coverage=GeomFromText('POINT(0 0)') where astext(coverage) is null;"
        }, {
        "id": 44,
        "url": "https://neatline.org//docs/upgrading-to-v2/",
        "title": "Upgrading to Neatline 2.0",
        "body": "Upgrading to Neatline 2. 0At a glance:  Neatline 2. 0 is a major evolution of the project that improves many of the core workflows and adds lots of new features.  Almost all exhibits created with Neatline 1. x will behave exactly the same when migrated to Neatline 2. 0.  In cases where features have been changed, Neatline 2. 0 provides alternative methods to achieve the same functionalities. What’s new: Neatline 2. 0, which was released on July 2, 2013, is a major update to the project that includes a large number of improvements to the existing feature-set and adds a number of new features designed to make it easier to create larger and more complex exhibits. Some of the highlights in the new version:    A high-performance, real-time spatial querying system (the map loads just the subset of information that it needs to fill in the viewport at any given moment) that makes it possible to work with really large collections of records – as many as about 1,000,000 in a single exhibit;     The ability to import SVG vector graphics created in programs like Adobe Illustrator or Inkscape and interactively “drag” them into position as first-class geometry in a Neatline exhibit;     A Neatline-flavored dialect of CSS, integrated into the editing environment, that makes it possible to quickly perform bulk updates on large collections of tagged records;     The ability to add custom base layers, which could be regular geospatial tile sets like the included OpenStreetMap or Google layers, or completely non-spatial entities like paintings, drawings, photographs, documents, diagrams, or anything else that can be captured as an image;     A total rewrite of the front-end JavaScript application (both the editing environment and the public-facing exhibit views) that provides a more minimalistic and responsive environment for creating and viewing exhibits;     A flexible user-permissions system, designed for large-scale classroom use, that makes it possible to cordon off individual student/contributor accounts and grant them access only to their own content;     An exhibit-specific theming system, which makes it possible for designers and developers to completely customize the appearance, layout, and interactivity of Neatline projects on a per-exhibit basis;     A new programming API and “sub-plugin” system that makes it possible for developers to add custom functionality – everything from simple user-interface widgets (sliders, legends, scrollers, forward-and-backward buttons, etc. ) up to really extensive modifications that expand the core data model and add totally new interactions.  What’s different: Some of these changes entailed some pretty significant changes to the core codebase. All of the core features from the 1. x releases are preserved in 2. 0, and most exhibits will behave exactly the same after upgrading to 2. 0. In a handful of places, though, we made changes that will slightly alter the visual appearance of certain types of exhibits. We also made some changes to how Neatline is distributed and installed that we think will make the project more maintainable and reliable. Here are the important changes:    In the new version, the “Timeline” and “Items” panels (which could be toggled on and off with the “Layout Options” drop-down menu in the editor) have been broken out into separate plugins - NeatlineSimile and NeatlineWaypoints - that extend the Neatline plugin, which houses the core content management system. These two “sub-plugins” integrate seamlessly with Neatline - after upgrading from 1. x to 2. 0, just install the two widget plugins, and the timeline and item-browser panels will be automatically restored to their original states in all of your exhibits.     The “Layout Editor” feature from the first version - which made it possible to interactively toggle and position the three viewports - has been removed in favor of a more flexible theming system that gives designers complete control over the layout of each individual exhibit. The old approach was visually appealing and pleasant to work with, but it depended on a brittle, JavaScript-powered approach to positioning the viewports that made it extremely difficult for theme designers to customize the exhibits. In the new version, we provide sensible defaults for all exhibits, and provide an extremely simple theming system that makes it easy to customize the layout and sizing of the viewports with a few lines of CSS.  Upgrading: Upgrade Neatline to 2. 0: Upgrading to Neatline 2. 0 is just the same as upgrading any other Omeka plugin:    Always start by backing up your database in the unlikely event that something goes wrong during the upgrade. As an extra precaution, since the migration to 2. 0 makes some pretty significant changes to the underlying data, Neatline actually spawns off archived copies of the original Neatline tables, in case you want to revert back to a previous version.     Delete the old /Neatline directory under /plugins in your Omeka installation.     Download the most recent version of Neatline, unpack the . zip archive, and move it into /plugins.     In the Omeka administrative interface, click on the Plugins link on the top navigation bar and find the listing for Neatline. With the code for the new version in place, you should see a notification saying “You have a new version of Neatline. Please Upgrade!”.     Click the Upgrade button.     Important: After starting the upgrade, you’ll immediately see a success message saying that “The Neatline plugin was successfully upgraded!”. At this point, Neatline 2. 0 is fully installed and ready for use, but it may take up to 20-30 seconds before the old exhibits are visible under the “Neatline” tab.  Behind the scenes, Neatline actually spins up a “background process” - a special, long-running program that does the work of actually converting all of the old content to the new, 2. 0 format - that can take a bit longer than the average web request. Depending on the how many exhibits and records you had in the old installation, this could take anywhere from just a couple seconds up to around a minute. Install NeatlineWaypoints and NeatlineSimile (optional): Once the core Neatline plugin is upgraded to 2. 0, you’ll have access to everything except the timeline and item-browser viewports, which are now broken away into two new “sub-plugins” called NeatlineSimile and NeatlineWaypoints that are installed alongside Neatline and extend the core feature set. Install them just like any other Omeka plugin:    Download the most recent verisons of NeatlineWaypoints and NeatlineSimile, unpack the . zip archives, and move the NeatlineWaypoints and NeatlineSimile folders into /plugins.     Go to the Plugins pane in the Omeka administrative interface and find the listings for the two new plugins. Click the Install button for each.     Once the sub-plugins are installed, the old “activation” settings for each of the old exhibits (eg, which exhibits have the timeline enabled, which have the item browser, which don’t, etc. ) will automatically be re-applied.  "
        }, {
        "id": 45,
        "url": "https://neatline.org//docs/user-permissions/",
        "title": "User Permissions",
        "body": "Managing User PermissionsAt a glance:  Neatline has a simple user permissions system integrated into Omeka, designed to make it easy to use Neatline with groups of all sizes.  Researcher users can view public Neatline exhibits, but don’t have access to any of the administrative features.  Contributor users can create and modify their own Neatline exhibits, but can’t make changes to other users’ exhibits.  Admin and Super users can do everything: create, modify, and delete Neatline exhibits created by all users.  When groups of users need to work together as a team on a single exhibit, or a set of exhibits, assign one Contributor account to be used by the whole group. User Levels and Access: Neatline uses the built-in ACL (Access Control List) system in Omeka, which defines a series of user “roles” for site administrators, each with a different level of access. You can find the list of users and add new ones by clicking the “Users” tab on the top navigation bar when logged into your Omeka site (see the Omeka documentation for more information about how to create and manage user roles). Defining user permissions allows you to control access to Neatline exhibits when working with multiple users, and can help in avoiding issues like one user modifying or deleting a Neatline exhibit created by another user. If you are working with a small group of trusted collaborators, you may want to allow everyone to have access to all work on the site, no matter the creator. However, if you’re using Neatline with large numbers of people - for example, if you’re teaching a 200-person lecture course, and want to use Neatline for an assignment - setting user permissions is critical to prevent users from accidentally changing settings or deleting content. Read through the following user roles and their Neatline access to determine what works best for your project:    Researcher users are completely locked out of Neatline - they can’t create, edit, or delete exhibits. Effectively, researchers have the same level of access as an anonymous, public user - they can view published exhibits, but nothing else. This conforms with Omeka’s definition of the Researcher role, which was originally added so that site administrators could make it possible for certain users to view non-public items, without being able to modify content on the site.     Contributor users can create, edit, and delete their own Neatline exhibits, but can’t make changes to anyone else’s exhibits. This is the role that’s best suited for students, workshop participants, and other users who need to be able to work with their own Neatline content, but who don’t need to make high-level changes to the site (eg, changing themes, installing plugins).     Admin and Super users can do everything - they can create, modify, and delete Neatline exhibits created by all users. Super and Admin users have different levels of access in Omeka, see the Omeka documentation for more details.  Working with User “Groups : User roles can only be assigned to individual users - Omeka has no notion of a “group” of users. This is problematic if you want to allow teams of users to work collaboratively on the same exhibit. It doesn’t work to create separate Contributor accounts for each of the users, which would allow each individual user to create her own exhibits, but not for the entire group to make edits to the same exhibit. You could always just make all of the users Admin users, but that may not be ideal for your needs - everyone would be able to edit everyone else’s content, not just the exhibits that are “owned” by the group. For now, the easiest way to allow groups of users to work together on a single exhibit, or a set of exhibits, is to create a single Contributor account for each group. So, if you have 10 groups, each comprised of 4 students, create 10 different Contributor accounts and give the same set of login credentials to all 4 students in each of the 10 groups. This way, users can edit exhibits and records created by anyone else in their own group, but not exhibits created by anyone in a different group. Related: Omeka Documentation, Managing Exhibits "
        }, {
        "id": 46,
        "url": "https://neatline.org//docs/what-is-neatline/",
        "title": "What is Neatline?",
        "body": "What is Neatline?Neatline is an annotation framework that allows users to create rich, interactive editions of visual objects, and is built with humanities scholarship in mind. The project began with a focus on maps, but Neatline provides the flexibility to annotate anything with some sort of visual instantiation. Neatline’s set of vector-drawing and content management tools can be used to create interpretive views of maps, paintings, drawings, photographs, documents, diagrams, and anything else that can be captured as an image. What makes it different?: How does Neatline fit into the existing ecosystem of geospatial and annotation tools? Neatline sits in the space between consumer-grade mapping applications like the Google custom map-maker and heavyweight, analytical GIS tools like ArcGIS. It’s designed to be simple enough that college undergraduates can easily use it for class assignments, but also sufficiently flexible, scalable, and feature-rich that it can be used for professional scholarship, journalism, and art. Neatline keeps things simple and provides sensible defaults, but it’s careful never to make intellectual or aesthetic decisions on your behalf. Neatline Project Examples: Neatline works best when you’re using it to tell a story or create an interpretive lens to better understand a collection of artifacts, documents, or richly-described concepts. Do you have a collection to build on, or do you want to create a searchable Omeka collection while you’re mapping and annotating? Is the aesthetic dimension of your visualization important? Do you want to show that contested, conflicting readings of the same dataset are possible? Neatline is for you. Here are some examples of the kinds of projects that could be built (or have been built!) with Neatline:    Wordsworth in the Alps: In Book Sixth of The Prelude, “Cambridge and the Alps,” Wordsworth describes his 1790 grand tour of Europe, culminating in the famous description of the crossing of Simplon Pass in the Alps. You want to create an interactive edition of the poem that traces Wordsworth’s journey from Cambridge across the channel to Calais, south through France, into the Alps, and along the Stockalper trail over the pass. How does Wordsworth’s description of the sequence of towns and landmarks map onto the actual geography of the area?     The Declaration of Independence: The signatures at the bottom of the Declaration of Independence are iconic - we can all recognize John Hancock and Thomas Jefferson, but what about the rest? You want to create an interactive edition of the document that traces out visual annotations around each of the signatures that connects it to a short biography - who they were, where they came from, and how they ended up signing the declaration. With the signatories in place, you then provide a transcription of the declaration itself, and link the individual sentences or words in the text to the corresponding locations on the high-resolution scan of the original document.     Minard’s Napoleon Infographic: Charles Minard’s 1869 diagram showing the gradual depletion of the French army over the course of Napoleon’s 1812 invasion of Russia is a seminal work in the history of information design. You want to take high-resolution scan of Minard’s original graphic, overlay it on top of modern satellite geography, and layer on an interactive reimagination of the original material - trace out the components of Minard’s flowchart, add background information about each of the cities and rivers marked along the route, and link individual objects on the map to paragraphs and sentences in a narrative that describes the history of the invasion.     Whitman’s “Salut au Monde”: “Salut au Monde” is an index of Whitman’s geographic imagination, an expansive catalog of cities, countries, regions, landmarks, oceans, rivers, and cultures. You want to create a rich interactive edition of the poem by layering the actual text on top of modern satellite imagery and connecting each of the of geospatial references to hand-selected (and at times highly interpretive) focus locations on the map - the “Amazon” to the expansive, dark green rainforests in Brazil, the “northern blasts” to the glaciers in the Brooks Range, etc.     Hotchkiss at Chancellorsville: Jedediah Hotchkiss, a military cartographer for the Confederacy during the Civil War, spent the rest of his life revisiting maps he made during the war, sketching in marginalia and marking off troop locations. In one instance, he printed a series of three identical engravings of the area around Chancellorsville and Fredericksburg and sketched in the positions of the Union and Confederate armies on each of the three days of the Battle of Chancellorsville with colored pencils. You want to create an exhibit that positions the three maps on top of modern satellite imagery of the battle field and layers on a second layer of visual annotation about the maps - the movement of the armies in the weeks leading up to the battle, Lee’s risky decision to split his army and leave half of his force behind at Fredericksburg, and why Jackson decided to perform a risky flanking maneuver on the morning of the first day.     The Chelyabinsk Meteor: On February 15, 2013, a 10,000-ton meteor streaked over the city of Chelyabinsk in the Ural Mountains, producing a massive airburst that shattered windows and collapsed buildings. The explosion occurred during the morning rush hour, and the event was captured by dozens of commuters with dashboard-mounted video cameras. You want to create an exhibit that traces out the trajectory of the meteor as it enters the atmosphere and traverses the airspace over the city, and plot out the exact position and orientation of each of the recordings relative to the location of the airburst.  Find more Neatline projects on our Showcase page. "
        }, {
        "id": 47,
        "url": "https://neatline.org//docs/working-with-the-simile-timeline-widget/",
        "title": "Working With The Simile Timeline Widget",
        "body": "Working with the SIMILE Timeline PluginDefinition: The SIMILE Timeline web plugin allows users of Neatline to add interactive timeline components to their Neatline exhibits. The plugin is open source software originally developed as part of the SIMILE project with funding from the Andrew W. Mellon Foundation. Download the latest version of the plugin. Enabling SIMILE Timeline for an Exhibit: The SIMILE Timeline plugin is enabled from the main Exhibit Settings screen, either when first setting up the exhibit or by editing the settings later.  To enable the Timeline plugin, click once in the widgets box, then click on SIMILE Timeline in the drop down list to turn the plugin on for the exhibit. Plugin Settings: The settings that control the timeline’s appearance are found in the Plugins tab on the Neatline editor screen, accessed by clicking the title of the Neatline exhibit from the Browse Exhibits list. Click on Plugins, then click SIMILE Timeline to open the Timeline Settings editor.  Default Date: The default date setting centers the timeline on the date entered. The default value for this setting is the current date/time, as defined by the server on which the Omeka + Neatline software is running. SIMILE Neatline requires the ISO-8601 date format for all dates entered. The format is YYYY-MM-DDTHH:MM:SS, where T is the delimiter alerting the software that a Time value follows. Please see the Date Formatting section of this document for examples. Interval Unit: Interval Unit defines the unit of measurement for the timeline. Users select the most relevant time increment from the drop down list. Available interval values include Millennium, Century, Decade, Year, Month, Week, Day, Hour, Minute, or Second. The default value for this setting is Year. Interval Pixels: The interval pixels setting defines how long each interval on the timeline will be, in pixels. The default setting is 100 pixels. The maximum setting is 500 pixels. The minimum setting depends on the time interval selected for the Interval Unit. Users will wish to select an interval at which the timeline’s interval units are legible to an exhibit viewer, given the number of events that will be appearing on the timeline. As an example, if the Interval Unit selected is Seconds, the Interval Pixels value might be set as low as 30 pixels; if the Interval Unit is Year, the Interval Pixels value would need to be set at 40 pixels or higher. Track Height: The Track Height value defines the height in pixels used by the timeline event tape, plus the label on the timeline event. Users will wish to select a value that allows all tapes and their labels to be legible for viewers. The default Track Height value is 30 pixels. The max value is 500 pixels. The min value is 0 pixels. Please note that the actual viable range for Track Height is between 20 pixels and about 50 pixels, depending on the value selected for Tape Height and the number of events on the timeline. The Track Height will not display a value too low in order to display both the event tape and the label. Tape Height: Tape Height is the value, in pixels, that defines the height of the tape representing a timeline event. The default value for Tape Height is 10 pixels. The max value is 500 pixels. The min value is 0 pixels. Please note that the actual viable range for Tape Height is between 3 pixels and about 40 pixels, depending on the value selected for Track Height and the number of items on the timeline.  Adding an Item Record to the Timeline: To include a Neatline item on the timeline, on the Style tab in the Neatline Item editor, select SIMILE Timeline in the plugin drop down box and populate the Date fields on the Style tab. The Title of the Neatline item record will appear as the label on the event point or tape, and the color value will match that selected for the point or shape drawn to represent the event on the map.  Dates: Start and End Dates: The dates that mark the beginning and end of an event, a person’s life, the existence of a building or structure. To render an event as a single point on the timeline, fill in only the Start Date. If both Start and End Dates for an event are populated, SIMILE Timeline will create an event tape on the timeline. NOTE: if the Start and End Dates are the same value, the span will have width of 0 pixels and will not be visible.  After and Before Dates: After and Before dates determine the duration of the event’s visibility in the exhibit and on the waypoints side bar, based on the position of the timeline. For example, a record with an After Date of 1589-09-23 and a Before Date of 1613-04-26 would only be visible to a viewer when the center-line of the time is positioned between September 23, 1589 and April 26, 1613. At any other position on the timeline, the event’s geometry is invisible.  Date Formatting: SIMILE Timeline requires the use of the ISO-8601 format for the date fields. Dates can be entered in a range from just the year, down to minutes and seconds. The basic format for dates is YYYY-MM-DDTHH:MM:SS, where T is the delimiter alerting the software that a Time value follows. Here are some examples CE Dates    1564 (the year 1564)     1564-04 (April, 1564)     1564-04-23 (April 23, 1564)     1564-04-23T08:30 (8:30AM on April 23, 1564)     1564-04-23T0808:30:15 (15 seconds after 8:30AM on April 23, 1564)  BCE Dates: SIMILE Timeline can also render BCE dates, but the format is slightly different. Please note that the software CANNOT calculate that there is no Year 0, so BCE dates must be adjusted to account for this.    -001563 (the year 1564 BCE)     -000563 (the year 564 BCE)     -000063 (the year 64 BCE)     -000003 (the year 4 BCE)     -001563-04 (April, 1564 BCE)     -001563-04-23 (April 23, 1564 BCE)  Hours, minutes, and seconds may also be rendered for BCE dates in the same manner as the CE date examples above, should this be relevant to an event’s information. Removing a Neatline Item from the Timeline: To remove an item from the timeline, click the X on the Simile Timeline plugin selection on the Item Record’s Style tab and save the item record.  Disabling SIMILE Timeline for an Exhibit: From the Neatline Browse Exhibits Screen, select Exhibit Settings, scroll down to widgets, then click the X on the SIMILE Timeline plugin selection. Once SIMILE Timeline has been deselected, scroll to the bottom of the screen and click the Save Exhibit button to save the settings.  "
        }, {
        "id": 48,
        "url": "https://neatline.org//docs/working-with-the-text-widget/",
        "title": "Working With The Text Widget",
        "body": "NeatlineTextDefinition: NeatlineText is an extension to the Neatline plugin that makes it possible to connect paragraphs, sentences, and words in text documents with annotations in Neatline exhibits. Download the latest version of the plugin. For example, imagine you’re making an interactive edition of Walt Whitman’s “Salut au Monde,” and want to wire up the locations in this passage with annotations on the map: I see the tracks of the rail-roads of the earth;I see them welding State to State, city to city, through North America;I see them in Great Britain, I see them in Europe;I see them in Asia and in Africa. Installation:    Download the latest version of the plugin from the Omeka add-ons repository.     Uncompress the . zip archive.     Move the NeatlineText folder into the /plugins folder in your Omeka installation.     In the Omeka administrative interface, click on Plugins in the top navigation bar and find the listing for “Neatline Widget ~ Text”. Click on “Install. ”  Note: Since NeatlineText is a “sub-plugin” that extends the core functionality of Neatline (itself a plugin), Neatline needs to be installed in order to install NeatlineText. Usage: Step 1: Create the Neatline records: First, create records in the Neatline exhibit for each of the geographic entities that you want to represent on the map - North America, Great Britain, etc. - and fill in the “Slug” field in the “Text” tab with a semantic, easy-to-remember string: Think of the slug as a plain-text, human-readable identifier that can be used to reference the record in other contexts, for instance, in HTML markup. Step 2: Create the Narrative: You have two options in creating the text to which you’re attaching Neatline records. You can easily edit shorter texts within the built in editor of the “Exhibit Settings” page. While you can edit longer texts within that same editor, you may find it more comfortable to work within a familiar text editor, such as Notepad++, TextMate, or Sublime Text. Editing a Shorter Text within the Built-in Editor:  In the “Exhibit Settings,” click the Full Screen button () to open a larger text editing window or enter the text into the “Narrative” field text window. You could type the text directly in the window or copy from a file.  Click “Source” in order to view and edit the HTML markup.    In the “Source” view, enclose sections of the text to which you wish to link map annotations with HTML elements containing a data-neatline-slug attribute, setting the value of the data-neatline-slug attribute equal to the slug of the record with which the text is associated. For example, to link the words ‘North America’ to the record to which I assigned the slug ‘north-america,’ type &lt;span data-neatline-slug= north-america &gt; before the words you want to link and &lt;/span&gt; after those words:   I see them welding State to State, city to city, through &lt;span data-neatline-slug= north-america &gt;North America&lt;/span&gt;;    After you’ve linked the all sections of the text you wish to, click the Full Screen Button again to close the full screen editor, if it is open Click the green Save Exhibit button at the bottom of the page. Note: We typically use&lt;span&gt; elements because they do not create any visual changes in the document in themselves. However, you could use others elements, such as &lt;div&gt;. Neatline looks for the attribute data-neatline-slug rather than the element. If you are in doubt of which element to use, use &lt;span&gt;. Editing Longer Texts with a Text Editor: Alternatively, especially for longer texts, it may be easier to add the elements with the data-neatline-slug attribute within a text editor such as Sublime Text or Notepad++.  Open your text editor of choice.  Copy in or compose the text document.    Editing the HTML, wrap sections of the text with elements with data-neatline-slug attributes as in the example above, setting the value equal to the slug of the record with which the text is associated. For example, to link the words ‘North America’ to the record to which I assigned the slug ‘north-america,’ I would type &lt;span data-neatline-slug= north-america &gt; before the words I want to link and &lt;/span&gt; after those words:     Open up the “Exhibit Settings,” scroll down to the “Narrative” text box, and click the “Source” button in the editor. You must click “Source” so that the editor will understand the HTML markup you’ve written.  Copy and paste the HTML from your text editor into the “Narrative” text box.  Click the green Save Exhibit button at the bottom of the page. Now, when you open up the public and fullscreen views of the exhibit, NeatlineText will automatically create bi-directional connections between the spans in the text document and the corresponding records in Neatline. Out of the box, the plugin implements two basic interactions:    Highlighting: When the user hovers the cursor over a span in the text, any corresponding objects in the Neatline exhibit (shapes on the map, waypoints, etc. ) will be highlighted. And vice versa - when the cursor hovers on an object in the exhibit, the span(s) in the text will highlight.     Selecting: When the user clicks on a highlighted span in the text, the Neatline exhibit will “focus” around the corresponding record in the exhibit - the map will pan and zoom to frame the annotation, the timeline will scroll to show the span, etc. And likewise, when the user selects a record in the Neatline exhibit, the text will automatically scroll to display the corresponding span.  Theming: Unlike other Neatline extensions like Waypoints and SIMILE, NeatlineText needs to be used in conjunction with a theme that positions the text next to the exhibit inside of a scrollable container element. By default, most themes just display the exhibit narrative above or below the exhibit, which means that the user would need to manually scroll up and down on the page to compare the exhibit with the text, which defeats the purpose. There are two ways to go about this:    Omeka themes: To make it easy to get up and running, we’ve built a really simple starter theme called Neatlight, which is specifically designed to house NeatlineText exhibits. Think of Neatlight as the Neatline equivalent of the default “Thanks Roy” theme that ships with Omeka - it’s a simple, no-frills foundation that can be easily adapted and expanded.     Neatline themes: The other approach is to use Neatline’s exhibit-specific themeing system, which makes it possible to create completely separate themes for each individual Neatline exhibit. For more information about this, check out the documentation, and take a look at David McClure’s fork of the Neatlight theme, which contains the source code for the custom themes used in projects at neatline. dclure. org.  "
        }, {
        "id": 49,
        "url": "https://neatline.org//docs/working-with-the-waypoints-plugin/",
        "title": "Working With The Waypoints Plugin",
        "body": "Working with the Waypoints PluginDefinition: The Neatline Waypoints widget allows the creation of contextual reference points for exhibit content, providing creators with a means of shaping users’ interaction with the exhibit’s contents. Download the latest version of the plugin. Enabling Waypoints for an Exhibit: To enable the waypoints widget, on the exhibit settings screen, select the widget from the drop down selection box. Adding a Waypoint For a Record: To include a Neatline record on the waypoints sidebar  Create the Neatline record.    On the Style tab of the record, click the Widgets field and select Waypoints from the drop down box.      Save the record. Removing a Waypoint For a Record: To remove a Neatline record from the waypoints sidebar  Open the Neatline record editor.    On the Style tab, deselect Waypoints from the drop down box by clicking on the small X on the plugin label.      Save the record. Waypoint Settings: To access settings for the Waypoint widget, from the main Neatline editor screen, click on the Plugins tab, then select Waypoints from the list. After opening the Waypoints setting tab, you can click and drag your waypoints into the desired order then save your changes by clicking the blue Save button. The new order of your waypoints will show on the waypoints sidebar once you’ve saved your changes.  Disabling Waypoints for an Exhibit: To disable Waypoints on an exhibit  Open the Exhibit Settings dialogue.  Scroll down to the Widgets section.  Click the small X on the widget label.  Scroll down and click the green Save Exhibit button. "
        }, {
        "id": 50,
        "url": "https://neatline.org//docs-s/tag-v-0-1-0/",
        "title": "Neatline for Omeka S",
        "body": "Neatline for Omeka S: Development Release v0. 1. 0We’re happy to share a development release of Neatline for Omeka S. The version for this release is 0. 1. 0, so it’s not yet ready for production use. We’ll continue to work on the plugin, and do incremental 0. x releases until we’re ready to offer a stable, production-ready 1. 0. If you’re interested and willing to test out some beta software, check out our most recent release:  Neatline for Omeka S Development Release 0. xAlternatively, if you like Docker, you can clone this Docker example, follow the README, and have a fresh Omeka S instance with the Neatline plugin referenced.  Omeka S + Neatline 3 DockerThe note on the 0. 1. 0 release lists some known issues. Additionally, we still have plenty of issues on Github to address. If you find an issue that is not already listed, we’d be grateful if you let us know about it by submitting a new issue on Github. Immeasurable thanks to Performant Software for partnering with us on Neatline development, and to the Office of Digital Humanities at the NEH for our grant support. We’re grateful for such wonderful collaborators and supporters. Omeka Community Forum "
        }, {
        "id": 51,
        "url": "https://neatline.org//2020/02/26/neatline-s-0.3.0-release.html",
        "title": "Neatline for Omeka S - Development Release v0.3.0",
        "body": "2020/02/26 - Here’s our most recent development release of Neatline for Omeka S: version 0. 3. 0 Major updates include:  Compatibility with Omeka S 2. 0 Requires Omeka S 2. 0 or higherNeatline for Omeka S is still in development, and this version is not yet ready for production use. We are continuing work on the module, and will do incremental 0. x releases until we’re ready to offer a stable, production-ready 1. 0 version. Currently, we are on schedule to release Neatline for Omeka S by September 2020. Please continue to check here for any updates. If you’re interested and willing to test out some beta software, check out our most recent release:  Neatline for Omeka S Development Release v0. 3. 0Alternatively, if you like Docker, you can clone this Docker example, follow the README, and have a fresh Omeka S instance with the Neatline module referenced.  Omeka S + Neatline 3 DockerWe still have plenty of issues on Github to address. If you find an issue that is not already listed, we’d be grateful if you let us know about it by submitting a new issue on Github. "
        }, {
        "id": 52,
        "url": "https://neatline.org//2019/06/04/neatline-2.6.2-release.html",
        "title": "Neatline 2.6.2 Release",
        "body": "2019/06/04 - Neatline 2. 6. 2 is a security release for all previous versions of Neatline for Omeka Classic, and we strongly encourage you to update to this version immediately. Download Neatline 2. 6. 2 from the Omeka Classic addons page and check out the documentation for upgrading plugins to complete your upgrade. This release addresses a SQL injection vulnerability in the records view. Many thanks to Andrew Angelopoulos and Mathew Tams of Fordham University for reporting the issue. "
        }, {
        "id": 53,
        "url": "https://neatline.org//announcements/2017/07/05/neatline-2-5-2.html",
        "title": "Neatline 2.5.2",
        "body": "2017/07/05 - New release! First, a huge thank you to Jamie Folsom and Andy Stuhl from Perfomant Software Solutions LLC, who did the heavy lifting on the coding for this release. We couldn’t have done it without them. We’re grateful, as well, to Neatline community member Adam Doan (@doana on Github) from the University of Guelph, whose code contributions made Neatline’s first accessibility functionality possible. What’s Fixed:: Google Maps API issues. We originally embedded the API key for Google Maps directly in the Neatline code, but Google changes the way apps should connect to their codebase fairly regularly, and with little or no warning. It’s just easier for everyone if you can directly configure an API key for your specific installation of Neatline, so that’s what we’ve done. Updated installation and configuration instructions (with screencaps!) are available on our documentation site . WMS map layer issues. We thought we had this one squished, but it came back again because of issues with our implementation of OpenLayers 2. 0 and conflicts with the way that MapWarper passes data via URL. MapWarper WMS layers will now render properly as exhibit items and as base layers for an exhibit. What’s New:: Accessibility. Thanks to Neatline community member @doana, you can now specify a URL to an accessible version of your Neatline exhibit in the exhibit’s settings. If the accessible URL exists, a hidden link will be rendered at the top of the public exhibit page directing users of assistive technology to the alternative page so that their screen reader can render the page for them. This feature relates specifically to Guideline 1. 1 of WCAG 2. 0. Our documentation of this new feature will be available on docs. neatline. org by July 10, 2017. For more detail on this update, check out the Changelog. Ready to download? Get the latest release from the Omeka Add-Ons Repository. Encounter an issue? ask a question on the Omeka Forums or submit an issue, or feature request, directly to us on our issue tracker. "
        }, {
        "id": 54,
        "url": "https://neatline.org//announcements/2016/08/12/neatline-implementation-grant.html",
        "title": "Neatline Implementation Grant",
        "body": "2016/08/12 -  You may have noticed on Twitter or elsewhere that the NEH announced funding for almost 300 humanities projects. Congratulations to all! One of the projects awarded was our Neatline Omeka plugin! We’re really excited by the possibilities that this will open up for this project and the ways that we’re planning on improving it. So what do we hope to accomplish? What should you be looking for from the future of Neatline? Primarily, we’re going to focus on graphesis and sustainability. First, Neatline has always been an experiment in trying to embody the principles of graphesis. It’s motivated by the belief that interacting with your project and your data in a visual, hands-on, and messy way informs and changes the way that you think about your project. Of course, modern technology is limited in how well it can enact these principles. As mobile platforms and tablets have matured, however, they offer a more hands-on, material experience. We’d like to incorporate these new technologies and leverage them to improve the experience of creating and exploring Neatline exhibits. Related to this, we want to improve the Neatline Text add-on. This allows Neatline exhibits to incorporate and interact with long-form text. Unfortunately, the editing interface is still very rough. Improving this would go a long way to making Neatline a more compelling platform for creating geotemporal exhibits around a text. And in general, we’ll revisit the editing interface for Neatline to streamline it for common tasks, while making less used features still easily accessible. Second, Neatline is itself also maturing, and like any software project, it’s aging gracefully in some ways, and—ahem—less so in others. We’d like to take this opportunity to make Neatline a more sustainable project. This is a broad goal, so let’s tease it apart. What do I mean by this?    The Omeka team at RRCHNM are working on a new version of the platform, called Omeka S, that will make it significantly easier to host and managing multiple Omeka instances. This will involve significant changes to the plugin architecture, however, so we’ll update Neatline to work with this new version of Omeka.     Currently, Neatline uses OpenLayers for its mapping component. After we included it in Neatline, however, OpenLayers released version 3, which is a major rewrite of this component for modern browsers. Because of licensing issues, it also no longer supports Google maps. We’ll take this opportunity to evaluate upgrading to OpenLayers 3 or going with a different mapping component altogether, such as LeafletJS.     For the timeline component, Neatline uses the SIMILE Timeline. This software is also showing its age, so we’ll look at using a different timeline component, possibly creating one ourselves. This will also give us the chance to evaluate the data models that we use to represent time and change them to accommodate ambiguity and fuzzy dates better. This will also make this part of Neatline better suited to messy humanities data.     But the most important sustainability feature that we’d like to work on is building a more sustainable and active community. This includes better documentation, better tutorials, and better support for getting new developers set up to work on Neatline. We’d also like to make it easier for users to contribute in many ways to the project, whether through code, documentation, design, or other ways.  We’re really excited about the opportunities that this grant opens up for us, and we’re so grateful to the NEH ODH for providing the resources for this. "
        }, {
        "id": 55,
        "url": "https://neatline.org//announcements/experimental%20humanities/research%20and%20development/2015/03/09/neatline-2-4-0.html",
        "title": "Neatline 2.4.0",
        "body": "2015/03/09 - We’re happy to announce a new version of Neatline which adds a couple new features along with resolving a few small issues. The two main features in this release were implemented based on community feedback. First, it’s now possible to set the opacity of a WMS layer when its selected using the “selected” opacity setting. Previously this setting only pertained to drawn geometries on a Neatline record. Second is the ability for custom themes to provide containers for Neatline widgets. This gives theme developers more control over where elements of a Neatline exhibit are displayed on the page. There were also some issues that are resolved. An optimization was introduced in Neatline 2. 3 which caused Neatline to not render WMS maps created using MapWarper. This has been corrected and maps created using the NYPL MapWarper and Harvard WorldMap WARP tools properly render in Neatline. By the way, these two resources provide a great number of maps for you to use in Neatline without needing to run your own instance of GeoServer or other service. We also fixed an issue where styles with an underscore (“_”) in them would not render properly, and we fixed an issue that would move SVG layers at specific zoom levels. You can check out the Changelog for more detail on these changes. As always, you can download the latest release from the Omeka Add-Ons Repository. If you run into any issues, you can always ask a question on the Omeka Forums or submit an issue or feature request on our issue tracker. "
        }, {
        "id": 56,
        "url": "https://neatline.org//geospatial%20and%20temporal/2014/10/11/minard-napoleon-neatline.html",
        "title": "Minard + Napoleon + Neatline",
        "body": "2014/10/11 - [Cross-posted from dclure. org] Open the Exhibit Yesterday I made the hop across the country to Boston for the NEH Workshop on Digital Methods for Military History at Northeastern University, where I’ll be giving a couple of workshops about Neatline and soaking up lots of interesting new projects from old friends and new friends alike. Beautiful fall foliage aside, I’m very excited about this! Ever since we worked on the Hotchkiss projects back in 2012, Neatline and military history have been a great pairing. Which is no accident - military history is often about how things change over time on maps, which is basically the tag line for Neatline. In fact, I’ve always assumed that military history played a pretty big role in inventing the whole vocabulary of visual concepts and techniques that have been picked up by digital tools like Neatline - the flowcharts, the arrows, the diagrammatic ways of representing how things move from one place to another. Hotchkiss was using colored pencils to scratch out annotations onto his battle maps back in the 1870s, which is more or less exactly what Neatline is, minus the computer screen. Anyway, when I started putting together the workshop, I decided to use this as an excuse to build out a little Neatline exhibit that I’ve been rolling around in my head about for about three years - an interactive version of Charles Minard’s classic flow diagram of Napoleon’s 1812 invasion of Russia. This is not an original idea. Minard’s map is sort of like the “Stairway to Heaven” of digital mapping and information visualization, and it’s been remade digitally dozens of times. But, I decided to give it try, and see if I could find some kind of interesting riff. I started out by georeferencing a scan of Minard’s diagram, and then traced out vector annotations on top of each of the individual segments that represent the deteriorating size of the Grande Armée over the course of the invasion: Once the basic structure in place, I realized that I didn’t really have an intuitive sense of the scale of the whole thing - how far was it from the Neman River to Moscow? How long did it take? It turns out that the march was about 540 miles in each direction. I fired up Illustrator, blocked in a little ruler-like shape, and dragged out the annotation along the top of the map: Then, the question of time. This seemed like a good excuse for some d3. I made a little chart on the right side of the screen that plots out the size of the French army over the course of the ~5-month interval of time between when Napoleon crossed the Neman on June 24 and when that last little bit of the army stumbled back out of Russia in December 14. Then, in the exhibit theme, I wrote a little bit of Javascript that wires up the graph with the vector annotations on the map - hover on the graph to highlight the corresponding blocks in Minard’s diagram, and click to zoom to that location: Anyway - simple but fun. I’m looking forward to spending the next two days learning from people who actually know something about military history! "
        }, {
        "id": 57,
        "url": "https://neatline.org//research%20and%20development/2014/09/26/upgrading-neatline-and-omeka.html",
        "title": "Upgrading Neatline and Omeka",
        "body": "2014/09/26 - One of my first projects here at the Scholars’ Lab was to help update some Omeka/Neatline sites. These are sites we keep around as examples of our Neatline plugin for Omeka, and they were a few versions behind. While a pretty easy process to do by hand, having a script to take care of it makes it even easier for future upgrades, too. I call the script ONUS (Omeka Neatline Upgrade Script). While the script was written specifically for our purposes, it may be useful if you have an Omeka install using the Neatline plugin. It can be found here on github. com, feel free to use at your own risk. https://github. com/scholarslab/onus I perhaps went a little overboard and made the script pretty robust. I was going to take the opportunity to learn some Ruby, but ended up writing it in Bash. What is Bash (or ksh or zsh or tcsh)? Bash is a shell. When you open a terminal, or command line, what you type in is called a shell. It takes your commands and does stuff with them. They are all basically the same, but have various things they do better than others, hence the great number of them. A shell script is basically a document that has a list of commands that the shell can run. Most shells allow for some logic, like if/while/case/for statements, variables, functions, etc. Usually very basic programming. (A good tutorial for learning the command line in general is found here: http://cli. learncodethehardway. org/book/) I thought I could write the script very quickly in Bash since I know that language relatively well (much better than Ruby), but one thing I learned is that Bash does not handle comparing floating point numbers. Floating point numbers is a fancy way of saying numbers with decimal points, like version numbers, (ex. 2. 2. 1 and 1. 3. 1). Bash does not have an easy, default way to compare these numbers like most programming languages (like Ruby, Python, and Perl), and even other shells (like ksh and zsh). In retrospect it probably would have been better to write this in Ruby or some “real” programming language from the get go, but alas I didn’t have the need for comparing floating point numbers until most of the logic was already figured out and coded in Bash. I’ll run through how to use the script as well as go through some of the logic for working with floating point numbers in Bash. Running the Script: The script runs the commands needed to upgrade Omeka from 1. 5. x to the latest version, and Neatline from 1. x. x to the latest version. You would run this script on the server/computer where the Omeka installation is found. You can pass the path to the Omeka install to the script, or it will prompt you for it. The script can take four flags/switches/options: -L : Upgrade Omeka and Neatline to the latest and greatest versions. (Note:  Pre-2. 0 versions of Neatline can't be upgraded directly to version 2. 2. Upgrade to version 2. 0 first! )-n [number] : Where [number] is a valid Neatline tag from https://github. com/scholarslab/Neatline. This will upgrade Neatline to the specified version number. Note, all Neatline version have three digits x. x. x. -o [number] : Where [number] is a valid Omeka tag from https://github. com/omeka/Omeka. This will upgrade Omeka to the specified version number. -s : Do not upgrade Omeka-t : Do not upgrade NeatlineBasic Usage::    Download the onus. sh file from the github repo. It doesn’t really matter where you put this script, but your home directory is a good location.     On the command line, enter the directory where the file is located and type the following command. This will allow you to execute the script.  chmod u+x onus. sh If needed, change any default variables at the top of the file, ex. paths to MySQL, PHP, and git. The default is to use your account’s system default. This may be different based on your system, if for example you are testing with MAMP on your Mac computer. MYSQL= /path/to/bin/mysql MDUMP= /path/to/bin/mysqldump MADMIN= /path/to/bin/mysqladmin PHP= /path/to/bin/php  Change one ‘sed’ line if needed, to work with GNU/Linux. Remove the empty double quotes after -ised -i     80s/. */${migrate}/  ${path}/plugins/Neatline/migrations/2. 0. 0/Neatline_Migration_200. php Run the script by typing the following at the command promp; make sure to type the period ( . ) before the forward slash ( / ) and then the script name. . /onus. sh /path/to/omeka/installThis will upgrade Omeka and Neatline to the next available major release. Run the script as many times as needed to get to the latest version. For more examples, please visit the GitHub page at https://github. com/scholarslab/onus NOTE: One important thing to be aware of is when you upgrade from 1. 5. x versions of Omeka and 1. x. x versions of Neatline the Neatline functionality will be broken until Omeka and Neatline are upgraded to the very latest stable versions. So if you plan on using this script, then plan on upgrading to the very latest versions! Getting Back Neatline Exhibits After Upgrading to 2. 0. 0: We noticed one big problem when upgrading sites with versions of Omeka and Neatline previous to 2. 0. 0 by hand. This section will detail the steps to fix it by hand for demonstration purposes, but they are included in the script. Omeka and Neatline both go through some significant database (and code) changes from 1. 5. x to 2. x. x. The biggest seemed to be that the upgrade script for Neatline didn’t “take” and needed to be done manually. For these sites, the Neatline Exhibits did not get transferred from the old database table to the new table. The first step is always to make a backup copy of the database and files. That way if anything goes awry, you can easily put things back together.  To back up the database, simply take a MySQL dump. mysqldump -uUserName -pPassword databasename &gt; databasename. sqlDo this in the main directory of Omeka. Then make a zip file of the entire Omeka directory. zip -r omeka-backup. zip /path/to/omeka/   Next, deactivate any plugins, including Neatline and NeatlineMaps. One of the big changes with the 2. x. x version is that NeatlineMaps is rolled into Neatline.     Grab a 2. 0. x version of Omeka. Either do this with github  git clone https://github. com/omeka/Omeka NewOmekaor with a zip file. wget http://omeka. org/files/omeka-2. 0. 4. zipunzip omeka-2. 0. 4. zip   Add the 2. 0. 0 version of Neatline plugin into the NewOmeka/plugins directory, along with any other upgraded plugins you may need. NeatlineText, NeatlineSimilie and NeatlineWaypoints may be needed if you used that functionality in the previous version.     Copy the db. ini file from the old installation to the NewOmeka/ directory.     Now load the admin page for NewOmeka/ in the browser: http://domain/NewOMeka/admin/. Upgrade the database and login to upgrade and reactivate the Neatline plugin and other plugins as needed.     You may notice things go smoothly, except the existing Neatline exhibits may not transfer. To get them into the new database tables, add the following two lines at line 80 in the NewOmeka/plugins/Neatline/migrations/2. 0. 0/Neatline_Migration_200. php file:  $fc = Zend_Registry::get( bootstrap )-&gt;getPluginResource( FrontController )-&gt;getFrontController();$fc-&gt;getRouter()-&gt;addDefaultRoutes(); Run the following database command to allow the background process to run:mysql -uuser -ppassword database --execute= UPDATE prefix_processes SET status='starting' WHERE id=1;  Run the following php command to get the processes started.   /path/to/bin/php /path/to/NewOmeka/application/scripts/background. php -p 1    Finally, if everything in the new version looks good, you can remove the old and replace it with the new.   mv /path/to/omeka/ /path/to/old-omeka/mv /path/to/NewOmeka /path/to/omeka   Some Script Logic: Initially, I used the script to upgrade both Omeka and Neatline to the next higher version, going through every single minor version incrementally. When upgrading from Omeka 1. 5. 1 and Neatline 1. 0. 0 to the latest versions (2. 2. 2 for Omeka and 2. 3. 0 for Neatline), I had to run the script over 20 times! That was way too labor intensive and time consuming, so next I added some logic to just skip to the next major release. That dropped the times needed to run the script down to four. This is how the script behaves if run without any options. But I could do better than that! I added in some command line options/flags that allow you to upgrade to any Omeka or Neatline version you specify. Now you can upgrade from Omeka 1. 5. x and Neatline 1. x. x directly to Omeka 2. 0. 4 and Neatline 2. 0. 0, then right to Omeka 2. 2. 2 and Neatline 2. 3. 0. Two steps! Bash and floating points: As mentioned above, Bash does not work with floating points, so I had to create a function to deal with that. Dealing with version numbers, especially with minor version numbers kind of requires the need to compare floating point numbers… In the script I use two different functions:   # Compare two floating point numbers.   # Usage:  # if $( compare_floats number1 number 2 ); then  #   echo 'number1 is less'  # else  #   echo 'number2 is less'  # fi  #  # result : the string 'true' or 'false'  # number1 : the first number to compare  # number2 : the second number to compare  # Read it as: is number1 less than number2? It returns 'true' if number1 is  # less, and 'false' if number1 is greater.   function compare_floats() {    echo | awk -v n1=$1 -v n2=$2 '{if (n1&lt;n2) printf ( true ); else printf ( false );}'  }This function basically compares two numbers. It outputs true if the first number is less than the second number, and false if the first number is greater than the second number. Another way to think about it would be to ask the question, is the first number less than the second number? It returns ‘true’ if that is true, and ‘false’ if that is false. The function is basically echoing the result of the awk command, so let’s look at what it does a bit more closely.   awk -v n1=$1 -v n2=$2 '{if (n1&lt;n2) printf ( false ); else printf ( true );}'First we call the awk command with two ‘variable’ flags. The -v says that the next expression sets a value to a variable, so n1 is the variable and $1 is the value. The $1 and $2 are actually variables themselves. When you call this function later in the script, you pass it two numbers. These numbers are automatically assigned to variables, the first number to $1 and the second to $2. The next part of the awk command processes an if/else statement; the part within the single quotes and curly braces. The single quotes are required by Bash, and the curly braces tell awk to process the action. The part within the braces is the basic if/else statement. If the comparison is true, then do the first step; else/otherwise do the next step. So, in our case, if the first number (n1) is less than the second number (n2), then print “true”, otherwise print “false”. See here if you are interested in learning more about the ways of awk http://www. grymoire. com/Unix/Awk. html#uh-1. This function is used in two ways in the script. First, it just does a basic check in an if statement. Check if this number is less than that number:   if $( compare_floats $n_upgrade 2. 0. 0 ); thenThis checks if the next Neatline version is less than 2. 0. 0. If that is true, it runs some commands. Second, we can use the function as part of a multi conditional check:   if [[ -d $path/archive/ &amp;&amp; $( compare_floats $o_upgrade 2. 0. 0 ) ==  true  ]]; thenHere we check if the /archive/ directory exists (used with Omeka versions less than 2. 0) and we also check if the next version to upgrade Omeka to is less than 2. 0. 0. If both of those conditions are met, then we can run some code. Otherwise we do some more conditional checking and different code running. And, the next function…   # Pass the current version first, then the array  # the function echoes the version just greater than the current version,  # i. e. , the next version to upgrade to.   #  # Usage:  # variable=$( get_next_version $num array[@] )  #  # variable : the next version greater than $num  # $num : the current version  # array[@] : an array of all possible versions  function get_next_version() {    num=$1    declare -a ARRAY=( ${!2} )    for i in ${ARRAY[@]}    do      if awk -v n1=$num -v n2=$i 'BEGIN{ if (n1&lt;n2) exit 0; exit 1}'; then        echo $i        break      fi    done  }With this function we are doing a similar thing, comparing two numbers, but we are comparing one number against a list of numbers. To run this function you pass the current version and a list of possible version numbers. The function will compare the number you pass it with the list, and echo the next highest number from the list. Let’s break down this function as well.   num=$1  declare -a ARRAY=( ${!2} )These first two lines are simply getting the input from calling the function and turning them into an internal variable and an internal array. You may remember the ‘$1’ is the first number passed to the function. But where is the ‘$2’? It’s expanded and changed a bit because it is actually an array, or a list of numbers, rather than a single number. In Bash, you can write a variable with a dollar sign (ex. $myNumber) or with curly braces (ex. ${myNumber}). The second option allows you to string multiple variables together and do basic string or array manipulation. For example we could put two variables together: ${myNumber}${anotherNumber} In this case we are declaring a new array named ‘ARRAY’ and pre-populating it with the values of the passed array. We do some indirect expansion to get the values of the passed array, that’s the “${!2}” part. Basically, this part says set the values of the array passed as the values of the new array (in this case we call it ‘ARRAY’), rather than setting the name of the array as the value of the new array. See here for more explanation on Bash arrays and indirection http://wiki. bash-hackers. org/syntax/arrays#indirection Next we do a standard for loop to go through every element or value of the array.   for i in ${ARRAY[@]}Next we check the current version number against each number in the list of version numbers, using the same awk command as before.   if awk -v n1=$num -v n2=$i 'BEGIN{ if (n1&lt;n2) exit 0; exit 1}'; thenIn this case, though, instead of printing ‘true’ or ‘false’ the command exits without errors (exit 0) or exits with an error (exit 1). The if statement that includes the awk command will execute the code within the if statement only if the statement returns true, that is, if the awk command exits without errors. So, if the first number is less than the second number, then exit without errors (true) and echo the second number. This becomes the next version number. Basically you can think of this as getting the current version number, then comparing this to a list of all possible version numbers, starting with the lowest number. When the current version is greater than the possible version number, do nothing. When the current version is not less than the possible version number, then the possible version number is greater, and therefore should be the next version to upgrade to. The break statement within the for loop tells the for loop to stop looping when it has found the next version number. Conclusion: Few, that was a long winded explanation of the script. The two above functions, and accompanying explanation, could have been avoided by using a programming language (like Ruby, Python, or Perl) instead of a shell script because they handle floating point comparisons naturally. So, just to summarize, if you have Omeka and Neatline installed already, and would like to upgrade to the latest version, then you can run this script on the server where Omeka is installed. It requires that you have git installed. All of the other programs it depends on are pretty standard. "
        }, {
        "id": 58,
        "url": "https://neatline.org//research%20and%20development/2014/08/18/omeka-neatline-mac-development-oh-my.html",
        "title": "Omeka, Neatline, Mac, development, oh my!",
        "body": "2014/08/18 - At the Scholars’ Lab, we’re big big advocates of Open Source. All of our projects are available freely and openly on Github, and we’re always more than happy to accept pull requests. We’d like to be able to empower everyone to contribute to our projects as much as they’re able to and comfortable with. Unfortunately, one of our flagship projects, Neatline, isn’t easy to contribute to. There are a number of reasons for this, but one is that the development environment is not trivial to get set up. In order to address this and make it easier for others to contribute, we’ve developed an Ansible playbook that takes a not-quite-stock Mac and sets up an instance of Omeka with the Neatline plugin available, as well as all the tools necessary for working on Neatline. Ansible is a system for setting up and configuring systems. It’s often used to set up multiple servers—for instance, a database server and a static web server, both working with a dynamic web applications deployed on several computers. If you’re familiar with Chef or Puppet, Ansible solves the same problems. In this case, we’ll use it to configure our local development workstation. We’ve published these playbooks on Github in the neatline. dev repository, on the mac-ansible branch. You can get this by cloning it to your local machine. (Since this is for getting started developing Neatline, I assume that you’re already comfortable with git. If not, there are lots of great tutorials. ) $ git clone --branch mac-ansible https://github. com/erochest/neatline. dev. gitRequirements: In creating this, I’ve aimed for starting from a stock Mac. And I missed pretty badly. However, the necessary prerequisites are minimal. You’ll just need to have these things installed.    XCode     Homebrew  Once those two are on your machine, you can install the other two dependencies. These are available through Homebrew. So open Terminal and type these lines: $ brew install python$ brew install ansibleThat’s all. You should be ready to go. Settings: This project includes a number settings that you can change to customize your installation. Those are found in the file playbook. yaml. The relevant section is labelled vars, and it allows you to set information about the Omeka database (omeka_db_user, omeka_db_password, and omeka_db_name), which version of Omeka you wish to use (omeka_version), where you wish to install it (omeka_dir), and where you want to point your browser to (dev_hostname) as you’re working on the site. The defaults are: vars: db_user: root db_password: omeka_db_user: omeka omeka_db_password: omeka omeka_db_name: omeka dev_hostname: omeka-neatline. dev omeka_dir:  /omeka/neatlinedev  omeka_version: stable-2. 1 debug: true neatline_repo: git@github. com:scholarslab/Neatline. git php_version: 55Change these to reflect what you’d like your personal Omeka/Neatline installation to look like. One option that I’ll call out in particular is neatline_repo. This is the git repository that you’ll be working with. If you’re using github to host your project, you can fork the primary Neatline repository (from the URL given above). And when you’ve completed your work, if you’d like to contribute back, you can send us a pull request through the Github site. Setting Up: Finally, we’re ready to actually create the system. This is quite easy. In the Terminal, from the neatline. dev directory, run the neatline-dev script. $ cd neatline. dev$ . /neatline-devNow wait. After your computer whirs away for a while, you’ll get your prompt back. When that happens, you should be able to point your browser to http://omeka-neatline. dev (in the example above). There you’ll see the Omeka installation form. What Just Happened?: The Ansible playbook does a number of tasks.    It installs all the dependencies that you’ll need, including PHP, NodeJS, and MySQL.     It sets MySQL to start automatically when you log in, and it creates the Omeka MySQL user and database.     It configures Apache to work with PHP and to find your Omeka directory.     It downloads and configures Omeka and turns on debugging.     It clones Neatline into Omeka’s plugin directory.     It initializes git flow for working in Neatline and leaves you on the develop branch.     And it installs the necessary JavaScript and PHP tools, including Grunt, Bower, Composer, and PHPUnit.  After all that, it really needs a break. You probably do too. Future: Unfortunately, that’s only the first step that we need to take to make the Neatline code-base approachable. Some more things that we have planned include:    Documentation on all the moving parts.     Documentation on the overall architecture of Neatline.     Documentation on the code. What’s where? If you wish to change something, where would you find it?  As we get those parts in place, we’ll keep you posted. "
        }, {
        "id": 59,
        "url": "https://neatline.org//announcements/2014/07/28/neatline-2-3.html",
        "title": "Neatline 2.3",
        "body": "2014/07/28 - Today we’re happy to announce Neatline 2. 3! This release includes a couple of nifty new features and, under the hood, a pretty big stack of bug fixes, performance tweaks, and improvements to the development workflow. The coolest new feature in 2. 3 is a simple little addition that we’ve gotten a number of requests for in the last few months - the ability to “hard link” to individual records inside of an exhibit. In the new version, when you select a record in an exhibit, a little fragment gets tacked on to the end of the URL that points back to that record. For example, if the record has an ID of 16, the URL will change to something like: www. omeka-site. org/neatline/show/exhibit**#records/16** Then, if someone goes directly to this URL, the exhibit will automatically select that record when the page loads, just as if the reader had manually clicked on it - the map will focus and zoom around the record, the popup bubble will appear, the timeline will scroll, and any other custom event bindings added by the exhibit’s theme will fire. This is nice because it makes it easier to use Neatline as a kind of geospatial “footnoting” system that can be referred to from external resources - sort of like the Neatline Text extension, except the text doesn’t have to be housed inside of Omeka. Imagine you’re working on an article that makes reference to some geographic locations, and you want to plot them out in Neatline. This way you could put the text of the article anywhere on the web (a Wordpress blog, an online journal, etc. ) and just link to the relevant parts of the Neatline exhibit using plain old anchor tags. For example, check out this simple little Neatline exhibit, which just plots out the locations of eight US cities. Then, click on these links to open up the same exhibit, this time focused on the individual cities: New York, San Francisco, Chicago, Los Angeles, Seattle, Denver, Atlanta, and (but of course) Charlottesville.  Check out the change log for the full list of updates in 2. 3, and grab the new production package from the Omeka addons repository. Thanks Jenifer Bartle, Jacki Musacchio, Rachel King, Lincoln Mullen, and Miriam Posner for helping us find bugs and brainstorm about features! As always, drop a note on the GitHub issue tracker if you run into problems or have ideas for new features. "
        }, {
        "id": 60,
        "url": "https://neatline.org//2014/07/02/a-digital-declaration-of-independence-with-text-painting-and-map/",
        "title": "A (Digital) Declaration of Independence",
        "body": "2014/07/02 -  [Cross-posted from dclure. org] Launch the Exhibit: Way back in the spring of 2012, a couple months before we released the first version of Neatline, I drove up to Washington to give a little demo of the project to the folks at the Library of Congress. I had put together a couple of example exhibits for the presentation, but, the night before, I was bored and found myself brainstorming about Washington-themed projects. On a lark, I downloaded a scan of the 1823 facsimile of the Declaration of Independence from the National Archives website, and spent a couple hours tracing polygons around each one of the signatures at the bottom of the document. I showed the exhibit the next day, and had big plans to flesh it out and turn it into a real, showable project. But then I got swept up in the race to get the first release of Neatline out the door before DH2012 in Hamburg, and then sucked into the craziness of the summer conference season, and the project slipped down into the towering stack of things that I could never quite find time to work on. For some reason, though, the idea popped back into my head a couple months ago – maybe because Menlo Park is submerged in a kind of permanent summer, and it pretty much always feels like a good time to eat ice cream and shoot off fireworks. After mulling it over for a couple weeks, I decided to resurrect it from the dead, spruce it up, and post it in time for the 4th of July. So, with two days to spare, here we go – an interactive edition of the Declaration of Independence, tightly coupled with three other “views” in an effort to add dimension to the original document:  A full-text, two-way-linked transcription of the manuscript and the signatures at the bottom. Click on sentences in the transcription to focus on the corresponding region of the scanned image, or click on annotated blocks on the image to scroll the text.  &lt;/li&gt;     An interactive edition of Trumbull’s “Declaration of Independence” painting, with each of the faces outlined and interactively linked with the corresponding signature on the document.  &lt;/li&gt;               All of which is plastered on top of a map that plots out each of the signers’ hometowns on a custom Mapbox layer, which makes it easy to see how the layout of the signatures maps on to the geographic layout of the colonies. Which, by extension, tracks the future division between Union and Confederate states in the Civil War – Georgia and the Carolinas look awful lonely over on the far left side of the document.  &lt;/li&gt; &lt;/ol&gt; Once I positioned the layers, annotated the signatures and faces, and plotted out the hometowns, I realized that I had painted myself into an interesting little corner from an information design standpoint – it was difficult to quickly move back and forth between the three main sections of the exhibit. In a sense, this is an inherent characteristic of deeply-zoomed interfaces. The ability to focus really closely on any one of the three visual grids – which is what makes it possible to mix them all together into a single environment – has the side effect of making the other two increasingly distant and inaccessible, more and more so the further down you go. For example, once you’ve focused in on Thomas Jefferson’s face in the Trumbull painting, it’s quite a chore to manually navigate to the corresponding signature on the document – you have to zoom back, pan the map up towards the scanned image, find the signature (often no easy task), and then zoom back down.       This is especially annoying in this case, since this potential for comparison is a big part of what’s interesting about the content. What I really wanted, I realized, was to be able to switch back and forth in a really simple, fluid way among the different instantiations of any individual person on the document, painting, and map – I wanted to be able to flip through them like a slideshow, to round up all the little partial representations of the person and hold them side-by-side in my head. So, as an experiment, I whipped up a little batch of custom UI components (built with the excellent React library, which fits in like a dream with Neatline’s Javascript API) that provide a “toggling” interface for each individual signer, and the exhibit as a whole.       By default, when you hit the page, three top-level buttons in the right corner of the window link to the the three main sections of the exhibit – the hometowns plotted along the eastern seaboard, the declaration over the midwest, and the painting over the southeast. In addition to the three individual buttons, there’s also a little “rotate” button that automatically cycles through the three regions, which makes it easy to toggle around without looking away from the map to move the cursor:             More useful, though, it’s possible to bind any of the individual signers to the widget by clicking on the annotations. For example, if I click on Thomas Jefferson’s face in the painting, the name locks into place next to the buttons, which now point to the representations of that specific person in the exhibit – “Text” links to Jefferson’s signature, “Painting” to his face, and “Map” to Monticello:             Once you’ve activated one of the signers, click on the name to show an overlay with a picture and biography, pulled from a public domain book published by the National Park Service called Signers of the Declaration:             This is pretty straightforward on the map and document, where there’s always a one-to-one correspondence between an annotation and one of the signers. Things get more complicated on the map, though, where it’s possible for a single location to be associted with more than one signer. Philadelphia, for example, was home to Robert Morris, Benjamin Rush, Benjamin Franklin, John Morton, and George Clymer, so I had to write a little widget to make it possible to hone in on just one of the five after clicking the dot:             Last but not least, each sentence in the document itself is annotated and wired up with the corresponding text transcription on the left – click on the image to scroll the text, or click on the text to focus the image:             Happy fourth!                "
        }, {
        "id": 61,
        "url": "https://neatline.org//2014/04/01/creating-themes-for-individual-neatline-exhibits/",
        "title": "Creating themes for individual Neatline exhibits",
        "body": "2014/04/01 - Neatline makes it possible to create separate themes for individual exhibits, which is useful if you want to host a collection of self-contained Neatline projects on a single site. To get started, fork the exhibit starter theme, which abstracts out the style, layout, and UX of the Project Gemini over Baja California exhibit. One of the coolest but most under-documented features in Neatline is the ability to create separate themes for each individual exhibit. Since Neatline exhibits are just one particular type of “view” inside of Omeka, it’s always been possible to customize the styling and layout at the level of the Omeka theme. Changes the the Omeka theme, though, propagate to all the exhibits on the site. In many cases, this is ideal – if you have a collection of closely-related Neatline projects, all part of the same thematic umbrella, it makes sense that they should all look more or less the same. For examples of this, check out Jeremy’s beautiful Astrolabe and Neatscape themes for Omeka, which were designed with Neatline projects in mind. In other cases, though, this can be a real hindrance. Sometimes it can make sense to host a number of self-contained Neatline exhibits in the same installation of Omeka. For example, imagine you’re using Neatline in a big lecture course, and you split the class up into 10-15 groups of students, all working on separate exhibits. As the semester draws to an end, some of the groups want to use the NeatlineText plugin, and need a layout that positions the exhibit narrative on the side of the screen, flush with the edge of the window. But other groups are just threading the text content into the record bodies, and don’t want a big, empty container element taking up space on the screen. How to handle both at once? Or, for a concrete example, take a look at the Neatline Labs site, which I use a sandbox for little Neatline-powered experiments and feature demos. By design, these projects are all totally different – different content, different layouts, different Javascript interactions, etc: It would be annoying to have to spin up a completely new instance of Omeka for each of these projects. To get around this, Neatline implements its own “sub-theming” system, piggybacking on top of the capabilities provided by Omeka, that makes it possible to customize part or all of the appearance, layout, or behavior of each exhibit on an individual basis. This is an opt-in system that can be mixed with the regular, site-wide theming system – if you have 10 Neatline exhibits on your site, you could write exhibit-specific themes for three of them, and leave the other seven unchanged, allowing them to continue to inherit the generic Omeka theme. And, within the three exhibit-specific themes, you have full control over which parts of the theme you override – for one, you could leave the layout unchanged, but modify the CSS; for another, you could leave the CSS the same but change the layout and add some custom Javascript interactions. Exhibit-specific themes are also highly portable – once you’ve built one to your liking, it can be adapted for new exhibits just by copying and renaming the directory. I’ve held off on documenting this publicly because I wanted to be sure that the file structure and Javacsript APIs used in the themes worked well at scale – but at this point it’s all pretty battle tested, and I’m curious to see what other folks can come up with! Getting started: Creating the theme directory: Neatline themes are created as directories that sit inside of the Omeka theme. For any given exhibit, Neatline will look for a theme directory that has the same name as the “URL slug” of the exhibit, the unique, plain-text identifier used to form the end of the exhibit’s public-facing URL. So, imagine you’ve got an exhibit called “Test Exhibit,” with a URL slug of test-exhibit. To create a theme for the exhibit, create a directory called test-exhibit at this location relative to the root of your Omeka theme: [omeka-theme]/neatline/exhibits/themes/test-exhibit For example, here’s the layout of my fork of the Neatlight theme, with the theme directories for a handful of exhibits at neatline. dclure. org: Anatomy of a Neatline theme: Neatline themes consist of just four files: style. css, script. js, show. php, and item. php. style. cssUse style. css to add custom CSS to the exhibit. Neatline loads this as the last stylesheet on the page, after the Omeka CSS and after the CSS provided by the Neatline core (which, if you want, can be omitted from the page by providing a custom show. php template – see below). style. css can be anything from a handful of simple rules to change fonts or colors up to a complete redesign of the page. script. jsUse script. js to add custom Javascript interactions to the page. Again, these can be as simple or complex as needed. The Neatline front-end application is a big chunk of code, and it’s a bit beyond the scope of this article to really dive into the API in detail. The gist of it, though, is that Neatline is structured as a bunch of little mini-applications, called “modules,” that communicate with one another using a pub-sub messaging system, powered by the superb EventAggregator component in the Marionette framework. The cool thing about this architecture is that snippets of code in the script. js file can hook directly into this messaging system and interact with Neatline just as if they were included in the core codebase – Neatline literally won’t know the difference. There’s really no limit to what you could do here – the entire Neatline editing environment, for instance, is implemented as a single module (containing lots and lots of nested sub-modules), and could theoretically be grafted onto Neatline completely inside of an exhibit theme. This makes it possible to wrap up a Neatline exhibit in pretty much any kind of interface without having to modify the internals. That said, in most cases you’ll probably just need a few little snippets to add in some visual bells and whistles, or to manage complex layout tasks that are tough to accomplish in CSS. For example, here are a few snippets I used in the Project Gemini over Baja California project:  Position the text container on the left side of the screen and fill the height of the window:&lt;/li&gt;     Add an NProgress-powered loading bar to the page:&lt;/li&gt;         Implement custom zooming buttons:&lt;/li&gt;                     Add a “Loading Tiles…” spinner that displays when WMS imagery is being loaded from Geoserver:&lt;/li&gt; &lt;/ul&gt;For an example of a fully-fledged module, which follows the file layout conventions of the Neatline core, take a look at the Lines module in the Gemini theme, which intercepts events broadcast by NeatlineText and draws the little yellow lines between the text and the map.         show. php        By default, all Neatline exhibits are displayed using the show. php that ships with the plugin. If you create a file called show. php in the exhibit theme, though, Neatline will use that file in place of the default. This makes it possible to completely customize the structure of the markup in any way you want. For example, if you look closely at some of the Jacascript examples above, you’ll notice that in a couple of places the code is selecting elements (things like $('#wms-loader') and $('div. narrative')) that aren’t actually templated anywhere in the default show. php, which looks like this:         This works, though, because I’m providing a custom show. php template that provides those elements (e. g. , see the #wms-loader element down near the bottom):         item. php        Last but not least, Neatline makes it possible to override the template that’s used to generate the metadata output for items displayed inside Neatline exhibits. By default, Neatline uses a simple template that pretty much just follows the layout of the regular item “show” pages in Omeka:         But, imagine you had an exhibit that was filled with items that represent photographs, and, for the sake of cleanliness and visual economy, you just want to display the item title and the image thumbnail. Just drop in a new item. php template that does exactly what you need:         And Neatline will automatically use that template instead of the default. What if you need different templates for different items, though? For example, imagine that you actually have two types of items in the exhibit – the images, which just need the title and thumbnail, but also a set of letters, which are structured as “Text” type items with the transcriptions of the documents entered into the “Text” field. So, how to display both types of items in the exhibit, without resorting to a weird, Frankenstein template that accommodates both?         First, add tags to the records in Neatline:                 Then, just create two template in the exhibit theme – one called item-image. php (the same as above), the other called item-letter. php. In the letter template, just display the title and text:         Neatline will automatically use the tag-specific templates for any records tagged with image or letter, and fall back to the unadorned item. php template for records that aren’t tagged.         Starter theme:         So far, we’ve just been entering all of our custom CSS and Javascript directly into the style. css and script. js and files. This works fine for simple themes, but it can start to get a little clunky as the theme grows more complex – nobody likes to see a big heap of Javascript snippets, all doing different things, crammed into the same file. So, how to decompose style. css and script. js into separate files? One good solution is to use a task runner like Grunt to concatenate multiple source files into the style. css and script. js files, which, instead of being edited directly, become compiled payload files that are updated automatically by the task runner.                  To make it easy to get started, I’ve created a little starter theme, based on the theme used for the Project Gemini over Baja California project, with all of the configuration and file structure in place to build out themes for exhibits that use the NeatlineText extension. This includes all of the layout, styling, and UX interactions from the Gemini project, like the little yellow lines that wire up the text with the map.         https://github. com/scholarslab/neatline-theme-template         Just fork the repo, clone it into your Omeka theme, and theme into the sunset!                             "
        }, {
        "id": 62,
        "url": "https://neatline.org//2014/03/31/neatlinetext-connect-neatline-exhibits-to-documents/",
        "title": "NeatlineText: Connect Neatline exhibits to documents",
        "body": "2014/03/31 -  Download the plugin: Today we’re pleased to announce the first public release of NeatlineText, which makes it possible to create interactive, Neatline-enhanced editions of text documents – literary and historical texts, articles, book chapters, dissertations, blog posts, etc. – by connecting individual paragraphs, sentences, and words with objects in Neatline exhibits. Once the associations are established, the plugin wires up two-way linkages in the user interface between the highlighted sections in the text and the imagery in the exhibit. Click on the text, and the exhibit focuses around the corresponding location or annotation. Or, click on the map, and the text scrolls to show the corresponding sections in the text. We’ve been using some version of this code in internal projects here at the lab for almost two years, and it’s long overdue for a public release. The rationale for NeatlineText is pretty simple – again and again, we’ve found that Neatline projects often go hand-in-hand with some kind of regular text narrative that sets the stage, describes the goals of project, or lays out an expository thesis that would be hard to weave into the more visual, free-form world of the Neatline exhibit proper. This is awesome combination – tools like Neatline are really good at displaying spatial, visual, dimensional, diagrammatic information, but nothing beats plain old text when you need to develop a nuanced, closely-argued narrative or interpretation. The difficulty, though, is that it’s hard to combine the two in a way that doesn’t favor one over the other. We’ve taken quite a few whacks at this problem over the course of the last few years. One option is to present the text narrative as a kind of “front page” of the project that links out to the interactive environment. But this tends to make the Neatline exhibit feel like an add-on, something grafted onto the project as an after-thought. And this can easily become a self-fulfilling prophecy – when you have the click back and forth between different web pages to read the text and explore the exhibit, you tend to write the text as a more or less standalone piece of writing, instead of weaving the narrative in with the conceptual landscape of the exhibit. Another option is to chop the prose narrative up into little chunks and build it directly into the exhibit – like the numbered waypoints we used in the the Hotchkiss projects back in 2012, each waypoint containing a small portion of a longer interpretive essay. But this tends to err in the other direction, dissolving the text into the visual organization of the exhibit instead of presenting it as a first-class piece of content. NeatlineText tries to solves the problem by just plunking the two next to each other and making it easy for the reader (and the writer!) to move back and forth between the two. For example, NeatlineText powers the interactions between the text and imagery in these two exhibits of NASA photograph from the 1960s:  (Yes, I know – I’m a space nerd. ) NeatlineText is also great for creating interactive editions of primary texts. An earlier version of this code powers the Mapping the Catalog of Ships project by Jenny Strauss Clay, Courtney Evans, and Ben Jasnow (winner of the Fortier Prize prize at DH2013!), which connects the contingents in the Greek army mentioned in Book 2 of the Iliad with locations on the map: And NeatlineText was also used in this interactive edition of the first draft of the Gettysburg Address: Anyway, grab the code from the Omeka add-ons repository and check out the documentation for step-by-step instructions about how to get up and running. And, as always, be sure to file a ticket if you run into problems! "
        }, {
        "id": 63,
        "url": "https://neatline.org//2014/03/17/project-gemini-over-baja-california/",
        "title": "Project Gemini over Baja California",
        "body": "2014/03/17 -  [Cross-posted from dclure. org] Launch the Exhibit: A couple weeks ago, somewhere in the middle of a long session of free-association link hopping on Wikipedia, I stumbled into a cluster of articles about Project Gemini, NASA’s second manned spaceflight program. Gemini, I quickly discovered, produced some spectacular photographs – many of them pointed downward towards the surface of the earth, capturing a dizzying opposition between the intelligible scale of the foreground (the 20-foot capsule, 100-foot tethering cords, 6-foot human bodies floating in space) and the completely unintelligible scale of the massive geographic entities below (peninsulas, continents, oceans). As I started to click through the pictures, I found myself reflexively alt-tabbing back and forth between Chrome and Google Earth to compare them with the modern satellite imagery of the same geographic locations. Which made me think – why not try to actually combine the two into a single environment? Over the course of the next few days, I sketched out a little Neatline exhibit that plasters two photographs of Baja California Sur – taken about a year apart on Gemini 5 (August 1965) and Gemini 11 (September 1966) – around the Mapbox satellite imagery of the peninsula. Instead of lining up the coastlines to make the images overlay accurately on top of the satellite tiles, I just plunked them down on the map off to the side at a scale and orientation that makes it easy to compare the two. (We’ve played around with this before, and I like to think of it as faux – or just especially humanistic! – georectification. ) Then, using the drawing tools in Neatline, I blocked in some simple annotations that visually wire up the two sets of imagery – outlines around the four islands along the eastern coast of the peninsula, and arrows between the different instantiations of La Paz and San José del Cabo. I also wanted to find a way to visually formalize the difference in perspective between the Gemini photographs (oblique, wide-angle, deliberate) and the Mapbox tiles (flat-on, uniform). Using Illustrator, I created a long, ruler-like vector shape to label the ~200-mile distance between La Paz and the approximate positon of the Gemini 5 capsule when the picture was taken, and then used the “Perspective Grid” tool to render the shape in three dimensions and place it on top of the Gemini photograph, as if the same shape were physically positioned in front of the lens. In Illustrator: And placed in the Neatline exhibit, first to match the shallow angle of the Gemini shot: And then to match the perpendicular angle of the Mapbox tiles: I was also fascinated by the surreal opposition in scale between the Agena Target Vehicle (an unmanned spacecraft used for docking practice in orbit) and Isla San José, which sits serenely in the dark blue of the Gulf of California hundreds of miles below, but occupies almost exactly the same amount of space in the photograph as the 7-foot boom antenna on the Agena. In the space between the two, I dragged out two little shapes that map the sizes of things onto recognizable objects – a 6-foot person in the foreground, Manhattan in the background: Perspective and Perspectivelessness These images fascinate me because they roll together two types of imagery – both ubiquitous on the web – that are almost exact opposites of one another. On the one hand, you have regular pictures, taken by regular (non-astronaut) people. These photographs freeze into place one particular perspective on things. In a literal sense, the world recedes from the lens in three dimensions – walls, buildings, bridges, mountains, valleys, clouds. Close things are big, distant things are small. Some are in focus, others aren’t. And unlike other forms of art like painting, poetry, sculpture, or music, which can claim (overconfidently, maybe) to graft completely new material onto the world, photographs innovate at the level of stance and viewpoint, the newness of the perspective on things that already exist. It’s less about what they add, more about what they subtract in order to whittle the world down to one particular frame. Why that angle? Why that moment? Why that, and not anything else? On the other hand you have spatial photography – the satellite imagery used in Google Maps, Mapbox, Bing Maps, etc. – which is almost completely perspectiveless, in just about every sense of the word. The world becomes a flat, depthless plane, photographed from a distance at a perpendicular angle. Instead of trying to find interesting new ways to crop down the world, spatial tiles try to be comprehensive and standardized. Instead of showing one thing, in one way, at one moment in time, they try to show everything, in the exact same way, at the exact same moment – now. The companies that source and assemble the satellite imagery race to keep it as current as possible, right at the threshold of the present. Last year, Google announced that its satellite imagery had been purged of all clouds. No doubt this makes it more functional, but it also does away with those wispy, bright-white threads of cloud that used to hang over the rainforests in Peru and Brazil, which were lovely. What’s gained, of course, is the intoxicating grandeur of it all, the ability to hold in a single view a photograph of the entire world – which, if nothing else, is some sort of crazy affirmation of human willpower. I always imagine Whitman, scratching out “Salut au Monde“, panning around Google Maps for inspiration. Photographs taken by astronauts, though, collapse the distinction in interesting ways. They’re literally “satellite” photography, but they’re also drenched in subjectivity and historical stance. The oceans and continents spread out hundreds of miles below, just like on Google Maps or Mapbox – but the pictures were snapped with regular cameras by the hands of actual people, stuffed into little canisters falling around the world at thousands of miles an hour, which were only up there in the first place due to a crazy mix of socio-political ambitions and anxieties that were deeply characteristic of that particular moment in history. The Gemini imagery is haloed with little bits of space-race technology that instantly historicizes the frame – the nose cone of the capsule blocks out a huge swath of desert and ocean, the Agena vehicle hangs just a couple of hundred feet from the camera, tethered by a slight, ribbon-like cord that twists for hundreds of miles across the Gulf of California. "
        }, {
        "id": 64,
        "url": "https://neatline.org//2014/02/04/the-nicolay-copy-of-the-gettysburg-address/",
        "title": "The “Nicolay copy” of the Gettysburg Address",
        "body": "2014/02/04 - Cross-posted from dclure. org Launch the Exhibit: This is a project that I’ve been hacking away at for some time, but only found the time (and motivation) to get it polished up and out the door over the weekend – a digital edition of the “Nicolay copy” of the Gettysburg Address, with each of the ~250 words in the manuscript individually traced out in Neatline and wired up with a plain-text transcription of the text on the right side of the screen. I’ve tinkered around with similar interfaces in the past, but this time I wanted to play around with different approaches to formalizing the connection between the digitally-typeset words in the text and the handwritten words in the manuscript. Your eyes tend to dart back and forth between the image and the text, and it’s easy to lose your place – how to reduce that cognitive friction? To chip away at this, I wrote a little sub-plugin for Neatline called WordLines, which automatically overlays a little visual guideline (under the hood, a d3-wrapped SVG &lt;/p&gt;&lt;line&gt; element) on top of the page that connects each pair of words in the two viewports when the cursor hovers on either of the instantiations. So, when the mouse passes over words in the transcription, lines are automatically drawn to the corresponding locations on the image; and vice versa. From a technical standpoint, this turns out to be quite easy – just get the pixel offsets for the &lt;span&gt; element in the transcription and the vector annotation on the map (for the latter, OpenLayers does the heavy lifting with helpers like getViewPortPxFromLonLat, which maps spatial coordinates to document-space pixel pairs), and then draw a line connecting the two points. The one hitch, though, is that this involves placing a large SVG element directly on top of the page content, which, by default, will cover all of the underlying elements (shapes on the map, words in the text) and block them from receiving the cursor events that drive the rest of the UI – including, very problematically, the mouseleave event that garbage-collects old lines and prevents them from getting stuck on the screen.  The work-around is to put pointer-events: none; on the SVG element, which causes the browser to treat it as a purely visual veneer over the page – cursor events drop through to the underlying content elements, and everything else behaves normally. This is just barely and only very recently cross-browser, but I’m not sure if there’s actually any other way to accomplish this, given the full set of constraints. Modeling intuitions about scale Originally, I had planned to just leave it at that, but, as is almost always the case with these projects, I ended up learning lots of interesting things along the way, and I ended up going back and adding in another set of annotations that make note of some of the more historically noteworthy aspects of the manuscript. Namely, I was interested in the different types of paper used for the two different pages (Lincoln probably wrote the first page in Washington before departing, the second page after arriving in Gettysburg) and the matching fold creases on the pages, which some historians have pointed to as evidence that the Nicolay copy was perhaps the actual “reading copy” that Lincoln used when delivering the speech, since eyewitness accounts describe Lincoln pulling a folded piece of paper out of his coat pocket. The other candidate is the Hay draft, which includes lots of changes and corrections in Lincoln’s hand, giving it the appearance of working draft that was prepared just before the event. One problem with the Hays draft, though, is its size – it’s written on larger paper and has just a single fold down the center, which would seem to make it an unlikely thing to tuck into coat pocket. When I read about this, I realized that I had paid almost no attention to the physical size of the manuscript. On the screen, it’s either extremely small or almost infinitely large – a tiny speck when you zoom far back, and an endless plane of beige-and-black when you zoom in. But, in this case, size turns out to be of great historical significance – the Nicolay copy is smaller than the Hays copy, especially when folded along the set of matching creases clearly visible on the pages. So, how big is it? This involved a bit of guesswork. The resource page for the manuscript on the Library of Congress website doesn’t include dimensions, and direct Google searches didn’t turn up an easy answer, so I started poking around the internet to see if I could find other Lincoln manuscripts written on the “Executive Stationery” used for the first page. I rooted up a couple of documents for sale by rare book sellers, and in both cases the dimensions are listed at about 5 inches in width and 7-8 inches in height, meaning that the Nicolay copy – assuming the stationery was more or less standardized – would have folded down to a roughly 5 x 2. 5-inch rectangle, which seems reasonably pocket-sized. (Again, this is amateur historical conjecture – if I’m wrong, please let me know!) I sketched out little ruler annotations labeling the width of the page and the height of the fold segment, but, zooming around the exhibit, I realized that I still didn’t any intuitive sense of the size of the thing. Raw numerical measurements, even when you’re beat across the head with them, become surprisingly abstract in the a-physical, point-of-reference-less netherlands of deeply-zooming digital landscapes. I dug out a ruler and zoomed the exhibit back until the first page occupied five real-world inches, and then held my hand up to the screen, imagining the sheet of paper in my hand. And then I thought – why not just bake some kind of visual reference directly into the exhibit? I hunted down a CC-licensed SVG illustration of a handprint, and, using the size of my own hand as a reference, used Neatline’s import-SVG feature to position the outline in the whitespace to the right of the first page of the manuscript: "
        }, {
        "id": 65,
        "url": "https://neatline.org//2014/01/15/neatline-release-apalooza-neatline-2-2-0-neatscape-astrolabe/",
        "title": "Neatline release-apalooza: Neatline 2.2.0, Neatscape, Astrolabe",
        "body": "2014/01/15 -  Today we’re excited to announce the release of Neatline 2. 2. 0! This is a big update that ships out a cluster of features and fixes that address a couple of rough spots identified by users over the course of the last couple months. 2. 2. 0 focuses on improvements in two areas – first, we’ve overhauled the workflows that connect Neatline records with Omeka items to make them more intuitive, flexible, and feature-rich, with the goal of making the overall integration between the two environments feel more seamless and low-friction. Second, we’ve added a system of interactive documentation to the editor that builds reference materials and tutorials directly into the interface, which should make it easier for new users to find their way around. We’re also pushing out maintenance releases of the two extensions, NeatlineSimile and NeatlineWaypoints, which add compatibility for Neatline 2. 2 and deal with a couple of minor bugs. As always, grab the code from the Omeka addons repository:       Neatline 2. 2. 0   NeatlineSimile 2. 0. 1   NeatlineWaypoints 2. 0. 2   What’s more, we’re also making release candidates available for two new Omeka themes designed to showcase Neatline exhibits: Astrolabe and Neatscape. Loyal readers may recall that a while back, we ran a theme naming contest, and we’re finally making good on our word! These are just release candidates, but we wanted to get them out in the open for testing and feedback before cutting off stable releases. Give them a spin, and be sure to file a ticket on the respective issue trackers (Astrolabe and Neatscape) if you find quirks or need new features. Some highlights in Neatline 2. 2:    Adds a new interface for linking Neatline records to Omeka items that makes it possible to browse the entire collection of items, run full-text searches, and instantaneously preview the Omeka content (metadata, images, etc. ) as it will appear in the public Neatline exhibit.    Frees up the “Title” and “Body” fields for modification on Neatline records linked to Omeka items. Previously, these fields were automatically populated with the item content imported from Omeka, making it impossible to add custom information not contained in the Omeka metadata. Now, Neatline leaves these fields open for editing and displays them above the content synced in from Omeka, making it possible (though not required) to add exhibit-specific headings and text descriptions for imported items.    Makes it possible to import raw data from the Dublin Core “Coverage” field. When Omeka items are imported into Neatline exhibits, existing values in the Dublin Core “Coverage” field (either KML or WKT strings) are now automatically imported into Neatline and displayed on the map. Previously, this only worked if the coverage on the item was created with the Neatline Features plugin. With this functionality in place, it’s much easier to bulk-import existing spatial data sets – use the CSV Import plugin to populate a collection of items, and then push the new items to a Neatline exhibit.   Adds interactive documentation to the editor that builds reference materials for each individual control directly into the interface. Now, the heading for each input is followed by a little “?” button that, when clicked, overlays a document with information about what the control does, how to use it, and how it interacts with other functionality. The goal is to make the editor effectively self-documenting, so that it’s unnecessary to find separate documentation and toggle back and forth between different tabs as you work. Last semester was a busy one for Neatline – we were supporting twelve classes here at UVa that are using Neatline for research assignments, and had the good fortune to collaborate with a number of folks at Harvard, Stanford, Northeastern, Duke, Indiana, and elsewhere who were using Neatline or gearing up for upcoming projects in the new year. We’ve also got a couple of exciting ideas brewing here in the lab for new, Neatline-powered projects – keep an eye on this space over the course of the next couple months. As always, don’t hesitate to file bug reports on the issue tracker, post questions to the forums, or contact us directly. Happy new year! "
        }, {
        "id": 66,
        "url": "https://neatline.org//2013/12/11/neighborhoods-of-san-francisco/",
        "title": "Neighborhoods of San Francisco",
        "body": "2013/12/11 -  [Cross-posted from dclure. org] View the Exhibit: Built on the Stamen Toner layer. Back in October, about a month after moving from Scholars’ Lab HQ in Virginia out to Menlo Park (my partner started a PhD program at Stanford), I drove up the peninsula to San Francisco on a Saturday morning and set out on a long, rambling, 10-mile trek along the northwest shoulder of the city. It was a fantastic day – I walked west through Golden Gate Park, north along the Richmond beach, past the Cliff House, into the fog over Lincoln Park, through the mansions in Sea Cliff, past the abandoned artillery nests on the western coast of the Presidio, and finally out onto the Golden Gate bridge. From there, I headed south through the trails in the Presidio, into Richmond, and eventually back to where I started, near the top right corner of the park. From the middle of the Golden Gate Bridge, you can look out to the east over a large swath of the city – the skyscrapers of the financial district, the new span of the Bay Bridge hanging over Treasure Island, Alcatraz, and the faded outline of the East Bay, the Berkeley campus a little smudge at the base of the ridge line. But, scanning my eyes over the rest of the city, I realized that I had very little sense of what I was actually looking at. I could attach labels onto all the touristy landmarks, but I didn’t have any kind of intuitive mental geography of the place – the names of all the little hills and neighborhoods, what connects to what, how to string the pieces of the city together into workable routes and itineraries. So, over the course of the next few weeks, I slowly cobbled together a Neatline exhibit that plots out each of the neighborhoods in the city – 87 of them, by my count, although it’s somewhat a matter of interpretation as to how they should be sliced and diced. Working mainly from this image as reference, I started by tracing rough outlines of the boundaries (using Neatline’s standard-issue “Draw Polygon” tool) on top of Stamen’s Toner layer. Then, once the borders were in place, I used Neatline’s SVG import tool to place vector-geometry text labels on top of each of the individual neighborhoods, inspired by other spatial-wordcloud experiments like this and this. Adventures in geospatial typesetting This was great fun, and, interestingly, it ended up overlapping in unexpected ways with the interactive typesetting projects that I was playing with earlier in the semester. The process of positioning the labels becomes a kind of textual jigsaw puzzle, a game of trying to wrangle the raw, geometric instantiations of words into a coherent organizational scheme – except, this time, against the backdrop of actual geospatial coordinates and locations, not the abstract, featureless voids of the poetry experiments. Often, this is pretty straightforward – Noe Valley and the Inner Mission, for example, just get tagged as such: In other places, though, the names of the neighborhoods overlap with one another in ways that make it possible to find interesting “economies” in how the words can be laid out on the map – when adjacent neighborhoods share the same words, it’s sometimes possible to essentially atomize the names into their component parts, and then rebuild them according to their own spatial logic, in a sense, by visually stringing together the pieces on the map. Take Richmond, for example, which is divided into three side-by-side segments: Outer Richmond, Central Richmond, and Inner Richmond. Instead of cluttering things up by repeating “Richmond” for each of the three sections, I just dragged out a single, all-encompassing “Richmond” across the entire width of the three sub-neighborhoods, and the blocked in the three modifiers as smaller words on top of the corresponding sections: This worked much the same way for the Sunset and Parkside neighborhoods, which share the same cleanly partitioned spatial organization: With the exception of the “middle” portion of Parkside, which is just the un-prefixed “Parkside,” meaning that the center piece doesn’t get a separate modifier: In other cases, though, it gets much trickier, and much more interesting. Take the little cluster of neighborhoods at the southwest corner of the Presidio, the big park at the base of the Golden Gate Bridge. It’s a hodgepodge of repeated names, but in a much more scrambled and overlapping way – Presidio, Presidio Heights, Pacific Heights, Lower Pacific Heights. In this case, I had to take a bit more care to place the little black arrows in ways that didn’t connote incorrect linkages among the names. For example, the relationship between Presidio and Presidio Heights moves in just one direction – Presidio Heights (labelled with just “Heights” on the map) needs to “inherit” the “Presidio” modifier from the Presidio, but not the other way around, since the Presidio ceases to be the Presidio when “Heights” is tacked onto it: To encode these relationships, I settled on a rule of thumb that the arrows would always be contained inside the neighborhoods that they modify. So, the arrow pointing from “Presidio” to “Heights” is fully contained inside of the geographic boundaries of Presidio Heights, in the sense that it pulls “Presidio” downward into the “Heights,” without also pushing “Heights” back in the other direction (which would effectively mislabel the Presidio). Likewise the link between “Pacific” and “Heights” is contained within the Pacific Heights outline, since otherwise Presidio Heights would be implicitly but incorrectly prefixed by “Pacific. ” Anyway, this is all completely useless as actual cartographic practice, but great fun as a kind of abstract étude of information design. It’s also incredibly useful as a mnemonic device – after untold hours in Palo Alto coffee shops sketching out all the outlines and positioning the labels, they’re all thoroughly burned into my mind. This is an interesting aspect of digital mapping projects that doesn’t get a lot of attention – we tend to focus on the final products, the public-facing visualizations and interactions (for good and obvious reasons), but much less on the process that goes into creating them, the personal acquisition of knowledge that takes place when you force yourself to spend dozens or hundreds of hours painstakingly positioning and repositioning things on maps. It gives you an incredible sense of cognitive intimacy with the space, the ability to load a little chunk of the world into working memory and reason about it in really complex and interesting ways. "
        }, {
        "id": 67,
        "url": "https://neatline.org//2013/10/14/nitle-presentation-on-geotemporal-storytelling-with-neatline/",
        "title": "NITLE Presentation on Geotemporal Storytelling with Neatline",
        "body": "2013/10/14 -  About this time last year, David McClure and I had a great conversation with the folks from the National Institute for Technology in Liberal Education (NITLE) about geotemporal storytelling with Neatline. We had lots of great questions and comments from the audience, too. Video for the talk is now available on NITLE’s YouTube channel: "
        }, {
        "id": 68,
        "url": "https://neatline.org//2013/10/11/the-song-of-wandering-aengus-neatline-and-negotiation-with-the-machine/",
        "title": "“The Song of Wandering Aengus,” Neatline, and negotiation with the machine",
        "body": "2013/10/11 -  [Cross-posted from dclure. org] Click here to view the exhibit. : One last little experiment with Neatline-powered interactive typesettings – this time with the ending of Yeats’ endlessly recitable “The Song of Wandering Aengus,” which, like many great poems, seems to somehow signify the entire world and nothing really in particular. I chose to use just the last three lines so that it would be possible to play with a more dramatic type of geometric nesting that, with more content, would quickly run up against the technical limitation that I mentioned in Wednesday’s post about “A Coat” – the vector geometry used to form the letters starts to degrade as the Javascript environment runs out of decimal precision at around 40 levels of zoom, making it impossible to continue the downward beyond a certain point. With just three lines, though, I was able to place each consecutive line completely inside of one of the dots above an “i” in the previous line. So, the “silver apples of the moon” are inscribed into the dot over the “i” in the “till” of “till time and times are done,” and the “golden apples of the moon” are then contained by the dot on the “i” in “silver. ” Since the nested lines are placed literally inside the shaded boundaries of letters (as opposed to the empty spaces delineated by the “holes” in letters, as was the case with the first two experiments), the color of the text has to alternate in order to be legible against the changing color of the backdrop. What I didn’t expect (although in retrospect I guess it’s obvious) is that this shift in the color palette completely modulates the visual temperature of the whole environment – the backdrop swerves from bright white to solid black back and then back to white over the course of the three lines, with the last transition mapping onto the night-to-day, moon-to-sun thematic movement in the final couplet. Interestingly, this effect was almost thwarted by another unexpected quirk in the underlying technologies, although I managed to maneuver around it with a little hack in the exhibit theme. The problem was this – it turns out that OpenLayers will actually stop rendering an SVG geometry ones the dimension of the viewport shrinks down below a certain ratio relative to the overall size of the shape. So, in this case, as the camera descends down into the black landscape of the dot over the first “i,” the black background supplied by the vector shape would suddenly drop away, as if the camera were falling through the surface, which of course had the effect of making the second-to-last line – typeset in white – suddenly invisible against the default-white background of the exhibit. I thought this was a showstopper, but then I realized that I could programmatically “fake” the black background by directly flipping the CSS background color on the exhibit container. So, I just fired up the Javascript console, inspected the zoom attribute on the OpenLayers instance to get the zoom thresholds where the color changes needed to happen, and then dropped a little chunk of custom code into the exhibit theme that manifests the style change in response to the zoom events triggered by the map: Weird, but effective. Whenever I work on projects like these I’m fascinated by the wrinkles that arise in the interaction between what you want to do and what the technology allows you to do. It’s very different from analog scholarship or art practice, where you have a more complete mastery over the field of play – you have a much more direct and unmediated control over the sound of your words, the shape of a line in a physical sketch, the pressure of a brush stroke. With digital objects, though, you’re building on top of almost unimaginably huge stacks of technology – the millions of man-hours of work that it took to create the vast ecosystem of Javascript and PHP libraries that Neatline depends on, the whole set of lower-level technologies that shape the underlying browser rendering engines and Javascript runtimes, which in turn are implemented in still lower-level languages, which eventually brush up against the dizzying rabbit hole of physical hardware engineering, which to my mind is about as close to magic as anything that people have produced. That kind of deep, massively-distributed collaboration can definitely exist offscreen (eg. , all of intellectual history, in a sense), but it’s more loosely coupled, and certainly less fragile – if I write an essay about Yeats, Yeats can’t break in the way that a code dependency literally can (will). At first this really bothered me, but I’ve come to peace with it – digital work is by definition a relinquishing of control, a give-and-take with the machine, a negotiation with our current little slice of modernity about what’s possible. "
        }, {
        "id": 69,
        "url": "https://neatline.org//2013/10/09/more-fun-with-interactive-typesetting-a-coat-by-yeats/",
        "title": "More fun with interactive typesetting: “A Coat,” by Yeats",
        "body": "2013/10/09 -  [Cross-posted from dclure. org] Click here to view the exhibit. : After spending the weekend tinkering around with an interactive typesetting of a couplet from Macbeth that tried to model reading as a process of zooming downward towards the end of the phrase, I became curious about experimenting with the opposite analogy – reading as an upward movement, an climb from the bottom (the beginning) to the top (the end), with each word circumscribing everything that comes before it. Really, this is just the flip side of the same coin. Meaning certainly flows “downhill” in a phrase – each word is informed by the previous word. But it also flows back “uphill” – each word casts new meaning onto what comes before it. What would it would feel like to visualize that? This time I decided to work with “A Coat,” Yeats’ wonderful little ode to simplicity (he renounces what he thinks to be the stylistic affectation of his work from the 1890’s, and announces an intention to write “naked[ly]“). Originally, I planned to exactly invert the layout of the Macbeth couplet – start with the “I” at the bottom of the stack, and work upwards towards the end with “naked,” which, in the final frame, would geometrically contain each of the preceding words. I started to do this, but quickly ran into an interesting computational obstacle, which actually cropped up in the Shakespeare example as well. Trip Kirkpatrick noticed the problem:    @clured Are jaggies on deepest zoom artifacts results of zoomed pixels or aesthetic decisions? Both?      &mdash; Trip Kirkpatrick (@triplingual) October 7, 2013  Indeed, the last two words – “way” and “comes” – are pixelated and malformed:  This wasn’t on purpose – I couldn’t figure out why it was happening when I was working on the exhibit, but decided against trying to fix it, half out of laziness and half because the visual effect had some satisfying affinities with the content of the line, especially when paired with the “descending” motif – a plunge down to hell, where order disintegrates, smooth lines are forbidden, etc. Anyway – after thinking it over, I’m pretty sure I know what’s going on, although I’m not certain. At the extremely deep zoom levels (far beyond anything you’d ever need for a regular map), I think that OpenLayers is actually losing the floating point precision that it needs to accurately plot the SVG paths for the letters – the computer is running out of decimal places, essentially. I squeaked by with the Macbeth couplet, but this turned out to be a showstopper for the Yeats, since I was effectively trying to plot geometry about four and a half times deeper – 45 words versus 11. At that depth, the text becomes completely illegible, so I had to find a way to squeeze more content into fewer zoom levels. In the end, I managed to fit it all in by positioning each line into a geometric “notch” formed by the ascenders of two letters on the following line, which more or less preserves the philosophical rationale of the exhibit (each bit of text “envelops” the previous, if somewhat less completely than before) while limiting the zooming to just ten magnification contexts, one for each line.  To scan the poem, just zoom out by clicking on the “minus” button (or scrolling the mouse wheel or pinching the screen, if applicable), or click on the lines in the reference text at the top left to auto-focus on a particular part of the poem. "
        }, {
        "id": 70,
        "url": "https://neatline.org//2013/10/07/experimental-typesetting-with-neatline-and-shakespeare/",
        "title": "Experimental typesetting with Neatline and Shakespeare",
        "body": "2013/10/07 -  [Cross-posted from dclure. org] Click here to view the exhibit. : I’ve always been fascinated by the geometric structure of text – the fact that literature is encoded as physical, space-occupying symbols that can be described, measured, and manipulated just like any other two-dimensional shapes. There’s something counter-intuitive about this. When I look at a letter or a word, I see particles of sound and meaning, transcendental cognitive forms, not things that could be straightforwardly described as a chunks of vector geometry. And there’s definitely a truth to this – I do think that texts have a kind of extra-physical cognitive essence that’s independent of their visual instantiations on pages or screens, and that it’s usually this common denominator that’s most interesting when we talk about literature with other people. And yet, in the context of any individual reading, the physical structure of documents – the set of pragmatic decisions that go into the design, layout, and formatting of text on the page – can have subtle but significant effects on how a text feels, on the imaginative dreamscape that surrounds it in your mind when you think back on it days or weeks or years after the fact. This is definitely true, for example, at the level of some-thing like font selection, which encodes a kind of “meaning metadata” about the text – where it comes from, who it’s intended for, how serious it imagines itself to be, etc. But I think it also holds at the level of more incidental, pseudo-random aspects of typesetting. For example, how does the vertical line traced out by the right margin of a paragraph or stanza color the reader’s affective reaction to the literary content? Does a jagged, unjustified border make the text feel more tumultuous and Dionysian? Would the same text, printed with a justified margin, become more emotionally controlled and orderly? I think of cases like Whitman’s long lines, which often have to be prematurely broken at the right edge of the page, resulting in a kind of clumpy, disorganized visual gestalt. I doubt that Whitman intended this, in the strong sense of the word (although I don’t know that he didn’t), but it has a kind of symbolic affinity with the poetry itself – sprawling, organic, uncontainable. When I think of Whitman, the image that appears in my mind consists largely of this. I wonder what it would be like to read an “unbroken” Leaves of Grass, printed on paper wide enough to accommodate the lines? Would it become more metaphysical, detached, ironical? Or would it be just the same? Anyway, this kind of speculation fascinates me. I’ve been thinking a lot recently about experimental modes of digital typesetting that would be completely impossible on the analog page – new ways of presenting text on screens to evoke certain feelings or model intuitions about the structure of language. As a quick experiment, I decided to use Neatline to try to capture a certain aspect of my experience of reading Shakespeare. I’ve always been interested in the notion of language as kind of progressive enveloping of words – they’re printed side-by-side on the page as equals, but the meaning of a syntagm grows out of the ordering of the tokens. Each exists in the context of the last and casts meaning onto the next; each word is contained, in a sense, inside the sum of its predecessors. I was taken by this idea when I read Saussure and company in college, because it seemed to map onto my own experience of reading poetry – the sensation of scanning a line always felt more like a descent than a left-to-right movement, a shift from the surface (the beginning) to the center (the end). To play with this, I built a Neatline exhibit that typesets a single Shakespearean couplet in a kind of recursive, fractal, Prezi-like layout in which each successive word is “physically” embedded inside of one of the letters of the previous word. Reading the couplet literally becomes a matter of magnification, zooming, burrowing downwards towards the end of the syntagm. To scan the fragment, either pan and zoom the environment manually, as you would a regular, Google-like slippy map, or click on the words in the reference text at the bottom of the screen to automatically focus on individual slices of the text. "
        }, {
        "id": 71,
        "url": "https://neatline.org//2013/09/25/neatline-2-1-0/",
        "title": "Neatline 2.1.0",
        "body": "2013/09/25 -  We’re pleased to announce the release of Neatline 2. 1. 0! This is a fairly large maintenance release that adds new features, patches up some minor bugs, and ships some improvements to the UI in the editing environment. Some of the highlights:    A “fullscreen” mode (re-added from the 1. x releases), which makes it possible to link to a page that just displays a Neatline exhibit in isolation, scaled to the size of the screen, without any of the regular Omeka site navigation. Among other things, this makes it much easier to embed a Neatline exhibit as an iframe on other websites (eg, a WordPress blog) – just set the src attribute on the iframe equal to the URL for the fullscreen exhibit view. Eg:   Thanks coryduclos, colonusgroup, and martiniusDE for letting us know that this was a pain point. &lt;/li&gt;          A series of UI improvements to the editing environment that should make the exhibit-creation workflow a bit smoother. We bumped up the size of the “New Record” button, padded out the list of records, and made the “X” buttons used to close record forms a bit larger and easier-to-click. Also, in the record edit form, the “Save” and “Delete” buttons are now stuck into place at the bottom of the panel, meaning that you don’t have to scroll down to the bottom of the form every time you save. Much easier!           Fixes for a handful of small bugs, mostly cosmetic or involving uncommon edge cases. Notably, 2. 1. 0 fixes a problem that was causing item imports to fail when the Omeka installation was using the Amazon S3 storage adapter, as we do for our faculty-project installations here at UVa. &lt;/ul&gt; Check out the release notes on GitHub for the full list of changes, and grab the new code from the Omeka add-ons repository. And, as always, be sure to send comments, concerns, bug reports, and feature requests in our direction.        In other Neatline-related news, be sure to check out Katherine Jentleson’s Neatline-enhanced essay “‘Not as rewarding as the North’: Holger Cahill’s Southern Folk Art Expedition,” which just won the Smithsonian’s Archives of American Art Graduate Research Essay Prize. I met Katherine at a workshop at Duke back in the spring, and it’s been a real pleasure to learn about how she’s using Neatline in her work!  "
        }, {
        "id": 72,
        "url": "https://neatline.org//2013/08/12/displaying-recent-neatline-exhibits-on-your-omeka-home-page/",
        "title": "Displaying Recent Neatline Exhibits on your Omeka Home Page",
        "body": "2013/08/12 -  The charismatic Alex Gil submitted a feature request to Neatline asking to be able to browse Neatline exhibits on your Omeka home page. Turns out you can already specify which page you want as your home page in Omeka 2. 0, so that helped with Alex’s original query. But as we discussed the issue, Alex also wondered about putting a list of recent Neatline exhibits on the home page, much the same way Omeka already does with recent items. While we’re not sure yet about putting this kind of thing in the plugin itself, I mentioned that it’s fairly easy to do in your own them using one of Omeka’s hooks, and promised him a blog post explaining more. Here’s me making good on that promise. In case you didn’t know, Omeka has plenty of ways for developers to add new content to an Omeka site or filter existing content using hooks and filters, respectively. To use them, you first need to write a function that adds or changes content to your preference, then you pass that function to the relevant hook or filter in Omeka. Some dummy code to illustrate: &lt;?phpfunction my_custom_function() { echo 'Hello world!';}add_plugin_hook('hook_name', 'my_custom_function');You could put this kind of code anywhere that Omeka could run it, particularly a new plugin or your activated theme’s custom. php file. (An Omeka theme’s custom. php file is a great place to put some custom code for your Omeka site, without having to go to the trouble of creating and activating a plugin. ) In our case, we want to append some new content to the home page of an Omeka site, so we’ll need to find a hook to let us do that. Fortunately, we have one available—public_home—so let’s use that to display some recent Neatline exhibits. (Keep in mind that the following code should work in Omeka 2. 0 and Neatline 2. 0; you can take a similar approach for earlier versions of each, but some of the functions would be different. ) First, we’ll need to create a custom. php file in your current active theme, if one doesn’t already exist. (If it does exist, we’ll use that one. ) Make sure the file is in the root of your theme: omeka/themes/your-theme/custom. php. Next we’ll need to write a function that gets a certain number of Neatline exhibits and lists them out, and put that in our custom. php file. We’ll name our function display_recent_neatline_exhibits, and put all our goodies in there. Let’s create the function: &lt;?phpfunction display_recent_neatline_exhibits() {}After we’ve created the function, we’ll go ahead and pass that function to the public_home hook: &lt;?phpfunction display_recent_neatline_exhibits() {}add_plugin_hook('public_home', 'display_recent_neatline_exhibits');We still shouldn’t see any changes on the home page, since our function isn’t actually doing anything. But you shouldn’t get any errors on the page either. If you do, make sure you have every curly brace and semicolon and all the other characters right; PHP is quite dramatic about syntax errors. Now lets add some stuff to our function to get some recent Neatline exhibits. First, let’s define a variable $html and set that equal to an empty string. In the end, we’ll echo the value of $html, so we want it equal to at least something, in case you actually don’t have any Neatline exhibits to display. &lt;?phpfunction display_recent_neatline_exhibits() {  $html = '';  echo $html;}add_plugin_hook('public_home', 'display_recent_neatline_exhibits');Next we’ll create a variable, $neatlineExhibits, and assign it to the results of a query using Omeka’s get_records function. The get_records function takes three arguments: the type of record, an array of query parameters, and number to limit results. We’ll query for ‘NeatlineExhibit’ record type, make sure that the recent parameter is true, and limit our results to five: &lt;?phpfunction display_recent_neatline_exhibits() {  $html = '';  // Get our recent Neatline exhibits, limited to five.   $neatlineExhibits = get_records('NeatlineExhibit', array('recent' =&gt; true), 5);  echo $html;}add_plugin_hook('public_home', 'display_recent_neatline_exhibits');Now we’ll set the results in $neatlineExhibits for a record loop, and check to see if in fact we have exhibits to display in a PHP if statement: &lt;?phpfunction display_recent_neatline_exhibits() {  $html = '';  // Get our recent Neatline exhibits, limited to five.   $neatlineExhibits = get_records('NeatlineExhibit', array('recent' =&gt; true), 5);  // Set them for the loop.   set_loop_records('NeatlineExhibit', $neatlineExhibits);   // If we have any to loop, we'll append to $html.   if (has_loop_records('NeatlineExhibit')) {  }  echo $html;}add_plugin_hook('public_home', 'display_recent_neatline_exhibits');Inside our if statement, we’ll update the value of $html so that, instead of echoing an empty string, it echos some HTML that includes links to each of our recent Neatline exhibits. Remember that this will only get printed if we actually have Neatline exhibits in the database, otherwise we’ll just return an empty string. &lt;?phpfunction display_recent_neatline_exhibits() {  $html = '';  // Get our recent Neatline exhibits, limited to five.   $neatlineExhibits = get_records('NeatlineExhibit', array('recent' =&gt; true), 5);  // Set them for the loop.   set_loop_records('NeatlineExhibit', $neatlineExhibits);   // If we have any to loop, we'll append to $html.   if (has_loop_records('NeatlineExhibit')) {    $html . = '&lt;ul&gt;';        foreach (loop('NeatlineExhibit') as $exhibit) {      $html . = '&lt;li&gt;'          . nl_getExhibitLink(             $exhibit,             'show',             metadata($exhibit, 'title'),             array('class' =&gt; 'neatline')           )          . '&lt;/li&gt;';    }    $html . = '&lt;/ul&gt;';  }  echo $html;}add_plugin_hook('public_home', 'display_recent_neatline_exhibits');As you can see, we append an opening unordered list tag, &lt;ul&gt; to $html. (Using . = in PHP lets us append additional strings onto an existing variable. ) Then, we use Omeka’s loop function to loop through our set of Neatline exhibits. Inside that loop, we once again adding something to the value of $html: A list item wrapping a link to a the current Neatline exhibit in the loop. To help us make that link, we’ll use a function provided by the Neatline plugin: nl_getExhibitLink. We’re passing values for four arguments: The exhibit object (defined in $exhibit in the foreach loop); the action or route you want the link to take; the text of the link (here we’ve used Omeka’s metadata function to give us the title of the exhibit); and an array of attributes for the link (we’ve added a class attribute equal to ‘neatline’). Then we end with a closing list item tag. And that should do it. You can see a version more or less the same as what I demonstrate here in a public gist I published earlier in the week. If you’d like to display a recent list of Neatline exhibits on your Omeka home page, just grab this code, and put it in your theme’s custom. php template. "
        }, {
        "id": 73,
        "url": "https://neatline.org//2013/08/07/announcing-neatline-2-0-2/",
        "title": "Announcing Neatline 2.0.2!",
        "body": "2013/08/07 -  Today we’re pleased to announce the release of Neatline 2. 0. 2! This is a maintenance release that adds a couple of minor features and fixes some bugs we’ve rooted up in the last few weeks:    Fixes a bug that was causing item-import queries to fail when certain combinations of other plugins were installed alongside Neatline (thanks Jenifer Bartle and Trip Kirkpatrick for bringing this to our attention).     Makes it possible to toggle the real-time spatial querying on and off for each individual exhibit. This can be useful if you have a small exhibit (eg, 10-20 records) that can be loaded into the browser all at once without causing performance problems, and you want to avoid the added load on the server incurred by the dynamic querying.     Fixes some performance issues with the OpenStreetMap layer in Chrome.  And more! Check out the release notes for the full list of changes, and grab the new code from the Omeka add-ons repository. Also, watch this space for a couple of other Neatline-related releases in the coming weeks. Jeremy and I are working on a series of themes for Omeka specifically designed to display Neatline projects, including the NeatLight theme, which is currently used on the Neatline Labs site I’ve started playing around with (still a work in progress). We’re also just about ready to cut off a public release of the NeatlineText plugin, which makes it possible to connect records in Neatline exhibits to individual sections, paragraphs, sentences, and words in text documents (check out this example). Until then, give the new code a spin, and let us know what you think! "
        }, {
        "id": 74,
        "url": "https://neatline.org//2013/07/09/announcing-neatline-2-0-0-a-stable-production-ready-release/",
        "title": "Announcing Neatline 2.0.0! A stable, production-ready release",
        "body": "2013/07/09 -  [Cross-posted from dclure. org] It’s finished! Today we’re excited to announce Neatline 2. 0. 0, a stable, production-ready release of the new codebase that can be used to upgrade existing installations. If you’re starting fresh with a new project, just download the new version and install it like any other Omeka plugin. If you’re upgrading from Neatline 1. x, be sure to read through the 2. 0 migration guide before getting started (most important – the 2. 0 migration runs as a “background process,” which means that there could be a 10-20 second lag before your old exhibits are visible under the “Neatline” tab). Then, if you want to use the SIMILE Timeline widget and item-browser panel that were built into the first version of Neatline, download NeatlineSimile and NeatlineWaypoints, the two new sub-plugins that integrate those features seamlessly into the Neatline core. For more information, check out the (all new!) documentation, which walks through the installation process in detail.       Download the plugins: Neatline   NeatlineWaypoints   NeatlineSimile   Neatline 2. 0 is a major update that significantly expands the scope of the project. Building on the core set of geospatial annotation tools from the first version, we’ve turned Neatline into a general-purpose visual annotation framework that can be used to create interactive displays of almost any type of two-dimensional material – maps, paintings, drawings, photographs, documents, and anything else that can be captured as an image. We’ve also made a series of changes to the user interface and code architecture that are designed to make Neatline more accessible for new users (college undergraduates working on class assignments) and, at the same time, more flexible for advanced users (professional scholars, journalists, and digital artists who want to use Neatline for complex projects). Some of the highlights:    Improved performance and scalability, powered by a real-time spatial querying system that makes it possible to work with really large collections of records – as many as about 1,000,000 in a single exhibit;     A more sophisticated set of drawing tools, including the ability to import high-fidelity SVG documents created in programs like Adobe Illustrator or Inkscape and interactively drag them into position as geometry in Neatline exhibits;     An interactive, CSS-like stylesheet system, build directly into the editing environment, that makes it possible to quickly perform bulk updates on large collections of records using a simplified dialect of CSS;     A flexible user-permissions system, designed to make it easier to use Neatline for class assignments and workshops, that makes it possible to prevent users from modifying or deleting content they didn’t create;     Expanded support for non-spatial base layers that makes it possible to build exhibits on top of any web-accessible static image or non-spatial WMS layer – paintings, drawings, photographs, documents, etc.     A more powerful theming system, which makes it possible for designers to completely customize the appearance and interactivity of each individual Neatline exhibit. This makes it possible to host completely independent and thematically-distinct projects inside a single installation of Omeka.     A total rewrite of the front-end JavaScript applications (both the editing environment and the public-facing exhibit views) that provides a more minimalistic and responsive environment for creating and viewing exhibits;     A new programming API and “sub-plugin” system that makes it possible for developers to add custom functionality for specific projects – everything from simple user-interface widgets (sliders, legends, scrollers, forward-and-backward buttons, etc. ) up to really extensive modifications that expand the core data model and add totally new interactions.  And much more! Over the course of the next week, leading up to our panel about Neatline at the DH 2013 conference in Lincoln, Nebraska (“Circular Development: Neatline and the User/Developer Feedback Loop,” Wednesday at 10:30), we’re going to be fleshing out the new documentation and building a set of Neatline-2. 0-powered projects designed to put the new feature set through its paces. Also, watch this space later in the week for another code release – we’ve built an extension called NeatlineTexts that connects Neatline exhibits with word-level annotations in long-format documents, which makes it possible to use Neatline as a publication platform for essays, blog posts, scholarly articles, monographs, etc. , and built a special Omeka that’s specifically designed to frame these interactive editions. Until then – grab the new code, give it spin, and let us know what you think! "
        }, {
        "id": 75,
        "url": "https://neatline.org//2013/05/28/neatline-1-1-3-maintenance-release/",
        "title": "Neatline 1.1.3 Maintenance Release",
        "body": "2013/05/28 - This morning, Kiyonori Nagasaki noticed that one of the remote API’s used by the Neatline 1. x releases went offline, which had the effect of breaking exhibits that included the SIMILE Timeline widget. To fix this, we just posted a 1. 1. 3 maintenance release that patches up the timeline problem and also includes a couple of other improvements:    Disabled animated opacity transitions on WMS tiles, which were causing performance problems in recent builds of Chrome;     Fixed a bug that was causing the map not to focus correctly when a record is selected that has a default focus position/zoom, but no vector geometry.  Download Neatline 1. 1. 3. Meanwhile, lots of activity on the Neatline 2. 0 front – we’re almost done with a second alpha release, which gets us one step closer to a stable 2. 0 release, which will include the migration to update existing installations from the 1. x series. Stay posted! "
        }, {
        "id": 76,
        "url": "https://neatline.org//2013/05/28/interactive-css-in-neatline-2-0/",
        "title": "Interactive CSS in Neatline 2.0",
        "body": "2013/05/28 - [Cross-posted with dclure. org] Neatline 2. 0 makes it possible to work with really large collections of records – as many as about 1,000,000 in a single exhibit. This level of scalability opens up the door to a whole range of projects that would have been impossible with the first version of Neatline, but it also introduces some really interesting content management challenges. If the map can display millions of records, it also needs utilities to effectively manage content at that scale. This often involves a shift from working with individual records to working with groups of records. When there are a million records on the map, it’s pretty unlikely that you’ll want to change the color of just one of them. More likely, that record will exist as part of a large grouping of related records (eg, “democratic precincts,” or “photographs from 1945″), all of which should share a certain set of attributes. There needs to be a way to slice and dice records into overlapping clusters of related records, and then apply bulk updates to the individual clusters. Really, this is a familiar problem – it’s structurally identical to the task of styling web pages with CSS, which makes it possible to address groupings of elements with “selectors” and apply key-value styling rules to the groups. Inspired by projects like Mike Migurski’s Cascadenick, Neatline 2. 0 makes it possible to use a Neatline-inflected dialect of CSS to update groups of records linked together with “tags,” which can be applied in any combination to the individual records. Neatline Stylesheet Basics Let’s take a look at how this works in practice. Imagine you’re plotting results from the last four presidential elections. You load in a big collection of 800,000 records (200,000 precincts for each of the four elections), each representing an individual polling place with a point on the map. Each point is scaled to represent the number of ballots cast at that location, and shared red or blue according to which party won more votes. In this case, there are really seven different nested and overlapping taxonomies in the data. All of the records are precincts, but each falls into one of the our election seasons – 2000, 2004, 2008, or 2012. And each precinct went either democrat or republican, regardless of which election cycle it belongs to. Each record can be tagged with some combination of these tags: Each of the groupings needs to share a specific set of attributes – and also not share some attributes that need to be assigned separate values on individual records. For example, all of the precincts – regardless of date or party – should share the same basic fill-opacity and stroke-width styles. All records in each of the groupings for the four election seasons need to share the same after-date and before-date visibility settings so that the records phase in and out of visibility in unison. And all republican and democratic records should share the same shares of red and blue. Meanwhile, none of the groupings should define a standard point-radius style, which is used on a per-record basis to encode the number of ballots cast at that location. Neatline-inflected CSS makes it easy to model these relationships. To start, I’ll define some basic styles for the top-level precinct tag, which is applied to all the records in the exhibit: Now, when I click “Save,” Neatline instantaneously updates the stroke-width and fill-opacity styles on all records tagged with precinct: Next, I’ll set the before-date and after-date properties for each of the for election season tags, which ensure that the four batches of records phase in and out of visibility in unison as the timeline is scrolled back and forth: Now, when I open up any individual record, the before-date and after-date fields will be updated with new values depending on which election the record belongs to: Last, I’ll define the coloring rules for the two political parties. First, the Democrats: Click “Save,” and all democratic precincts update with the new color: Auto-updating stylesheet values So far, we’ve just been entering hard-coded values into the stylesheet. This often makes sense for properties that have inherently semantic values (eg, dates). For other attributes, though (namely colors), it’s much harder to reason in the abstract about what value you want. For example, I know that I want the republican precincts to be “red,” but I don’t know off-hand that #ff0000 is the specific hexadecimal value that I want to use. It makes more sense to open up the edit form for an individual record and use the color pickers for the “Fill Color” field to find a color that looks good. And even for styles that can be reasoned about in the abstract, it’s often easier and more intuitive to use the auto-previewing functionality on one of the record forms to tinker around with different values. Once you’ve decided on a new setting, though, it’s annoying to have to manually propagate the value back into the stylesheets so that all of the record’s siblings stay in sync – you’d have to copy the value, close the form, open up the stylesheet, find the right rule, and paste in the new value. To avoid this, Neatline also automatically updates the stylesheet when individual record values are changed, and immediately pushes out the new value to all of the record’s siblings. Let’s go back to the election results. For the republican precincts, instead of pasting in a specific hex value for the fill-color style, we’ll just “register” fill-color as being one of the properties controlled by the republican tag by listing the style and assigning it a value of auto: When I click “Save,” nothing happens, since a value isn’t defined. Now, though, I can just open up any of the individual republican records, choose a shade of red, and save the record. Since we activated the fill-color style for the republican tag, Neatline automatically updates all of the other republican records just as if we had set the value directly on the stylesheet: And now, when I go back to the stylesheet, the fill-color rule under republican is automatically updated with the value that we just set in the record form: This also works for styles that already have concrete values. For example, say I change my mind and want to tweak the shade of blue used for democratic precincts. I can just open up any of the individual democrat-tagged records, pick a new value with the color picker, and save the record. Again, Neatline automatically replaces the old value on the stylesheet and propagates the change to all of the other democratic precincts. "
        }, {
        "id": 77,
        "url": "https://neatline.org//2013/05/28/announcing-neatline-2-0-alpha2/",
        "title": "Announcing Neatline 2.0-alpha2!",
        "body": "2013/05/28 - [Cross-posted with dclure. org] We’re pleased to announce Neatline 2. 0-alpha2, a second developer-preview version that gets us one step closer to a stable 2. 0 release! For now, this is still just an testing release aimed at engineers and other folks who want to experiment with the new set of features (for more information, check out the announcement for the first testing release). Grab the code here:       **Neatline-2. 0-alpha2   NeatlineWaypoints-2. 0-alpha2   NeatlineSimile-2. 0-alpha2**   This revision fixes a couple of bugs and adds two new features that didn’t make it into the first preview release:    A user-privileges system, which makes Neatline much easier to use in collaborative, multi-user settings like classrooms and workshops. In a lot of ways, this feature reflects an expanded focus for Neatline. During the first cycle of development last year, we were mainly focused on building a tool designed for individual scholars and students working on focused projects. In that setting – when just a handful of trusted collaborators are working on a project – it’s often not necessary to assign “ownership” to individual pieces of content to protect them from being changed or deleted by other users. &lt;/p&gt; Over the course of the last year, though, we’ve realized that there’s a lot of interest in using Neatline in a classroom setting, which introduces a new set of requirements. When 50 students are all building their own Neatline exhibits inside a single installation of Omeka, it would be easy for someone to accidentally edit or delete someone else’s work – there need to be guard rails to prevent users from modifying content that doesn’t belong to them.   In Neatline 2. 0-alpha2, we’ve added an ACL (access control list) that makes it possible to enforce a three-level user privileges system:          Admin and Super users can do everything – they can create, edit, and delete all Neatline exhibits and records, regardless of who they were originally created by.           Contributor users can add, edit, and delete their own exhibits, but can’t make changes to exhibits or records that they didn’t create.           Researcher users are denied all Neatline-related privileges – they can’t create, edit, or delete any Neatline exhibits or records.        This is a simple approach, but we think it addresses most of the basic patterns for classroom use that we’ve encountered here at UVa and elsewhere. If students are working on individual projects, each can be given a separate “Contributor” account, which allows them to create and update their own exhibits, but blocks them from changing anyone else’s work. If students are working together in groups, each group can be assigned an individual “Contributor” account, which allows group members to update each other’s work, but prevents them from making changes other groups’ exhibits. &lt;/li&gt;          An exhibit-specific theming system that makes it possible to create completely custom “sub-themes” for individual Neatline exhibits. Before, it was possible to customize the layout and styling of the Neatline exhibit views by editing the Omeka theme, which would change the appearance of all the exhibits on the site. In many cases, though, individual exhibits have specific requirements. Depending on the content, it might be useful for different exhibits to have different page headers, typography, or viewport layouts; and it’s also really useful to be able to load exhibit-specific JavaScript files, which can be used to define custom interactions for individual exhibits. &lt;/p&gt; In this release, every aspect of an exhibit’s public view can be completely customized by adding an “exhibit theme” that sits inside of the regular Omeka theme. For example, if I have an exhibit called “Testing Exhibit” with a URL slug of testing-exhibit, I can define a custom theme for the exhibit by adding a directory in the public theme at neatline/exhibits/themes/testing-exhibit. With the directory in place, Neatline will automatically load any combination of custom assets:                If a template. php file is present in the directory, it will be used as the view template for the exhibit in place of the default show. php template that ships with Neatline.                 All . js and . css files in the directory will be loaded in the public view. This makes it possible to break additional styling and JavaScript functionality across multiple files, which makes it easier to break complex customizations into smaller units.              This gives the theme developer full control over the appearance and behavior of each individual exhibit, making it possible to build a extremely diverse collection of Neatline projects inside a single installation of Omeka. &lt;/ol&gt;        Check out the change log for more details. And let us know what you think!  "
        }, {
        "id": 78,
        "url": "https://neatline.org//2013/05/28/announcing-neatline-2-0-alpha2-2/",
        "title": "Announcing Neatline 2.0-alpha2!",
        "body": "2013/05/28 -  [Cross-posted with dclure. org] We’re pleased to announce Neatline 2. 0-alpha2, a second developer-preview version that gets us one step closer to a stable 2. 0 release! For now, this is still just an testing release aimed at engineers and other folks who want to experiment with the new set of features (for more information, check out the announcement for the first testing release). Grab the code here:       **Neatline-2. 0-alpha2   NeatlineWaypoints-2. 0-alpha2   NeatlineSimile-2. 0-alpha2**   This revision fixes a couple of bugs and adds two new features that didn’t make it into the first preview release:    A user-privileges system, which makes Neatline much easier to use in collaborative, multi-user settings like classrooms and workshops. In a lot of ways, this feature reflects an expanded focus for Neatline. During the first cycle of development last year, we were mainly focused on building a tool designed for individual scholars and students working on focused projects. In that setting – when just a handful of trusted collaborators are working on a project – it’s often not necessary to assign “ownership” to individual pieces of content to protect them from being changed or deleted by other users. &lt;/p&gt; Over the course of the last year, though, we’ve realized that there’s a lot of interest in using Neatline in a classroom setting, which introduces a new set of requirements. When 50 students are all building their own Neatline exhibits inside a single installation of Omeka, it would be easy for someone to accidentally edit or delete someone else’s work – there need to be guard rails to prevent users from modifying content that doesn’t belong to them.   In Neatline 2. 0-alpha2, we’ve added an ACL (access control list) that makes it possible to enforce a three-level user privileges system:          Admin and Super users can do everything – they can create, edit, and delete all Neatline exhibits and records, regardless of who they were originally created by.           Contributor users can add, edit, and delete their own exhibits, but can’t make changes to exhibits or records that they didn’t create.           Researcher users are denied all Neatline-related privileges – they can’t create, edit, or delete any Neatline exhibits or records.        This is a simple approach, but we think it addresses most of the basic patterns for classroom use that we’ve encountered here at UVa and elsewhere. If students are working on individual projects, each can be given a separate “Contributor” account, which allows them to create and update their own exhibits, but blocks them from changing anyone else’s work. If students are working together in groups, each group can be assigned an individual “Contributor” account, which allows group members to update each other’s work, but prevents them from making changes other groups’ exhibits. &lt;/li&gt;          An exhibit-specific theming system that makes it possible to create completely custom “sub-themes” for individual Neatline exhibits. Before, it was possible to customize the layout and styling of the Neatline exhibit views by editing the Omeka theme, which would change the appearance of all the exhibits on the site. In many cases, though, individual exhibits have specific requirements. Depending on the content, it might be useful for different exhibits to have different page headers, typography, or viewport layouts; and it’s also really useful to be able to load exhibit-specific JavaScript files, which can be used to define custom interactions for individual exhibits. &lt;/p&gt; In this release, every aspect of an exhibit’s public view can be completely customized by adding an “exhibit theme” that sits inside of the regular Omeka theme. For example, if I have an exhibit called “Testing Exhibit” with a URL slug of testing-exhibit, I can define a custom theme for the exhibit by adding a directory in the public theme at neatline/exhibits/themes/testing-exhibit. With the directory in place, Neatline will automatically load any combination of custom assets:                If a template. php file is present in the directory, it will be used as the view template for the exhibit in place of the default show. php template that ships with Neatline.                 All . js and . css files in the directory will be loaded in the public view. This makes it possible to break additional styling and JavaScript functionality across multiple files, which makes it easier to break complex customizations into smaller units.              This gives the theme developer full control over the appearance and behavior of each individual exhibit, making it possible to build a extremely diverse collection of Neatline projects inside a single installation of Omeka. &lt;/ol&gt;        Check out the change log for more details. And let us know what you think!  "
        }, {
        "id": 79,
        "url": "https://neatline.org//2013/05/16/neatline-1-1-3-maintenance-release-2/",
        "title": "Neatline 1.1.3 Maintenance Release",
        "body": "2013/05/16 -  This morning, Kiyonori Nagasaki noticed that one of the remote API’s used by the Neatline 1. x releases went offline, which had the effect of breaking exhibits that included the SIMILE Timeline widget. To fix this, we just posted a 1. 1. 3 maintenance release that patches up the timeline problem and also includes a couple of other improvements:    Disabled animated opacity transitions on WMS tiles, which were causing performance problems in recent builds of Chrome;     Fixed a bug that was causing the map not to focus correctly when a record is selected that has a default focus position/zoom, but no vector geometry.  Download Neatline 1. 1. 3. Meanwhile, lots of activity on the Neatline 2. 0 front – we’re almost done with a second alpha release, which gets us one step closer to a stable 2. 0 release, which will include the migration to update existing installations from the 1. x series. Stay posted! "
        }, {
        "id": 80,
        "url": "https://neatline.org//2013/05/14/interactive-css-in-neatline-2-0-2/",
        "title": "Interactive CSS in Neatline 2.0",
        "body": "2013/05/14 -  [Cross-posted with dclure. org] Neatline 2. 0 makes it possible to work with really large collections of records – as many as about 1,000,000 in a single exhibit. This level of scalability opens up the door to a whole range of projects that would have been impossible with the first version of Neatline, but it also introduces some really interesting content management challenges. If the map can display millions of records, it also needs utilities to effectively manage content at that scale. This often involves a shift from working with individual records to working with groups of records. When there are a million records on the map, it’s pretty unlikely that you’ll want to change the color of just one of them. More likely, that record will exist as part of a large grouping of related records (eg, “democratic precincts,” or “photographs from 1945″), all of which should share a certain set of attributes. There needs to be a way to slice and dice records into overlapping clusters of related records, and then apply bulk updates to the individual clusters. Really, this is a familiar problem – it’s structurally identical to the task of styling web pages with CSS, which makes it possible to address groupings of elements with “selectors” and apply key-value styling rules to the groups. Inspired by projects like Mike Migurski’s Cascadenick, Neatline 2. 0 makes it possible to use a Neatline-inflected dialect of CSS to update groups of records linked together with “tags,” which can be applied in any combination to the individual records. Neatline Stylesheet Basics Let’s take a look at how this works in practice. Imagine you’re plotting results from the last four presidential elections. You load in a big collection of 800,000 records (200,000 precincts for each of the four elections), each representing an individual polling place with a point on the map. Each point is scaled to represent the number of ballots cast at that location, and shared red or blue according to which party won more votes. In this case, there are really seven different nested and overlapping taxonomies in the data. All of the records are precincts, but each falls into one of the our election seasons – 2000, 2004, 2008, or 2012. And each precinct went either democrat or republican, regardless of which election cycle it belongs to. Each record can be tagged with some combination of these tags: Each of the groupings needs to share a specific set of attributes – and also not share some attributes that need to be assigned separate values on individual records. For example, all of the precincts – regardless of date or party – should share the same basic fill-opacity and stroke-width styles. All records in each of the groupings for the four election seasons need to share the same after-date and before-date visibility settings so that the records phase in and out of visibility in unison. And all republican and democratic records should share the same shares of red and blue. Meanwhile, none of the groupings should define a standard point-radius style, which is used on a per-record basis to encode the number of ballots cast at that location. Neatline-inflected CSS makes it easy to model these relationships. To start, I’ll define some basic styles for the top-level precinct tag, which is applied to all the records in the exhibit: Now, when I click “Save,” Neatline instantaneously updates the stroke-width and fill-opacity styles on all records tagged with precinct: Next, I’ll set the before-date and after-date properties for each of the for election season tags, which ensure that the four batches of records phase in and out of visibility in unison as the timeline is scrolled back and forth: Now, when I open up any individual record, the before-date and after-date fields will be updated with new values depending on which election the record belongs to: Last, I’ll define the coloring rules for the two political parties. First, the Democrats: Click “Save,” and all democratic precincts update with the new color: Auto-updating stylesheet values So far, we’ve just been entering hard-coded values into the stylesheet. This often makes sense for properties that have inherently semantic values (eg, dates). For other attributes, though (namely colors), it’s much harder to reason in the abstract about what value you want. For example, I know that I want the republican precincts to be “red,” but I don’t know off-hand that #ff0000 is the specific hexadecimal value that I want to use. It makes more sense to open up the edit form for an individual record and use the color pickers for the “Fill Color” field to find a color that looks good. And even for styles that can be reasoned about in the abstract, it’s often easier and more intuitive to use the auto-previewing functionality on one of the record forms to tinker around with different values. Once you’ve decided on a new setting, though, it’s annoying to have to manually propagate the value back into the stylesheets so that all of the record’s siblings stay in sync – you’d have to copy the value, close the form, open up the stylesheet, find the right rule, and paste in the new value. To avoid this, Neatline also automatically updates the stylesheet when individual record values are changed, and immediately pushes out the new value to all of the record’s siblings. Let’s go back to the election results. For the republican precincts, instead of pasting in a specific hex value for the fill-color style, we’ll just “register” fill-color as being one of the properties controlled by the republican tag by listing the style and assigning it a value of auto: When I click “Save,” nothing happens, since a value isn’t defined. Now, though, I can just open up any of the individual republican records, choose a shade of red, and save the record. Since we activated the fill-color style for the republican tag, Neatline automatically updates all of the other republican records just as if we had set the value directly on the stylesheet: And now, when I go back to the stylesheet, the fill-color rule under republican is automatically updated with the value that we just set in the record form: This also works for styles that already have concrete values. For example, say I change my mind and want to tweak the shade of blue used for democratic precincts. I can just open up any of the individual democrat-tagged records, pick a new value with the color picker, and save the record. Again, Neatline automatically replaces the old value on the stylesheet and propagates the change to all of the other democratic precincts. "
        }, {
        "id": 81,
        "url": "https://neatline.org//2013/05/13/announcing-neatline-2-0-alpha1-2/",
        "title": "Announcing Neatline 2.0-alpha1!",
        "body": "2013/05/13 -  [Cross-posted with dclure. org] It’s here! After much hard work, we’re delighted to announce the first alpha release of Neatline 2. 0, which migrates the codebase to Omeka 2. 0 and adds lots of exciting new things. For now, this is just an initial testing release aimed at developers and other brave folks who want to tinker around with the new set of features and help us work out the kinks. Notably, this build doesn’t yet include the migration to upgrade existing exhibits from the 1. 1. x series, which we’ll ship with the first stable release in the next couple weeks once we’ve had a chance to field test the new code. 45 minutes of Neatline 2. 0 alpha testing, compressed to 90 seconds, set to Chopin. In the interest of modularity (more on this later), the set of features that was bundled together in the original version of Neatline has been split into three separate plugins:  Neatline – The core map-making toolkit and content management system.  NeatlineWaypoints – A list of sortable waypoints, the new version of the vertical “Item Browser” panel from the 1. x series.  NeatlineSimile – The SIMILE Timeline widget. Just unpack the . zip archives, copy the folders into the /plugins directory in your Omeka 2. x installation, and install the plugins in the Omeka admin. For more detailed information, head over to the Neatline 2. 0-alpha1 Installation Wiki, and take a look at the change log for a more complete list of changes and additions. We’re really excited about this code. Since releasing the first version last summer, we’ve gotten a huge amount of incredibly helpful feedback from users, much of which has been directly incorporated into the new release. We’ve also added a carefully-selected set of new features that opens up the door to some really interesting new approaches to geospatial (and completely non-geospatial) annotation. It’s a leaner, faster, more focused, more reliable, and generally more capable piece of software – we’re excited to start building projects with it! Some of the additions and changes:    Real-time spatial querying, which makes it possible to create really large exhibits – as many as about 1,000,000 records on a single map;     A total rewrite of the front-end application in Backbone. js and Marionette that provides a more minimal, streamlined, and responsive environment for creating and publishing exhibits;     An interactive “stylesheet” system (inspired by projects like Mike Migurski’s Cascadenick), that makes it possible to use a dialect of CSS – built directly into the editing environment – to synchronize large batches of records;     The ability to import high-fidelity SVG illustrations created in specialized vector editing tools like Adobe Illustrator and Inkscape;     The ability to add custom base layers, which, among other things, makes it possible to annotate completely non-spatial entities – paintings, photographs, documents, and anything else that can be captured as an image;     A revamped import-from-Omeka workflow that makes it easier to link Neatline records to Omeka items and batch-import large collections of items;     A flexible programming API and “sub-plugin” system that makes it easy for developers to extend the core feature set with custom functionality for specific projects – everything from simple JavaScript widgets (legends, sliders, scrollers, etc. ) up to really deep modifications that extend the core data model and add completely new interactions.  Over the course of the next two weeks, I’ll be writing in much more detail about some of the new features. In the meantime – let us know what you think! We’re going to be pushing out a series of alpha releases in pretty rapid succession over the course of the next couple weeks, and we’re really keen to get feedback about the new features before cutting off a stable 2. 0 release. If you find a bug, or think of a feature that you’d like to see included, be sure to file a report on the issue tracker. "
        }, {
        "id": 82,
        "url": "https://neatline.org//2013/03/01/restarting-marionette-applications/",
        "title": "Restarting Marionette applications",
        "body": "2013/03/01 -  [Cross-posted from dclure. org] Over the course of the last couple months, I’ve been using Derick Bailey’s superb Marionette framework for Backbone. js to build the new version of Neatline. Marionette sits somewhere in the hazy zone between a library and a framework – it’s really a collection of architectural components for large front-end applications that can be composed in lots of different ways. I use Marionette mainly for the core set of message-passing utilities, which make it easy to define interactions among different parts of big applications – pub-sub event channels, command execution, request-response patterns, etc. I’ve come to completely rely on these structures, and can’t really imagine writing non-trivial applications without them anymore. The only big kink I’ve encountered is in the Jasmine suite. Since almost all of the integration-level test cases mutate the state of the application (trigger routes, open/close views, etc. ), I needed to completely burn down the app and re-start it from scratch at the beginning of each test to ensure a clean slate. The top-level Marionette Application has a start method that walks down the tree of modules and runs the initializers. As it exists now, though, start can only be called once during the lifecycle of the application, and does nothing if it’s called again later on. I was getting around this by defining independently-callable init methods for all of my modules and wiring them up to the regular Marionette start-up system: But then manually calling all of the init methods in my Jasmine start-up routine to force-restart the application: This is icky – I have to exactly recreate a specific start-up order that’s automatically enforced in the application itself by before: and after: initialization events. And it introduces lots of opportunities for false-negatives – if you add a module, and forget to explicitly start it in the test suite, everything falls apart. Really, I wanted to just re-call Neatline. start() before every test. I realized tonight, though, that the application object can be tricked into restarting itself by (a) stopping all of the modules and (b) resetting the top-level Callbacks on the application: Much cleaner. Assuming all state-bearing components are instantiated in the initializers, this has the desired effect of completely rebooting the application. I’d imagine this is a pretty common issue – is there any philosophical reason for the prohibition against re-calling Application. start() more than once? "
        }, {
        "id": 83,
        "url": "https://neatline.org//2013/02/26/neatline-and-omeka-2-0-2/",
        "title": "Neatline and Omeka 2.0",
        "body": "2013/02/26 -  [Cross-posted with dclure. org] We’ve been getting a lot of questions about when Neatline plugins will be ready for the newly-released Omeka 2. 0. The answer is – very soon! In addition to migrating all of the plugins (Neatline, Neatline Time, Neatline Maps, Neatline Features) over to the new version of Omeka, we’re also using this transition to roll out a major evolution of the Neatline feature-set that incorporates lots of feedback from the first version. Some of the new, Omeka-2. 0-powered things on tap:    Real-time spatial querying on the map, which makes it possible to work with really large collections of data (as many as 1,000,000 records in a single exhibit);     The ability to import SVG documents from vector-editing programs like Adobe Illustrator, making it possible to render complex illustrations on the map;     A portable stylesheet system that allows exhibit-builders to use a CSS-like syntax to apply bulk updates to large collections of records;     An improved workflow for displaying Omeka items in Neatline exhibits – mix and match individual Dublin Core fields, entire metadata records, images, and other item attributes;     A flexible workflow for adding custom base layers in exhibits, which makes it possible to use Neatline to annotate non-spatial materials: paintings, drawings, abstract maps, and anything else that can be captured as an image.     A new set of hooks and filters – both on the server and in the browser – that make it easy to for developers to write modular add-ons and customizations for Neatline exhibits – legends, sliders, record display formats, integrations with long-format texts, etc.  The new version is just about feature-complete, and we’re now in the process of tying up loose ends and writing the migration code to upgrade projects built on the 1. 1. x releases. We’re on schedule for a public beta by the end of March, and a full release by the end of the semester. Going forward, we’ll continue supporting the Omeka 1. 5. x-compatible releases of Neatline from a maintenance standpoint, but we’re moving all new development efforts into the new versions of the plugins, which only work with Omeka 2. 0. As the final pieces fall into place over the course of the next couple weeks, we’ll start posting a series of alpha releases for developers and other folks who want to test-drive the new feature set. Between now and then, check out some of the feature-preview articles we’ve posted in the last couple weeks: Neatline Feature Preview – 1,000,000 records in an exhibitNeatline Feature Preview – Importing SVG documents from Adobe Illustrator &lt;/ul&gt; And watch this space for ongoing weekly updates! "
        }, {
        "id": 84,
        "url": "https://neatline.org//2013/02/18/svg-to-wkt-converting-vector-graphics-into-spatial-coordinates/",
        "title": "SVG-to-WKT: Converting vector graphics into spatial coordinates",
        "body": "2013/02/18 - [Cross-posted with dclure. org] Last week, I wrote about the some of the new functionality in Neatline that makes it possible to take SVG documents created in vector-editing programs like Adobe Illustrator and drag them out as spatial geometry on the map. Under the hood, this involves converting the raw SVG markup – which encodes geometry relative to a “document” space (think of pixels in a Photoshop file) – into latitude/longitude coordinates that can be rendered dynamically on the map. Specifically, I needed to generate Well-Known Text (WKT), the serialization format used by spatially-enabled relational databases like PostGIS and MySQL. It turned out that there wasn’t any pre-existing utility for this, so I wrote a little library called SVG-to-WKT that does the conversion. The top-level convert method takes a raw SVG document and spits back the equivalent WKT GEOMETRYCOLLECTION: SVGtoWKT. convert('&lt;svg&gt;&lt;polygon points= 1,2 3,4 5,6  /&gt;&lt;line x1= 7  y1= 8  x2= 9  y2= 10  /&gt;&lt;/svg&gt;');&gt;&gt;&gt;  GEOMETRYCOLLECTION(POLYGON((1 -2,3 -4,5 -6,1 -2)),LINESTRING(7 -8,9 -10)) The library supports all SVG elements that directly encode geometry information, and exposes the individual helper methods that handle each of the elements: line SVGtoWKT. line(1, 2, 3, 4);&gt;&gt;&gt;  LINESTRING(1 -2,3 -4) polyline SVGtoWKT. polyline('1,2 3,4');&gt;&gt;&gt;  LINESTRING(1 -2,3 -4) polygon SVGtoWKT. polygon('1,2 3,4');&gt;&gt;&gt;  POLYGON((1 -2,3 -4,1 -2)) rect SVGtoWKT. rect(1, 2, 3, 4);&gt;&gt;&gt;  POLYGON((1 -2,4 -2,4 -6,1 -6,1 -2)) circle SVGtoWKT. circle(0, 0, 10);&gt;&gt;&gt;  POLYGON((10 0,9. 95 -0. 996,9. 802 -1. 981,9. 556 -2. 948,9. 215 -3. 884,8. 782 -4. 783,8. 262 -5. 633,7. 66 -6. 428,6. 982 -7. 159,6. 235 -7. 818,5. 425 -8. 4,4. 562 -8. 899,3. 653 -9. 309,2. 708 -9. 626,1. 736 -9. 848,0. 747 -9. 972,-0. 249 -9. 997,-1. 243 -9. 922,-2. 225 -9. 749,-3. 185 -9. 479,-4. 113 -9. 115,-5 -8. 66,-5. 837 -8. 119,-6. 617 -7. 498,-7. 331 -6. 802,-7. 971 -6. 038,-8. 533 -5. 214,-9. 01 -4. 339,-9. 397 -3. 42,-9. 691 -2. 468,-9. 888 -1. 49,-9. 988 -0. 498,-9. 988 0. 498,-9. 888 1. 49,-9. 691 2. 468,-9. 397 3. 42,-9. 01 4. 339,-8. 533 5. 214,-7. 971 6. 038,-7. 331 6. 802,-6. 617 7. 498,-5. 837 8. 119,-5 8. 66,-4. 113 9. 115,-3. 185 9. 479,-2. 225 9. 749,-1. 243 9. 922,-0. 249 9. 997,0. 747 9. 972,1. 736 9. 848,2. 708 9. 626,3. 653 9. 309,4. 562 8. 899,5. 425 8. 4,6. 235 7. 818,6. 982 7. 159,7. 66 6. 428,8. 262 5. 633,8. 782 4. 783,9. 215 3. 884,9. 556 2. 948,9. 802 1. 981,9. 95 0. 996,10 0)) ellipse SVGtoWKT. ellipse(0, 0, 10, 20);&gt;&gt;&gt;  POLYGON((10 0,9. 98 -1. 268,9. 92 -2. 532,9. 819 -3. 785,9. 679 -5. 023,9. 501 -6. 241,9. 284 -7. 433,9. 029 -8. 596,8. 738 -9. 724,8. 413 -10. 813,8. 053 -11. 858,7. 66 -12. 856,7. 237 -13. 802,6. 785 -14. 692,6. 306 -15. 523,5. 801 -16. 292,5. 272 -16. 995,4. 723 -17. 629,4. 154 -18. 193,3. 569 -18. 683,2. 969 -19. 098,2. 358 -19. 436,1. 736 -19. 696,1. 108 -19. 877,0. 476 -19. 977,-0. 159 -19. 997,-0. 792 -19. 937,-1. 423 -19. 796,-2. 048 -19. 576,-2. 665 -19. 277,-3. 271 -18. 9,-3. 863 -18. 447,-4. 441 -17. 92,-5 -17. 321,-5. 539 -16. 651,-6. 056 -15. 915,-6. 549 -15. 115,-7. 015 -14. 254,-7. 453 -13. 335,-7. 861 -12. 363,-8. 237 -11. 341,-8. 58 -10. 274,-8. 888 -9. 165,-9. 161 -8. 019,-9. 397 -6. 84,-9. 595 -5. 635,-9. 754 -4. 406,-9. 874 -3. 16,-9. 955 -1. 901,-9. 995 -0. 635,-9. 995 0. 635,-9. 955 1. 901,-9. 874 3. 16,-9. 754 4. 406,-9. 595 5. 635,-9. 397 6. 84,-9. 161 8. 019,-8. 888 9. 165,-8. 58 10. 274,-8. 237 11. 341,-7. 861 12. 363,-7. 453 13. 335,-7. 015 14. 254,-6. 549 15. 115,-6. 056 15. 915,-5. 539 16. 651,-5 17. 321,-4. 441 17. 92,-3. 863 18. 447,-3. 271 18. 9,-2. 665 19. 277,-2. 048 19. 576,-1. 423 19. 796,-0. 792 19. 937,-0. 159 19. 997,0. 476 19. 977,1. 108 19. 877,1. 736 19. 696,2. 358 19. 436,2. 969 19. 098,3. 569 18. 683,4. 154 18. 193,4. 723 17. 629,5. 272 16. 995,5. 801 16. 292,6. 306 15. 523,6. 785 14. 692,7. 237 13. 802,7. 66 12. 856,8. 053 11. 858,8. 413 10. 813,8. 738 9. 724,9. 029 8. 596,9. 284 7. 433,9. 501 6. 241,9. 679 5. 023,9. 819 3. 785,9. 92 2. 532,9. 98 1. 268,10 0)) path SVGtoWKT. path('M10 10 C 20 20, 40 20, 50 10Z');&gt;&gt;&gt;  POLYGON((10 -10,10. 722 -10. 689,11. 474 -11. 344,12. 255 -11. 964,13. 062 -12. 551,13. 894 -13. 102,14. 747 -13. 62,15. 62 -14. 103,16. 51 -14. 552,17. 417 -14. 968,18. 339 -15. 35,19. 273 -15. 7,20. 219 -16. 018,21. 175 -16. 304,22. 139 -16. 558,23. 112 -16. 782,24. 09 -16. 974,25. 075 -17. 137,26. 064 -17. 269,27. 056 -17. 371,28. 051 -17. 443,29. 048 -17. 486,30. 045 -17. 5,31. 043 -17. 484,32. 04 -17. 438,33. 035 -17. 363,34. 027 -17. 258,35. 015 -17. 123,35. 999 -16. 958,36. 977 -16. 763,37. 949 -16. 536,38. 913 -16. 279,39. 868 -15. 99,40. 813 -15. 67,41. 746 -15. 317,42. 666 -14. 931,43. 571 -14. 512,44. 461 -14. 06,45. 332 -13. 574,46. 183 -13. 053,47. 012 -12. 498,47. 817 -11. 909,48. 595 -11. 285,49. 345 -10. 627,49. 909 -10,48. 911 -10,47. 914 -10,46. 916 -10,45. 918 -10,44. 92 -10,43. 923 -10,42. 925 -10,41. 927 -10,40. 929 -10,39. 932 -10,38. 934 -10,37. 936 -10,36. 939 -10,35. 941 -10,34. 943 -10,33. 945 -10,32. 948 -10,31. 95 -10,30. 952 -10,29. 954 -10,28. 957 -10,27. 959 -10,26. 961 -10,25. 964 -10,24. 966 -10,23. 968 -10,22. 97 -10,21. 973 -10,20. 975 -10,19. 977 -10,18. 98 -10,17. 982 -10,16. 984 -10,15. 986 -10,14. 989 -10,13. 991 -10,12. 993 -10,11. 995 -10,10. 998 -10,10 -10)) If you look at the output strings, you’ll notice that the Y-axis coordinates in the WKT are inverted relative to the input: SVGtoWKT. polyline('1,2 3,4') returns LINESTRING(1 -2,3 -4), not LINESTRING(1 2,3 4). This is because the Y-axis “grows” in the opposite direction on maps as it does in document space. In Illustrator, the coordinate grid starts at the top left corner, and the Y-axis increases as you move down on the page; on maps, the Y-axis increases as you move “up,” to the north. SVG-to-WKT just flips the Y-axis coordinates to make the orientation correct on the map. TODO    Make it work in Node. js. This is actually a bit trickier that I thought it would be, because Node doesn’t implement the browser-native methods that jQuery’s parseXML uses. It may make sense to move to a generic XML parser that works in Node, which would be lighter-weight than jQuery anyway.     Instead of just being purely functional (SVG in, WKT out), it might be useful to return some sort of SVGDocument object that could then be used to generate specific WKT strings at different density levels, orientations, etc. This would have come in handy while writing the custom OpenLayers handler that Neatline uses to actually position the generated WKT on the map (more on this later).     Get rid of the Underscore. js dependency.  "
        }, {
        "id": 85,
        "url": "https://neatline.org//2013/02/13/neatline-feature-preview-importing-svg-documents-from-adobe-illustrator/",
        "title": "Neatline Feature Preview &#8211; Importing SVG documents from Adobe Illustrator",
        "body": "2013/02/13 - [Cross-posted with dclure. org] ;tldr – The new version of Neatline makes it possible to take SVG documents created in vector editing software like Adobe Illustrator and Inkscape and “drag” them directly onto the map, just like a regular polygon. This makes it possible to create really sophisticated illustrations that go far beyond the blocky, “sharp-edge” style that we usually associate with digital maps. Check out the screencast (and scroll down for screenshots): The first version of Neatline implemented a pretty standard set of GIS controls for sketching vector geometry onto maps – points, lines, and polygons. It was easy to sketch out simple shapes, but more difficult to create really intricate, complex illustrations. Really, this is a sort of ubiquitous problem with digital maps, which tend to be good at representing points, but bad at representing curves. Under the hood, shapes on digital maps are represented by a series of X/Y coordinate pairs, wrapped up into different geometry types that store information about how the points should be displayed. For example, in Well-Known Text – the serialization format used by databases like PostGIS and MySQL – a line is represented by LINESTRING(1 2,3 4,5 6), a polygon by POLYGON((1 2,3 4,5 6,1 2)), and so on and so forth. At the end of the day, everything is just a series of hard-coded points, strung together to form shapes. This low-level organization in the data tends to bubble up to the level of user interfaces in the form of map sketching tools that make it easy to draw jagged shapes but hard to draw smooth shapes. For example, in the first version of Neatline, drawing this is easy: But this is much harder: It’s still possible, but it’s time-consuming and brittle – if you change your mind later and want to adjust the curvature of the arrow, you have to manually reposition dozens of points. This especially frustrating since, in other domains, this is a well-understood problem with lots of high-quality solutions: Vector graphics editors like Adobe Illustrator, Inkscape, and even in-browser tools like svg-edit make it easy to create smooth, complex vector-based geometries that can be serialized to a portable XML format called SVG (Scalable Vector Graphics). In the upcoming release of Neatline, we’ve made it possible to take SVG markup created in any vector editing tool and place it directly onto the map. Just save off any vector graphic as a SVG document, open up the file in a text editor, and paste the raw markup into the Neatline editor. Then just drag out the shape to any position, dimension, and orientation on the map. Once the new geometry is in place, it behaves just like regular points and polygons added with the default controls – it can be styled and edited just like anything else on the map. This also opens up a whole new front of high-fidelity text-based annotation on digital maps. Since vector editors can convert strings of text into SVG paths, this makes it possible to sketch out labels, snippets, or even little paragraphs of content directly onto the map itself.    "
        }, {
        "id": 86,
        "url": "https://neatline.org//2013/02/13/neatline-feature-preview-importing-svg-documents-from-adobe-illustrator-2/",
        "title": "Neatline Feature Preview – Importing SVG documents from Adobe Illustrator",
        "body": "2013/02/13 - [Cross-posted with dclure. org] ;tldr – The new version of Neatline makes it possible to take SVG documents created in vector editing software like Adobe Illustrator and Inkscape and “drag” them directly onto the map, just like a regular polygon. This makes it possible to create really sophisticated illustrations that go far beyond the blocky, “sharp-edge” style that we usually associate with digital maps. Check out the screencast (and scroll down for screenshots): The first version of Neatline implemented a pretty standard set of GIS controls for sketching vector geometry onto maps – points, lines, and polygons. It was easy to sketch out simple shapes, but more difficult to create really intricate, complex illustrations. Really, this is a sort of ubiquitous problem with digital maps, which tend to be good at representing points, but bad at representing curves. Under the hood, shapes on digital maps are represented by a series of X/Y coordinate pairs, wrapped up into different geometry types that store information about how the points should be displayed. For example, in Well-Known Text – the serialization format used by databases like PostGIS and MySQL – a line is represented by LINESTRING(1 2,3 4,5 6), a polygon by POLYGON((1 2,3 4,5 6,1 2)), and so on and so forth. At the end of the day, everything is just a series of hard-coded points, strung together to form shapes. This low-level organization in the data tends to bubble up to the level of user interfaces in the form of map sketching tools that make it easy to draw jagged shapes but hard to draw smooth shapes. For example, in the first version of Neatline, drawing this is easy: But this is much harder: It’s still possible, but it’s time-consuming and brittle – if you change your mind later and want to adjust the curvature of the arrow, you have to manually reposition dozens of points. This especially frustrating since, in other domains, this is a well-understood problem with lots of high-quality solutions: Vector graphics editors like Adobe Illustrator, Inkscape, and even in-browser tools like svg-edit make it easy to create smooth, complex vector-based geometries that can be serialized to a portable XML format called SVG (Scalable Vector Graphics). In the upcoming release of Neatline, we’ve made it possible to take SVG markup created in any vector editing tool and place it directly onto the map. Just save off any vector graphic as a SVG document, open up the file in a text editor, and paste the raw markup into the Neatline editor. Then just drag out the shape to any position, dimension, and orientation on the map. Once the new geometry is in place, it behaves just like regular points and polygons added with the default controls – it can be styled and edited just like anything else on the map. This also opens up a whole new front of high-fidelity text-based annotation on digital maps. Since vector editors can convert strings of text into SVG paths, this makes it possible to sketch out labels, snippets, or even little paragraphs of content directly onto the map itself.    "
        }, {
        "id": 87,
        "url": "https://neatline.org//2013/02/06/neatline-feature-preview-1000000-records-in-a-single-exhibit/",
        "title": "Neatline Feature Preview – 1,000,000 records in a single exhibit",
        "body": "2013/02/06 - [Cross-posted with dclure. org] ;tldr – The upcoming version of Neatline makes it possible to build huge interactive maps with as many as 1,000,000 records in a single exhibit. It also introduces a new set of tools to search, filter, and organize geospatial data at that scale. Watch the screencast: One of the biggest limitations of the first version of Neatline was the relatively small amount of data that could loaded into any individual exhibit. Since the entire collection of records was loaded in a single batch on page-load, exhibits were effectively constrained by the capabilities of the browser Javascript environment. Beyond a certain point (a couple hundred records), the front-end application would get loaded down with too much data, and performance would start to suffer. In a certain sense, this constraint reflected the theoretical priorities of the first version of the project – small data over large data, hand-crafted exhibit-building over algorithmic visualization. But it also locks out a pretty large set of projects that need to be built on top of medium-to-large spatial data sets. In the upcoming version 1. 2 release of the software (which also migrates the codebase to work with the newly-released Omeka 2. 0) we’ve reworked the server-side codebase to make it possible to work with really large collections of data – as many as 1,000,000 records in a single Neatline exhibit. Three basic changes were needed to make this possible:  Spatial data needed to loaded “on-demand” in the browser. When the viewport is focused on San Francisco, the map doesn’t need to load data for New York. Huge performance gains can be had by loading data “as-needed” – the new version of Neatline uses the MySQL spatial extensions to dynamically query the collection when the user moves or zooms the map, and just loads the specific subset of records that fall inside the current viewport. As long as the exhibit creator sensibly manages the content to ensure that no more than a couple hundred records are visible at any given point (which isn’t actually much of a limitation – anything more tends to become bad information design), this means that the size of Neatline exhibits is effectively bounded only by the capabilities of the underlying MySQL database. &lt;/li&gt;         The editor needed more advanced content management tools to work with large collections of records. In the first version of Neatline, all the records in an exhibit were stacked up vertically in the editing panel. If the map can display 1,000,000 records, though, the editor needs more advanced tooling to effectively manage content at that scale. Neatline 1. 2 adds full-text search, URL-addressable pagination, and a “spatial” search feature that makes use of the map as a mechanism to query and filter the collection of records.           There needed to be an easy way to make batch updates on large sets of records in an exhibit. Imagine you’re mapping election returns from the the 2012 presidential election and have 20,000 points on neighborhoods that voted democratic. If you decide you want to change the shade of blue you’re using for the dots, there has to be an easy way of updating all 20,000 records at once, instead of manually updating each of the records individually. In version 1. 2, we’ve made it possible to assign arbitrary tags to Neatline records, and then use a CSS-like styling language – inspired by projects like Cascadenik – to define portable stylesheets that make it easy to apply bulk updates to records with a given tag or set of tags. &lt;/li&gt; &lt;/ol&gt; These are big changes, and we’re really excited about the new possibilities that open up with this level of scalability. At the same time, all development carries an opportunity cost – working on features A and B means you’re not working on features C and D. Generally, Neatline is on a trajectory towards becoming a much more focused piece of software that hones in on a lean, extensible toolset for building interactive maps. We’re taking a hard look at features that don’t support that core competency.     In the coming weeks, we’ll release an alpha version of the new codebase and solicit feedback from users to figure out what works and what doesn’t. What’s essential? What’s expendable? What assumptions are we making that nobody else is making?       "
        }, {
        "id": 88,
        "url": "https://neatline.org//2013/02/06/neatline-1-2-feature-preview-1000000-records-in-a-single-exhibit/",
        "title": "Neatline 1.2 Feature Preview &#8211; 1,000,000 records in a single exhibit",
        "body": "2013/02/06 - [Cross-posted with dclure. org] ;tldr – The upcoming version of Neatline makes it possible to build huge interactive maps with as many as 1,000,000 records in a single exhibit. It also introduces a new set of tools to search, filter, and organize geospatial data at that scale. Watch the screencast: One of the biggest limitations of the first version of Neatline was the relatively small amount of data that could loaded into any individual exhibit. Since the entire collection of records was loaded in a single batch on page-load, exhibits were effectively constrained by the capabilities of the browser Javascript environment. Beyond a certain point (a couple hundred records), the front-end application would get loaded down with too much data, and performance would start to suffer. In a certain sense, this constraint reflected the theoretical priorities of the first version of the project – small data over large data, hand-crafted exhibit-building over algorithmic visualization. But it also locks out a pretty large set of projects that need to be built on top of medium-to-large spatial data sets. In the upcoming version 1. 2 release of the software (which also migrates the codebase to work with the newly-released Omeka 2. 0) we’ve reworked the server-side codebase to make it possible to work with really large collections of data – as many as 1,000,000 records in a single Neatline exhibit. Three basic changes were needed to make this possible:  Spatial data needed to loaded “on-demand” in the browser. When the viewport is focused on San Francisco, the map doesn’t need to load data for New York. Huge performance gains can be had by loading data “as-needed” – the new version of Neatline uses the MySQL spatial extensions to dynamically query the collection when the user moves or zooms the map, and just loads the specific subset of records that fall inside the current viewport. As long as the exhibit creator sensibly manages the content to ensure that no more than a couple hundred records are visible at any given point (which isn’t actually much of a limitation – anything more tends to become bad information design), this means that the size of Neatline exhibits is effectively bounded only by the capabilities of the underlying MySQL database. &lt;/li&gt;         The editor needed more advanced content management tools to work with large collections of records. In the first version of Neatline, all the records in an exhibit were stacked up vertically in the editing panel. If the map can display 1,000,000 records, though, the editor needs more advanced tooling to effectively manage content at that scale. Neatline 1. 2 adds full-text search, URL-addressable pagination, and a “spatial” search feature that makes use of the map as a mechanism to query and filter the collection of records.           There needed to be an easy way to make batch updates on large sets of records in an exhibit. Imagine you’re mapping election returns from the the 2012 presidential election and have 20,000 points on neighborhoods that voted democratic. If you decide you want to change the shade of blue you’re using for the dots, there has to be an easy way of updating all 20,000 records at once, instead of manually updating each of the records individually. In version 1. 2, we’ve made it possible to assign arbitrary tags to Neatline records, and then use a CSS-like styling language – inspired by projects like Cascadenik – to define portable stylesheets that make it easy to apply bulk updates to records with a given tag or set of tags. &lt;/li&gt; &lt;/ol&gt; These are big changes, and we’re really excited about the new possibilities that open up with this level of scalability. At the same time, all development carries an opportunity cost – working on features A and B means you’re not working on features C and D. Generally, Neatline is on a trajectory towards becoming a much more focused piece of software that hones in on a lean, extensible toolset for building interactive maps. We’re taking a hard look at features that don’t support that core competency.     In the coming weeks, we’ll release an alpha version of the new codebase and solicit feedback from users to figure out what works and what doesn’t. What’s essential? What’s expendable? What assumptions are we making that nobody else is making?       "
        }, {
        "id": 89,
        "url": "https://neatline.org//2012/11/28/populating-mysql-tables-with-node-js-2/",
        "title": "Populating MySQL tables with Node.js",
        "body": "2012/11/28 - [Cross-posted from dclure. org] Over the course of the last week or so, I’ve been working on implementing “as-needed” spatial geometry loading for Neatline – the map queries for new data in real-time as the user pans and zooms on the map, just loading the geometries that fall inside the bounding box of the current viewport. Using the spatial analysis functions baked into MySQL, this makes it possible to build out exhibits with many hundreds of thousands of spatial records, provided that the content is organized (in terms of spatial distribution and min/max zoom thresholds) so that no more than a couple hundred records of visible at any given point. I needed a way to build out a really big exhibit to run the new code through its paces. Originally, mostly just because I was lazy to write the SQL, I had been generating testing data using a temporary development controller that called out to a helper functions that actually created the exhibits / records. These actions were invoked by Rake tasks that just spawned off GET requests to the controller actions. This works fine for relatively small data sets, but once I started trying to insert more than about 10,000 rows the loop ran for so long that the request timed out and the process died (at least, I think this was the problem). And, either way, this is just generally slow (all in PHP) and clunky (litters up the codebase). Instead, I decided to write a couple of little standalone scripts that would programmatically build out a big SQL insert and run it directly on the database. In the past, I might have done this with Python, but I remembered how difficult it was to get the Python &lt;-&gt; MySQL bindings working in the past and decided to try in with Node. This turns out to be easy and performant. The basic gist, using the standard node-mysql package: It’s inefficient to run a separate INSERT query for each row; better to clump them together into a single, massive query, which can be accomplished by stacking up a bunch of parentheticals after the VALUES: This can build out a 500,000-record exhibit in about 10 seconds: Full code here. "
        }, {
        "id": 90,
        "url": "https://neatline.org//2012/11/01/neatline-release-omnibus-edition-2/",
        "title": "Neatline Release Omnibus Edition",
        "body": "2012/11/01 - For the next and final round of the Omeka plugin release parade, I’m pleased to announce minor or patch releases for all Neatline plugins. Neatline is an Omeka plugin that helps you tell stories in time and space from your Omeka collection. For more information, see our original announcement or the Neatline site. For now, these are maintenance releases that patch up bugs and improve performance. Stay tuned over the course of the next couple months, though, for news about some exciting new directions for Neatline. We’re hard at work on a new round of development that’s going to migrate Neatline over to Omeka 2. 0, make it a lot easier to use Neatline in a multi-user classroom environment, and make it possible to connect paragraphs, sentences, and words in TEI texts to specific locations in Neatline exhibits. Here’s some information about the bug-fix releases.  Neatline:  Summary The main changes here are bug fixes. We also now store the GIS feature data as KML instead of Well-Known Text.  Version 1. 1. 1 Commit Details  Plug-in Page  On Github  Issues NeatlineMaps:  Summary The main changes here are bug fixes and adding internationalization support.  Version 1. 0. 1 Commit Details  Plug-in Page  On Github  Issues NeatlineTime:  Summary The main changes here are extra configuration options, bug fixes, and internationalization support.  Version 1. 1. 0 Commit Details  Plug-in Page  On Github  Issues NeatlineFeatures:  Summary The main changes here are bug fixes, KML data, and internationalization support.  Version 1. 1. 0 Commit Details  Plug-in Page  On Github  Issues For all of these, you can download the plugins from their plugin pages and provide feature suggestions or report problems on their issues pages. For general questions and help, feel free to ask on the Omeka forums. "
        }, {
        "id": 91,
        "url": "https://neatline.org//2012/10/26/neatline-omeka-theme-name-winners-2/",
        "title": "Neatline Omeka Theme Name Winners!",
        "body": "2012/10/26 - After extensive deliberations at the Scholars’ Lab, we’re pleased to announce that we have two winners of the Neatline Omeka Theme Name Contest:Amanda Visconti and the theme name “Astrolabe,” and Franky Abbott with the theme name “Neatscape. ” We’ll be getting in touch with Amanda and Franky separately, to get those beautiful Neatline tshirts their way. This means we’ll develop and release two Omeka themes. (I’ll have my work cut out for me, but it’s wonderful work. ) We’ll make those themes compatible with the upcoming 2. 0 version of Omeka, so look for those themes shortly after Omeka 2. 0 is released! "
        }, {
        "id": 92,
        "url": "https://neatline.org//2012/10/19/neatline-omeka-theme-name-contest/",
        "title": "Neatline Omeka Theme Name Contest",
        "body": "2012/10/19 - Yesterday I tweeted asking for name suggestions for an Omeka theme based on the design of Neatline. org.  We’ve already gotten a few great responses, but we’ve decided to kick it up a notch. We’ve got a few Neatline t-shirts. They’re nice t-shirts, as demonstrated by our friendly Scholars’ Lab Waynebot: Between now and next Thursday morning, say 9AM Charlottesville time (east coast US), leave us a name suggestion through Twitter (using the #neatlinetheme hash tag) or in the comments on this post. The Neatline team will look them over, pick one, and the winner will get a lovely Neatline t-shirt, some Scholars’ Lab stickers, and a credit line in the theme’s code. The person who mentions a name first will get credit for it. No multiple winners, we don’t have that many tshirts! The name could be a play on “Neatline” or something having to do with functionality of our lovely suite of Neatline plugins. Or it could be something totally random. Common decency, of course, is most appreciated. We’ll announce a winner next Friday morning. So send us a theme name! "
        }, {
        "id": 93,
        "url": "https://neatline.org//2012/09/10/geocoding-for-neatline-part-i/",
        "title": "Geocoding for Neatline &#8211; Part I",
        "body": "2012/09/10 - Recently I was asked if there was a way to import place names in connection with lat/lon points. Twitter’s character limitation does’t provide an adequate format to respond, and this technique can be quite useful outside of Neatline too, so I thought I would dive in a bit and explain a method to can get prepare place names for use in Omeka and beyond. This will be a two part series where I cover the basics of geocoding locations in a CSV file, then move to using these points with the NeatlineFeatures and Neatline plugins for Omeka. GeocodingGeocoding is a method of deriving geographic descriptions (a latitude/longitude point or series of points) from geographic data like an address (or portion of an address) or place name. The more granular the geographic data, the more accurate the location information. For example, Charlottesville, Virginia is far more accurate than Virginia, and the center point that a geocoder would return would use different points to represent this data. As you can see, the red marker is the center point for geocoding ‘Virginia,’ where the blue marker codes the center of ‘Charlottesville, Virginia. ’ [iframe src=”http://jsfiddle. net/wsgrah/rbHhj/embedded/result,js,html,css/” allowfullscreen=”allowfullscreen” frameborder=”0”] There are some complexities, as data can be a bit ambiguous (e. g. W Jefferson St. vs Jefferson St. ), but clever engineers have been working on issues like that and (generally) do a good job figuring out what is intended from partial address information. It is also worth noting that different services have different algorithms for calculating the result from a partial address (center of a county, city, state, country, etc. ), so be sure to check your results to make sure they’re what you are expecing! Web Services: With the growth of different mapping services over the last several years, getting access to geographic information has become pretty straight forward thanks to a lot of really smart engineers working on the problem of providing location-based information. Most likely you’ve consumed these services (even if you didn’t realize) and you’ve probably heard of some of the big companies that provide APIs to their Geocoding services like Google, Yahoo!, and Microsoft. These are great resources, and provide well documented access to their data, but do place some restrictions on the use of the data retrieved from their system. Generally these restrictions are on the commercial re-use of the information, but do read and understand the Terms of Service to make sure your intended use is in compliance with the Terms of Service for the geocoding service you use for your project. While these companies provide access to their information, I did want to take a moment to highlight some other services that are not backed by large corporate entities. Geocoder. us is a service that has good coverage if you’re data is in the US (Geocoder. ca provides a service for Canadian addresses) and allows up to 50,000 requests per day. USC’s GIS Research Laboratory provides a service for up to 2,500 addresses per day, with very few restrictions on its use. The last one I’ll mention (and there are many more of these services), Geonames. org has world-wide coverage, with more than 8 million place names. This service is particularly useful for things you don’t have a street address for (e. g. Eiffel Tower). First StepsI’ll start out by saying it’s not necessary for you to do any coding whatsoever to do geocoding. However, this is a good programming exercise, allowing you to work with a number of technologies. If you have no interest in writing custom code for this, you can check out Google’s Fusion Tables to do something similar to what I will explain here. The examples in this exercise will be written in Ruby, but the concept can be ported to just about any language (node, Python, PHP, Haskell, jQuery, …). If you don’t have Ruby (use a 1. 9 version) installed on your computer, you will need that (Windows, OS X, Linux). I’ll also be using the Geocoder gem as well as the built-in Ruby libraries for working with spreadsheets (specifically CSV, comma-separated values). Project Setup: The basic approach for this project will be to create a project directory, install the necessary libraries, create a spreadsheet of the addresses we want to look up, write a short program that will retrieve the latitude/longitude points (and other information) we need, then write those back this information to a new spreadsheet we can use later on. Assuming you have Ruby (and rubygems) properly installed, all you will need to get going is set up a new project space. A few simple commands will get this project going in your terminal: [code lang=”bash”]mkdir -p ~/projects/geocodegem install geocodertouch ~/projects/geocode/locations. csvtouch ~/projects/geocode/geocoder. rbcd ~/projects/geocode/[/code] This set of commands commands created a new directory (~/projects/geocode) for the project if it does not exist, installed the geocoder library, and created a couple of empty files to store our locations and our program logic. Lastly, we change the current directory (cd ~/projects/geocode for the terminal to be the project directory containing the files. The Datasource: In order to explore this technique, we need some data. A really easy format for working with text is the CSV format, or comma separated values. For the purposes of this exercise, paste the following in to a file named locations. csv. [code]Address,City,State“1600 Pennsylvania Ave”,Washington,DC“931 Thomas Jefferson Parkway”,Charlottesville,VA“Eiffel Tower”[/code] The CSV format is pretty straight forward; you literally separate the values (columns) with commas. The one gotcha is that if you have something with a comma in it, you will need to escape the comma with a backslash (e. g. “Charlottesville, VA” as a single field). Reading the File: Now with a little bit of data, we can turn our attention to reading the values out of the CSV file with an actual program. This is done with the Ruby CSV class, which provides methods to read and manipulate the contents of CSV data. Our program for this exercise will go in the geocoder. rb file. With your favorite text editor, open the geocoder. rb file and add the following: [code lang=”ruby”]require ‘csv’ LOCATIONS = ‘. /locations. csv’ CSV. foreach(LOCATIONS, :headers =&gt; true, :header_converters =&gt; :symbol) do |line|p line[:address]p line[:city]p line[:state]end[/code] This code reads the CSV file, converts each header value in to a symbol (for easy reference) then steps over each line in the file and prints the address, city, and state fields on a new line in the terminal. You can run this program in the terminal by executing the Ruby script with ruby geocoder. rb. When you do, you should see output along these lines: [code]○ → ruby geocoder. rb“1600 Pensylvania Ave”“Washington”“DC”“931 Thomas Jefferson Parkway”“Charlottesville”“VA”[/code] Adding Geocoding: Now that we can read the data, we can change (or refactor) the program to use the geocoder gem and write logic to look up location information. At this point, we need to include the Geocoder library, concatenate the address fields together, then retrieve the location information. [code lang=”ruby”]require ‘csv’require ‘geocoder’LOCATIONS = ‘. /locations. csv’ CSV. foreach(LOCATIONS, :headers =&gt; true, :header_converters =&gt; :symbol) do |line|address_string = “#{line[:address]}, #{line[:city]}, #{line[:state]}”result = Geocoder. search(address_string)p resultend [/code] Now when you run the program (ruby geocoder. rb), you’ll see that there is a lot more information returned from the geocoding web service. To make this a bit more useful for our purposes here, we can use the latitude and longitude convenience methods to display the latitude and longitude coordinates. [code lang=”ruby”] require ‘csv’require ‘geocoder’ LOCATIONS = ‘. /locations. csv’ CSV. foreach(LOCATIONS, :headers =&gt; true, :header_converters =&gt; :symbol) do |line|address_string = “#{line[:address]}, #{line[:city]}, #{line[:state]}”result = Geocoder. search(address_string). firstlat = result. latitudelon = result. longitude puts “#{lat}, #{lon}”end [/code] Now when you run the program, you should see that the program prints the latitude and longitude for the address line. [code lang=”bash”]○ → ruby geocoder. rb38. 8976777, -77. 0365170000000238. 0054041, -78. 456343348. 858278, 2. 294254[/code] This is great, but what we really want to do is write this back to a CSV file in a format that we can use in Omeka. The Neatline plugins currently use a format called WKT format to describe geographic information, so we need to get our results in this format using the WKT ** “Point”** data definition. If you can remember any of your middle school algebra, a point is a set of coordinates (typically X and Y). The Earth’s X axis is longitude, and the Y axis latitude, so we just use this format and wrap the coordinates with “POINT(): [code lang=”ruby”]require ‘csv’require ‘geocoder’ LOCATIONS = ‘. /locations. csv’ puts “address,city,state,point,lat,lon” CSV. foreach(LOCATIONS, :headers =&gt;true, :header_converters =&gt;:symbol) do |line|address_string = “#{line[:address]}, #{line[:city]}, #{line[:state]}”result = Geocoder. search(address_string). firstlat = result. latitudelon = result. longitude point = “POINT(#{lon} #{lat})” puts “#{address_string}, #{point}, #{lat}, #{lon}” end[/code] Notice I removed the comma in the POINT value; this is important as this is specified in the WKT format. Now with a shell trick (not this kind), we can run the program and generate a file that contains the new data. The trick is actually the I/O redirection command (&lt;) which can takes the output of one command and redirects it to a file. I generally prefer (when possible) to generate new files when dealing with massaging data. I’ve just deleted too many files accidentally in code. [code lang=”bash”]ruby geocoder. rb &gt; geocoded. csv[/code] This command will run the file, but redirect the content that was being shown on the screen in to a file named ‘geocoded. csv. ’ Coordinate Systems: Did you know that there were a lot of different ways to actually define latitude and longitude? Before taking this job I had only really seen coordinates expressed in either in the degrees, minutes, seconds format (e. g. 38° 1′ 48″ N, 78° 28′ 44″ W) or it’s decimal equivalent (e. g. 38. 03, -78. 478889). Turns out there are a lot different ways to actually describe these coordinates because our maps are flat, and our planet is not. If the world was actually a real sphere, this wouldn’t be a difficult problem, but the Earth’s shape actually what is referred to as an oblate spheroid, which makes getting precise locations on from the curved Earth to a flat map problematic. How you deal with the conversion of points on the spheroid (Earth) to a map is a projection. This conversion can introduce distortion, like the maps I remember in school growing up where Greenland is larger than Africa. Projections are chosen according to the purpose of the map to preserve qualities like shape, area, distance, or direction. The European Petroleum Survey Group (EPSG) maintains a database of all the myriad projections and datums. After a while, you start to know the more regularly used projections, and the results we got back from the Geocoder gem are in a projection for the WGS 84 coded EPSG:4326. (Note: for a nice piece on projections, check out Projection Lessons in Maps. ) But what does this have to do with the coordinates? In Neatline we are using a different coordinate system to make some of the conversions in using Google base maps a bit easier. Basically we need to take the decimal degrees and covert them to meters. For example, the coordinates of the White House, this: [code lang=”text”]POINT(-77. 03651700000002 38. 8976777)[/code] Which uses a spherical interpretation of the globe becomes the following when converted to meters. [code lang=”text”]POINT(-8575665. 843733624 4707025. 360473459)[/code] These are the same points, just described differently. So how can we handle this in the code? There are services that you can go out and use to re-project your data, but this one is pretty straight forward with a little trigonometry (didn’t think you’d read that today, did you). With a little mathematical hand-waving, I wrote the following method to convert degrees to meters: [code lang=”ruby”]def degrees_to_meters(lon, lat)half_circumference = 20037508. 34x = lon * half_circumference / 180y = Math. log(Math. tan((90 + lat) * Math::PI / 360)) / (Math::PI / 180) y = y * half_circumference / 180 return [x, y]end[/code] The 20037508. 34 the the above code is half the circumference of the earth in meters (I looked it up), and there are some math tricks to account for a generalized flattening of the earth. Now we can call this function and calculate the projected coordinates to use in a Neatline exhibit. [code lang=”ruby”]require ‘csv’require ‘geocoder’ LOCATIONS = ‘. /locations. csv’ def degrees_to_meters(lon, lat)half_circumference = 20037508. 34x = lon * half_circumference / 180y = Math. log(Math. tan((90 + lat) * Math::PI / 360)) / (Math::PI / 180) y = y * half_circumference / 180 return [x, y]end puts ‘address,city,state,point,lat,lon’CSV. foreach(LOCATIONS, :headers =&gt; true, :header_converters =&gt; :symbol) do |line|address_string = “#{line[:address]}, #{line[:city]}, #{line[:state]}”result = Geocoder. search(address_string). first lat = result. latitudelon = result. longitude #point = “POINT(#{lon} #{lat})”projected = degrees_to_meters(lon, lat)point = “POINT(#{projected[0]} #{projected1})” puts “#{address_string}, #{point}, #{lat}, #{lon}”end[/code] When you run the program as described above, you will get results similar to this: [code]address,city,state,point,lat,lon1600 Pennsylvania Ave, Washington, DC, POINT(-8575665. 843733624 4707025. 360473459), 4707025. 360473459, -8575665. 843733624931 Thomas Jefferson Parkway, Charlottesville, VA, POINT(-8733720. 184442518 4580189. 258447956), 4580189. 258447956, -8733720. 184442518Eiffel Tower, , , POINT(255395. 18699487977 6250848. 2584100235), 6250848. 2584100235, 255395. 18699487977[/code] Now you can regenerate your CSV file of the properly formatted location information from the terminal: [code lang=”bash”]ruby geocoder. rb &gt; geocoded. csv[/code] If you’ve already created a geocoded. csv file, the above command will overwrite the file. If you’re wanting to append similar content to the same file, you can use the &gt;&gt; operator which will add the output to the end of the file. SummaryIn this post I covered the basics of using geocoding services through a programming API, as well as reading CSV files, and redirecting output to a new file. I waved my hands with a little magic (some math, some programming, some Unix commands), but there are a lot of techniques here you can use in a variety of scenarious. In my next post, I will cover how to automate populating this information in an Omeka instance, automating the population of this information in new items, then them in a Neatline exhibit. "
        }, {
        "id": 94,
        "url": "https://neatline.org//2012/09/10/geocoding-for-neatline-part-i-2/",
        "title": "Geocoding for Neatline – Part I",
        "body": "2012/09/10 - Recently I was asked if there was a way to import place names in connection with lat/lon points. Twitter’s character limitation does’t provide an adequate format to respond, and this technique can be quite useful outside of Neatline too, so I thought I would dive in a bit and explain a method to can get prepare place names for use in Omeka and beyond. This will be a two part series where I cover the basics of geocoding locations in a CSV file, then move to using these points with the NeatlineFeatures and Neatline plugins for Omeka. GeocodingGeocoding is a method of deriving geographic descriptions (a latitude/longitude point or series of points) from geographic data like an address (or portion of an address) or place name. The more granular the geographic data, the more accurate the location information. For example, Charlottesville, Virginia is far more accurate than Virginia, and the center point that a geocoder would return would use different points to represent this data. As you can see, the red marker is the center point for geocoding ‘Virginia,’ where the blue marker codes the center of ‘Charlottesville, Virginia. ’ There are some complexities, as data can be a bit ambiguous (e. g. W Jefferson St. vs Jefferson St. ), but clever engineers have been working on issues like that and (generally) do a good job figuring out what is intended from partial address information. It is also worth noting that different services have different algorithms for calculating the result from a partial address (center of a county, city, state, country, etc. ), so be sure to check your results to make sure they’re what you are expecing! Web Services: With the growth of different mapping services over the last several years, getting access to geographic information has become pretty straight forward thanks to a lot of really smart engineers working on the problem of providing location-based information. Most likely you’ve consumed these services (even if you didn’t realize) and you’ve probably heard of some of the big companies that provide APIs to their Geocoding services like Google, Yahoo!, and Microsoft. These are great resources, and provide well documented access to their data, but do place some restrictions on the use of the data retrieved from their system. Generally these restrictions are on the commercial re-use of the information, but do read and understand the Terms of Service to make sure your intended use is in compliance with the Terms of Service for the geocoding service you use for your project. While these companies provide access to their information, I did want to take a moment to highlight some other services that are not backed by large corporate entities. Geocoder. us is a service that has good coverage if you’re data is in the US (Geocoder. ca provides a service for Canadian addresses) and allows up to 50,000 requests per day. USC’s GIS Research Laboratory provides a service for up to 2,500 addresses per day, with very few restrictions on its use. The last one I’ll mention (and there are many more of these services), Geonames. org has world-wide coverage, with more than 8 million place names. This service is particularly useful for things you don’t have a street address for (e. g. Eiffel Tower). First StepsI’ll start out by saying it’s not necessary for you to do any coding whatsoever to do geocoding. However, this is a good programming exercise, allowing you to work with a number of technologies. If you have no interest in writing custom code for this, you can check out Google’s Fusion Tables to do something similar to what I will explain here. The examples in this exercise will be written in Ruby, but the concept can be ported to just about any language (node, Python, PHP, Haskell, jQuery, …). If you don’t have Ruby (use a 1. 9 version) installed on your computer, you will need that (Windows, OS X, Linux). I’ll also be using the Geocoder gem as well as the built-in Ruby libraries for working with spreadsheets (specifically CSV, comma-separated values). Project Setup: The basic approach for this project will be to create a project directory, install the necessary libraries, create a spreadsheet of the addresses we want to look up, write a short program that will retrieve the latitude/longitude points (and other information) we need, then write those back this information to a new spreadsheet we can use later on. Assuming you have Ruby (and rubygems) properly installed, all you will need to get going is set up a new project space. A few simple commands will get this project going in your terminal: mkdir -p ~/projects/geocodegem install geocodertouch ~/projects/geocode/locations. csvtouch ~/projects/geocode/geocoder. rbcd ~/projects/geocode/This set of commands commands created a new directory (~/projects/geocode) for the project if it does not exist, installed the geocoder library, and created a couple of empty files to store our locations and our program logic. Lastly, we change the current directory (cd ~/projects/geocode for the terminal to be the project directory containing the files. The Datasource: In order to explore this technique, we need some data. A really easy format for working with text is the CSV format, or comma separated values. For the purposes of this exercise, paste the following in to a file named locations. csv. Address,City,State 1600 Pennsylvania Ave ,Washington,DC 931 Thomas Jefferson Parkway ,Charlottesville,VA Eiffel Tower The CSV format is pretty straight forward; you literally separate the values (columns) with commas. The one gotcha is that if you have something with a comma in it, you will need to escape the comma with a backslash (e. g. “Charlottesville, VA” as a single field). Reading the File: Now with a little bit of data, we can turn our attention to reading the values out of the CSV file with an actual program. This is done with the Ruby CSV class, which provides methods to read and manipulate the contents of CSV data. Our program for this exercise will go in the geocoder. rb file. With your favorite text editor, open the geocoder. rb file and add the following: require 'csv'LOCATIONS = '. /locations. csv'CSV. foreach(LOCATIONS, :headers =&gt; true, :header_converters =&gt; :symbol) do |line| p line[:address] p line[:city] p line[:state]endThis code reads the CSV file, converts each header value in to a symbol (for easy reference) then steps over each line in the file and prints the address, city, and state fields on a new line in the terminal. You can run this program in the terminal by executing the Ruby script with ruby geocoder. rb. When you do, you should see output along these lines: ○ → ruby geocoder. rb 1600 Pensylvania Ave  Washington  DC  931 Thomas Jefferson Parkway  Charlottesville  VA Adding Geocoding: Now that we can read the data, we can change (or refactor) the program to use the geocoder gem and write logic to look up location information. At this point, we need to include the Geocoder library, concatenate the address fields together, then retrieve the location information. require 'csv'require 'geocoder'LOCATIONS = '. /locations. csv'CSV. foreach(LOCATIONS, :headers =&gt; true, :header_converters =&gt; :symbol) do |line| address_string =  #{line[:address]}, #{line[:city]}, #{line[:state]}  result = Geocoder. search(address_string) p resultendNow when you run the program (ruby geocoder. rb), you’ll see that there is a lot more information returned from the geocoding web service. To make this a bit more useful for our purposes here, we can use the latitude and longitude convenience methods to display the latitude and longitude coordinates. require 'csv'require 'geocoder'LOCATIONS = '. /locations. csv'CSV. foreach(LOCATIONS, :headers =&gt; true, :header_converters =&gt; :symbol) do |line| address_string =  #{line[:address]}, #{line[:city]}, #{line[:state]}  result = Geocoder. search(address_string). first lat = result. latitude lon = result. longitude puts  #{lat}, #{lon} endNow when you run the program, you should see that the program prints the latitude and longitude for the address line. ○ → ruby geocoder. rb38. 8976777, -77. 0365170000000238. 0054041, -78. 456343348. 858278, 2. 294254This is great, but what we really want to do is write this back to a CSV file in a format that we can use in Omeka. The Neatline plugins currently use a format called WKT format to describe geographic information, so we need to get our results in this format using the WKT ** “Point”** data definition. If you can remember any of your middle school algebra, a point is a set of coordinates (typically X and Y). The Earth’s X axis is longitude, and the Y axis latitude, so we just use this format and wrap the coordinates with “POINT(): require 'csv'require 'geocoder'LOCATIONS = '. /locations. csv'puts  address,city,state,point,lat,lon CSV. foreach(LOCATIONS, :headers =&gt; true, :header_converters =&gt; :symbol) do |line|  address_string =  #{line[:address]}, #{line[:city]}, #{line[:state]}   result = Geocoder. search(address_string). first  lat = result. latitude  lon = result. longitude  point =  POINT(#{lon} #{lat})   puts  #{address_string}, #{point}, #{lat}, #{lon} endNotice I removed the comma in the POINT value; this is important as this is specified in the WKT format. Now with a shell trick (not this kind), we can run the program and generate a file that contains the new data. The trick is actually the I/O redirection command (&lt;) which can takes the output of one command and redirects it to a file. I generally prefer (when possible) to generate new files when dealing with massaging data. I’ve just deleted too many files accidentally in code. ruby geocoder. rb &gt; geocoded. csvThis command will run the file, but redirect the content that was being shown on the screen in to a file named ‘geocoded. csv. ’ Coordinate Systems: Did you know that there were a lot of different ways to actually define latitude and longitude? Before taking this job I had only really seen coordinates expressed in either in the degrees, minutes, seconds format (e. g. 38° 1′ 48″ N, 78° 28′ 44″ W) or it’s decimal equivalent (e. g. 38. 03, -78. 478889). Turns out there are a lot different ways to actually describe these coordinates because our maps are flat, and our planet is not. If the world was actually a real sphere, this wouldn’t be a difficult problem, but the Earth’s shape actually what is referred to as an oblate spheroid, which makes getting precise locations on from the curved Earth to a flat map problematic. How you deal with the conversion of points on the spheroid (Earth) to a map is a projection. This conversion can introduce distortion, like the maps I remember in school growing up where Greenland is larger than Africa. Projections are chosen according to the purpose of the map to preserve qualities like shape, area, distance, or direction. The European Petroleum Survey Group (EPSG) maintains a database of all the myriad projections and datums. After a while, you start to know the more regularly used projections, and the results we got back from the Geocoder gem are in a projection for the WGS 84 coded EPSG:4326. (Note: for a nice piece on projections, check out Projection Lessons in Maps. ) But what does this have to do with the coordinates? In Neatline we are using a different coordinate system to make some of the conversions in using Google base maps a bit easier. Basically we need to take the decimal degrees and covert them to meters. For example, the coordinates of the White House, this: POINT(-77. 03651700000002 38. 8976777)Which uses a spherical interpretation of the globe becomes the following when converted to meters. POINT(-8575665. 843733624 4707025. 360473459)These are the same points, just described differently. So how can we handle this in the code? There are services that you can go out and use to re-project your data, but this one is pretty straight forward with a little trigonometry (didn’t think you’d read that today, did you). With a little mathematical hand-waving, I wrote the following method to convert degrees to meters: def degrees_to_meters(lon, lat)  half_circumference = 20037508. 34  x = lon * half_circumference / 180  y = Math. log(Math. tan((90 + lat) * Math::PI / 360)) / (Math::PI / 180)  y = y * half_circumference / 180  return [x, y]endThe 20037508. 34 the the above code is half the circumference of the earth in meters (I looked it up), and there are some math tricks to account for a generalized flattening of the earth. Now we can call this function and calculate the projected coordinates to use in a Neatline exhibit. require 'csv'require 'geocoder'LOCATIONS = '. /locations. csv'def degrees_to_meters(lon, lat)  half_circumference = 20037508. 34  x = lon * half_circumference / 180  y = Math. log(Math. tan((90 + lat) * Math::PI / 360)) / (Math::PI / 180)  y = y * half_circumference / 180  return [x, y]endputs 'address,city,state,point,lat,lon'CSV. foreach(LOCATIONS, :headers =&gt; true, :header_converters =&gt; :symbol) do |line|  address_string =  #{line[:address]}, #{line[:city]}, #{line[:state]}   result = Geocoder. search(address_string). first  lat = result. latitude  lon = result. longitude  #point =  POINT(#{lon} #{lat})   projected = degrees_to_meters(lon, lat)  point =  POINT(#{projected[0]} #{projected[1]})   puts  #{address_string}, #{point}, #{lat}, #{lon} endWhen you run the program as described above, you will get results similar to this: address,city,state,point,lat,lon1600 Pennsylvania Ave, Washington, DC, POINT(-8575665. 843733624 4707025. 360473459), 4707025. 360473459, -8575665. 843733624931 Thomas Jefferson Parkway, Charlottesville, VA, POINT(-8733720. 184442518 4580189. 258447956), 4580189. 258447956, -8733720. 184442518Eiffel Tower, , , POINT(255395. 18699487977 6250848. 2584100235), 6250848. 2584100235, 255395. 18699487977Now you can regenerate your CSV file of the properly formatted location information from the terminal: ruby geocoder. rb &gt; geocoded. csvIf you’ve already created a geocoded. csv file, the above command will overwrite the file. If you’re wanting to append similar content to the same file, you can use the &gt;&gt; operator which will add the output to the end of the file. SummaryIn this post I covered the basics of using geocoding services through a programming API, as well as reading CSV files, and redirecting output to a new file. I waved my hands with a little magic (some math, some programming, some Unix commands), but there are a lot of techniques here you can use in a variety of scenarious. In my next post, I will cover how to automate populating this information in an Omeka instance, automating the population of this information in new items, then them in a Neatline exhibit. "
        }, {
        "id": 95,
        "url": "https://neatline.org//2012/09/06/omeka-neatline-metadata-survey/",
        "title": "Omeka + Neatline Metadata Survey",
        "body": "2012/09/06 - [crossposted from scholarslab. org] As part of our collaboration on Omeka + Neatline, the Scholars’ Lab and Omeka development teams are seeking your assistance to help make our projects more useful across many scholarly disciplines–including beyond the humanities and cultural heritage fields in which they originated. We’ve developed a short survey asking questions about new data types that Omeka+Neatline could display and metadata formats that it might import and describe. While Omeka + Neatline can handle many metadata standards and formats familiar to humanities scholars, archivists, and museum professionals–such as Encoded Archival Description schema (EAD), Text Encoding Initiative schema (TEI), Dublin Core (DC) and Visual Resources Association Core (VRA Core)–it is also possible to import simple CSV files or any flat XML format, with potential to handle other formats more applicable to your field’s standards. We’d like to hear about other specific standards and formats that could make Omeka + Neatline more helpful to your research and scholarship. Thank you for taking a few minutes to answer our survey!    Please click here to take the survey "
        }, {
        "id": 96,
        "url": "https://neatline.org//2012/08/29/using-neatline-with-historical-maps-part-3-geoserver/",
        "title": "Using Neatline with historical maps :: Part 3 &#8211; GeoServer",
        "body": "2012/08/29 - Note This is specifically for Omeka/Neatline 1. x. If you are using Omeka/Neatline 2. x, you can upload your maps to Geoserver with Option 2 below. Follow Editing Record Imagery for working with the WMS layers. [Cross-posted with dclure. org and scholarslab. org] This is part 3 of a 3-post tutorial that walks through process of georeferencing a historical map and using it in GeoServer and Neatline. In part 1 of this series, we used ArcMap to convert a static image into a georeferenced . tiff file. In part 2, we post-processed the file with gdal to remove the black borders around the image. In this article, we’ll load the . tiff file into GeoServer and import the final web map service into a Neatline exhibit. Generating the web map service on GeoServer There are two ways to upload the . tiff file to GeoServer – the entire process can be performed through the Omeka interface using the Neatline Maps plugin, or the file can be uploaded directly onto the machine running GeoServer and the service created by way of the GeoServer administrative interface. The first option is easier, but there’s a fundamental restriction that makes it unworkable in certain situations – since Neatline Maps has to upload the . tif file through Omeka before it can create the map service via the GeoServer API, it’s impossible to upload files through Neatline Maps that are larger than the file upload limit set by the upload_max_filesize and post_max_size settings in the php. ini file on your server. Depending on the hosting environment, these values can be set to anywhere from 2-20 megabytes by default. If you have access to the php. ini file, you can bump up the limit, but beyond a certain point it probably makes more sense just to upload the file directly to the server running GeoServer and create the web services through GeoServer administrative interface. Since high-resolution . tiff files can easily weight in a hundreds of megabytes or even gigabytes, this is often a more controlled and reliable approach, especially in cases where you’re working with multiple files at once. Regardless of how the file is uploaded, the final process of importing the map service into Omeka and Neatline works the same way. Option 1: Upload through Neatline Maps If your file is small enough to be uploaded through Omeka, the Neatline Maps plugin provides plug-and-play connectivity with GeoServer:    With Neatline Maps installed, click on the “Neatline Maps” tab in the top toolbar of the Omeka administrative interface and click on “Create Server. ” Fill in the URL, Username, and Password for your GeoServer. In the Name section, enter a plaintext identifier for the server (used for content management in Omeka) and use the Workspace field to specify the workspace on the GeoServer installation that will house the new stores and layers. Click “Save” to create the server record. (Note: If you want to upload files to more than one installation of GeoServer, you can create as many server records as you want. At any given point, though, only one of the record can be marked as the “Active” server – this the server that the plugin will use to handle new . tif uploads).        Create an item to associate the web map service with (or edit an existing item). In the Item add/edit form, click on the “Files” tab, click on “Choose File,” and select the . tiff file as you would for a regular file upload. When you save the item, Neatline Maps will automatically detect that you’re trying to upload a georeferenced . tif file and create a corresponding web map service by way of the GeoServer API.    Once you’ve saved the file, if you go back into the Item edit form and click on the “Web Map Service” tab, you’ll notice that “WMS Address” and “Layers” fields have been automatically updated to point to the new web map service. On the show page for the item, the map will be displayed in a small, interactive widget below the default metadata fields.  Option 2: Upload directly to GeoServer    First, upload the file to the server running GeoServer with scp or another file transfer protocol. It’s usually a good idea to get the file out of the /tmp directory, but it doesn’t matter beyond that – GeoServer can read the entire file system. We’ve gotten into the habit of putting the source . tiff files in /var/geotiff.     In the GeoServer administrative interface, click on “Stores” in the left column and then click “Add new Store. ” On the next screen, click GeoTIFF under the “Raster Data Sources” heading.        Select a workspace for the store and enter a name. Under “Connection Parameters,” click the “Browse. . ” link, and use the pop-up window to navigate to the file. Click “Save” to create the store.        Next, we have to publish the store as a public-facing layer. On the next screen, click the “Publish” link.        Now, the tricky part. We have to manually tell GeoServer to deliver the layer using a coordinate projection system that Neatline can use to layer the map on top of the real-geography base layers in OpenLayers. Scroll down to the “Coordinate Reference Systems” heading and enter EPSG:900913 into the “Declared SRS” field. Under “SRS handling,” select “Force declared. ” Under the “Bounding Boxes” heading, click both the “Compute from data” and “Compute from native bound” links.     Now, with the layer created, we can associate the new web map service with an item in your Omeka collection by manually filling in the two fields in the “Web Map Services” tab:  Go back the Omeka administrative interface and find the item that you want to associate the map with (or just create a new item). Open up the edit form for the item.          Click the “Web Map Services” tab. Fill in the the top-level WMS address for the GeoServer installation (this always ends with /wms, and might look something like localhost:8080/GeoServer/wms) and enter the list of comma-delimited layers that you want to be associated with the item. For example, if you have a workspace called “hotchkiss” with layers “chancellorsville” and “fredericksburg,” you could enter:     hotchkiss:chancellorsville,hotchkiss:fredericksburg.                Save the item       Use the map in a Neatline exhibit: The two methods both have the end result of filling in the two fields in the “Web Map Services” tab. The only difference is in whether the . tif file is uploaded through Omeka or directly into GeoServer. Once an item is linked to a web map service, Neatline automatically detects the map and loads it into an exhibit when the item is activated on the map. With the item queried into the editing environment for an exhibit, just check the middle of the three checkboxes next to the listing for the item in the content management panel: …and the WMS layer will appear on the map: "
        }, {
        "id": 97,
        "url": "https://neatline.org//2012/08/23/using-neatline-with-historical-maps-part-2-transparency/",
        "title": "Using Neatline with historical maps :: Part 2 &#8211; Transparency",
        "body": "2012/08/23 - Update 8/27/12: After posting this last week, a comment by KaCeBe on the Scholars’ Lab blog led me to go back and look for a way to get Geoserver to render transparent borders without having to manually add an alpha channel to the file. Although I still can’t find way to make Geoserver do it automatically, I did find this thread on the OSGeo. org forums in which user bovermyer finds a solution that’s much faster than the Photoshop workflow described in this post. With gdal installed (see below), open up the terminal and run this command: gdalwarp -srcnodata 0 -dstalpha file1. tif file2. tif …where file1. tif is the name of the original file generated by ArcMap and file2. tif is the name of the new, transparency-added copy of the file1. tif generated by gdal. Then (re)build the geotiff with this command: gdal_translate -of GTiff -a_srs EPSG:4326 file2. tif file2_rebuilt. tif …which we’ve found is necessary to avoid errors during the Geoserver upload process. At this point, file2_rebuilt. tif is ready to be loaded into Geoserver and brought into a Neatline exhibit. Much faster than pointing-and-clicking in Photoshop! [Cross-posted with dclure. org and scholarslab. org] This is part 2 of a 3-post tutorial that walks through process of georeferencing a historical map and using it in Geoserver and Neatline. Check out part 1, which covers rectification in ArcMap. In the first part of this series, we brought a static image into ArcMap and converted it onto a georeferenced . tif file. In this article, we’ll post-process the image in Photoshop to get it ready to be loaded into Geoserver. The problem: Black borders around the image If you open up the newly-generated . tif file in a regular image editing program, you’ll see that ArcMap added in regions of black around the actual map to make it fill the rectangular aspect ratio of the file. This happens almost every time, since the process of rectification usually involves rotating the image away from its original orientation.  In the context of a Neatline exhibit, this is problematic because the black borders will completely occlude the real-geography base layer (or underlying historical maps) immediately surrounding the image. Fortunately, former Scholars’ Lab GIS assistant Dave Richardson figured out how to strip out the borders in Photoshop by converting them into transparencies. This step is a bit of a nuisance, but we’ve found that it dramatically improves the final appearance of the map. Here’s how to do it:    Go to the directory that the file was originally saved to. You’ll notice that ArcMap actually generated four files – the . tif, along with a . tfw, tif. aux. xml, and . tif. ovr. Leave all the files in place, since we’ll need them at the end of the process to rebuild the geospatial header information after we post-process the image. Open up the main . tif file in Photoshop.        In Photoshop, right click on the starting background layer and click “Layer from Background. ” This will delete the locked background and replace it with a regular layer with the same content.        Use the “Magic Wand Tool”      to select each of the borders by holding down the shift key and clicking inside the black areas. A dotten line will snap to the edges of the borders. If the wand tool is selecting parts of the actual map image, drop down the “Tolerance” setting to 1, which will limit the selection to the exact color value of the clicked location on the image. Once the borders are selected, press the delete key to clear out the selection. At this point, the image should be surrounded by the default, checkered background graphic.        Add an alpha channel to the image by clicking on the “Channels” tab on the top toolbar of the layers window (If the “Channels” tab isn’t available by default, activate it by clicking Window &gt; Channels). Click the dropdown icon at the right of the toolbar, and click “New Channel. ” Check the “Masked Areas” radio button, and set the color to be pure black with 0% opacity. Click “OK” to create the channel.        Now, activate the Magic Wand Tool again and select each of the checkered, transparent areas around the image (the regions that were originally filled with the black borders). Then, invert the selection by clicking on Select &gt; Inverse. At this point, the selection should exactly frame the map itself (the portion of the image that should not be transparent).        Back over in the Channels tab, click on the listing for the Alpha channel that was created in step 4 and hide the RBG channels by clicking the visibility checkbox next to the top-level RGB listing. This will cause the image to go totally black, with the selection of the map region still active on top of the alpha channel.        Activate the Paint Bucket Tool      and set the foreground color to pure white (If you don’t see the icon for the paint bucket in the Tools column, click and hold the icon for the “Gradient” tool      and a drop-down select will appear with a listing for the Paint Bucket). Then apply the paint bucket on the selected area on the Alpha channel, creating a white area over the region occupied by the map.        Make sure that both the Alpha channel and all of the RGB color channels are marked as visible in the Channels window. Then go to File &gt; Save As. So as not to override the name of the original file, change the name to something like [original filename]_processed. Uncheck “Layers,” check “As a Copy” and “Alpha Channels,” and click “Save. ”       On the “Tiff Options” dialog box, leave “Save Image Pyramid” and “Save Transparency” unchecked and make sure “Discard Layers and Save a Copy” is checked.     Now, we have a second version of the . tiff file with an Alpha channel that converts the black borders into transparent regions. The problem, though, is that the process of re-saving the file strips out the critical geospatial information in the original . tiff – we’ll have to insert this data back into the processed file before it can be used in Geoserver and Neatline. Rebuilding the geotiff We’ll take care of this using a utility called gdal, a powerful command line library that can do a wide variety of transformations on geospatial files. Head over to gdal. org for full documentation on how to install the command line utilities. On Mac OSX, using the homebrew package manager, it should be as easy as brew install gdal. If you’re on Windows, a binary distribution of the tool can be found here. With gdal installed, fire up the terminal and change into the directory with the original . tif, the processed . tif, and the three *. tfw files.    First, create a copy the original . tfw file with a name that matches the processed . tif file that was created in step 8 above. So, if the original . tif was called hotchkiss. tif, and the processed file was saved as hotchkiss_processed. tif, copy hotchkiss. tfw as hotchkiss_processed. tfw (this can be done with cp hotchkiss. tfw hotchkiss_processed. tfw). The file names have to match in order for gdal to know where to pull information about the coordinate projection when we rebuild the header.     Now, still assuming we’re working with files named hotchkiss_processed. tif and hotchkiss_processed. tfw, rebuild the header with this command:   gdal_translate -of GTiff -a_srs EPSG:4326 hotchkiss_processed. tif hotchkiss_processed_rebuilt. tif.   (Note: It doesn’t actually matter what you call the derivative files at the various steps of the process. All that matters is that the . tfw file matches the name of the processed . tif file. )  This will create a new file called hotchkiss_processed_rebuilt. tif that contains the transparency channel and the reconstructed geospatial information. At this point, the file is ready to be uploaded to Geoserver and brought into a Neatline exhibit. "
        }, {
        "id": 98,
        "url": "https://neatline.org//2012/08/20/using-neatline-with-historical-maps-part-1-georeferencing/",
        "title": "Using Neatline with historical maps :: Part 1 &#8211; Georeferencing",
        "body": "2012/08/20 - [Cross-posted with scholarslab. org] Out of the box, Neatline (our recently-released framework for building geotemporal exhibits) can be used to create geo-temporal exhibits based on “modern-geography” base-layers – OpenStreetMap, Google satellite and street maps, and a collection of beautiful, stylized layers from Stamen Design. For historical and literary projects, though, one of Neatline’s most powerful features is its deep integration with Geoserver, an open-source geospatial server that can pipe georeferenced historical maps directly into Neatline exhibits. For some examples of this, check out these four demo exhibits built on Civil War battle maps by Jedediah Hotchkiss. Geoserver is a pretty complex piece of software, and the process of assigning geographic coordinates to static image files (called “georeferencing” or “georectifying”) can be a bit tricky at first. This is the first post in a three-part series that will walk through the entire process of rectifying a historical map using ArcMap, post-processing the image, uploading it to Geoserver, and importing the final web map service into a Neatline exhibit. Georectification To start, all you need is a static image file that can be positioned in some way or another on top of a real-geography base layer. Usually, this is a map of some sort, but it could also be aerial photography, or, in more experimental and interpretive use-cases, it could even be a totally non-geographic image that would gain some kind of meaning from being situated in a geospatial context (for example, see the georeferenced manuscript pages in the “My Dear Little Nelly” exhibit). Since the final map will be presented in an interactive environment that lets the user zoom in and out at will, it’s best to try to find a high-resolution version of the image you want to work with, which will make it possible to zoom further in before the image starts to noticeably pixelate. That said, the images don’t need to be excessively large – as Kelly Johnston (one of the GIS specialists in the Scholars’ Lab) pointed out, extremely high-fidelity images (~10,000 pixels in height or width) often don’t really provide that much more value than somewhat smaller images, and can have the effect of choking up Geoserver and slowing down the speed with which the map is rendered in the final Neatline exhibit. For historical and literary use cases, I’ve found that images with dimensions in the 3000-5000 pixel range provide a good balance of resolution and speed. In this tutorial, I’ll be working with map #124 in the Hotchkiss Map Collection at the Library of Congress (see the full list of maps here). To get the static image file, go to the view page for the map and right click on the “Download JPEG2000 image” link at the bottom of the screen and click “Save Link As…” With the image in hand, let’s fire up ArcMap and get the environment set up:    Add a base map by clicking on File &gt; Add Data &gt; Add Basemap. The base map is the real-geography foundation, the “true” map against which the image will be referenced. Select one of the nine options and click “Add. ” This is largely just a matter of preference. For for maps with a lot of human geography (roads, railroads, cities), I like the “Bing Maps Road” layer, and for maps with natural geography (rivers, mountains, coastlines) I like the “USA Topo Maps” layer. After you’ve added a base map, a listing the layer will appear in the “Table of Contents” column on the left, which lists out all of the assets available in the environment. You can toggle layers on and off by clicking the checkbox next to the layer title.        Add the static image that you want rectify by clicking on File &gt; Add Data &gt; Add Data. Navigate to the location of the image, select it, and click “Add. ” (Note: If the folder containing the image is not already available in the dropdown menu to the right of “Look in,” you may have to “connect” to the folder by clicking on the folder icon with the black “+” symbol in the toolbar to the right. Select the folder, click “OK,” and the folder should become available in the main dropdown menu. ) If you get a popup asking if you want to generate pyramids, click “No,” and if you get an alert labeled “Unknown Spatial Reference,” click “OK” (ArcMap is just reacting to the fact that the image doesn’t have existing geo-coordinates).        Enable the Georeferencing toolbar by clicking Customize &gt; Toolbars &gt; Georeferencing. The toolbar will appear at the top of the screen, and can be merged into the main top bar by dragging it upwards in the direction of the main navigation controls.        Move to the rough location of the image that’s being rectified by using the navigation controls at the left of the top toolbar to zoom the base map to the approximate location and bounds of the historical map. In this example, since the image I’m working with shows the town of Fredericksburg and the course of the Rappahannock southeast of the town, I’ll center the viewport a bit below and left of Fredericksburg, maybe zoomed back a bit to show the whole area that will be covered by the image.        Show the static image by clicking on Georeferencing &gt; Fit To Display. This just plasters the map directly on top of the base layer, using the bounds of the current viewport (set in the first step) to determine the position and scale of the image. Basically, this is just setting a crude, starting starting set of geo-coordinates that can be refined by laying down point associations.     Now, the actual rectification. All this entails is creating a series of associations (at least two, as many as ~15-20) between points on the static image and points on the real-geography base layer. As you add points, ArcMap will automatically pan, rotate, scale, and ultimately “warp” the image to match the underlying base layer.    Lay a positioning point: I like to start by picking the most obvious, central, easy-to-find point on the historical map. In this case, I’ll use the position at which the Richmond Fredericksburg Railroad crosses over the west bank Rappahannock. To lay the first point, click on the “Add Control Points” button in the Georeferencing toolbar and click at the exact position on the historical map that you want to use as the starting point. Then, without clicking down on the map viewport again, move the cursor over to the “Table of Contents” pane and check off the historical map, leaving just the base layer visible. Then, click on the location on the base layer that corresponds to the original location on the historical map. Once you’ve clicked for a second time, the dotted line between the two clicks will disappear. Display the historical map again by checking the box next to its title in the “Table of Contents. ” The image will now be anchored onto the base layer around the location of the first point association.        Lay a scaling and rotation point: Next, pick another easily-mappable point on the historical map, this time ideally near the edges of the image, or at least some significant distance from the first point. Follow the same steps of clicking on the historical map, hiding the historical map, clicking on the corresponding location on the base layer, and then re-enabling the historical map to see the effect.   At this point, you already have a minimally rectified image – the second point will both scale the image down to roughly correct proportions and rotate the image to the correct orientation. From this point forward, adding more points will make the rectification increasingly accurate and granular by “warping” the image, like a sheet of rubber, to fit the lattice of points as accurately as possible. How many points is enough? Really, it depends on the accuracy of the map and objectives of the Neatline exhibit. In this case, Hotchkiss’ map is already quite accurate, and the just first two points do a pretty good job of orienting the map and showing how it fits into the larger geography of the region. For literary and historical projects that don’t gain anything from extreme precision, a handful of points (2-5) is often sufficient. When a higher level of precision is required, though, or when the historial map is significantly inaccurate (as is the case for older maps), more points (10-20) can be necessary. It’s not an exact science – just lay points until it looks right. As you work (especially in cases where you’re laying down a lot points) experiment with different “transformation” algorithms by clicking Georeferencing &gt; Transformations and selecting one of the five options (1st Order Polynomial, 2nd Order Polynomial, etc). Behind the scenes, these algorithms represent different computational approaches to “fitting” the image based on the set of control points – some of the transformations will leave the image roughly polygonal, whereas others will dramatically “warp” the shape of the image to make it conform more accurately to the point associations. Depending on the type of image you’re working with and its accuracy relative to the base layer, different transformations will produce more or less pleasing results. For now, I’ll just leave it at 1st Order Polynomial. Once you’re done laying points, save off the image as a georeferenced . tiff file by clicking Georeferencing &gt; Rectify. As desired, change the filename and target directory, and click “Save. ” Links ArcGIS georeferencing documentationQuantum GIS georeferencing tutorial (open-source alternative to ArcMap)Georeferencing – making historic maps spatial "
        }, {
        "id": 99,
        "url": "https://neatline.org//2012/07/31/translating-neatline/",
        "title": "Translating Neatline",
        "body": "2012/07/31 - Cross-posted at the Scholars’ Lab blog. If you’re fluent in English and another language, and would love to help with the Neatline project, please consider contributing a translation for our Neatline plugins! We’re using a service called Transifex to manage translation work. To get started, just sign up for a free account on Transifex (or log in using your Twitter or Facebook account), then check out our Neatline project page. If you already see a language listed, just click on it, then request to join that language team to begin contributing. If the language you’d like to contribute doesn’t appear on the list, just click the link near the top of the languages list to “Request a new team” and we’ll add that team to the list, and add you to it. Once all that is set up, you can begin adding translations to any (or all!) of our plugins. Once you’re added to a language team, you can click on that language, and see a list of the resources (i. e. , Neatline plugins) we have available to translate. Clicking on any of the resources should bring up a modal window with various options for translating the resource, including a button to “Translate Online”. From there, you’ll be presented with a page that has the English word or phrase on one side, and a text area to contribute a translation on the other. &lt;figcaption class= wp-caption-text &gt;Translation interface on Transifex. net&lt;/figcaption&gt;&lt;/figure&gt; Translating static word strings—phrases like “Save your exhibit”, for example—are pretty straight-forward. Occasionally, though, you will run across a string that includes text like %s or %$1s. This text is a placeholder for dynamic content, generated by the Neatline plugin when used in Omeka. To translate strings with these placeholders, simply translate the other words in the string, and move the placeholder text wherever it would make sense for your translation. For example, the string “The timeline “%s” was successfully added!” is translated into Spanish as “Se agregó la secuencia “%s”!” The Omeka team also manages their translations through Transifex, and they have some nice documentation on contributing translations using the platform; if you have questions, try checking their page. Additionally, Transifex also has some nice documentation for many features of their service, including contributing translations. As translations are completed, we’ll add them to each plugin’s languages directory before each release. So if you’d like to see Neatline in a different language, please consider contributing a translation. We appreciate your help in giving Neatline a truly global reach! "
        }, {
        "id": 100,
        "url": "https://neatline.org//2012/07/30/neatline-1-0-1/",
        "title": "Neatline 1.0.1",
        "body": "2012/07/30 - Neatline 1. 0. 1 addresses a issue where the default width of the Items column in a Neatline exhibit was not correctly set upon installation. Once you download the new version and upgrade, the default width will be set correctly. Of course, this is still something you can adjust by activating the Items column, then clicking and dragging the side of the column to the width you’d like. But if you’re having trouble doing that, upgrading to 1. 0. 1 will help. You can download 1. 0. 1 from the Omeka Addons page for Neatline. Once you download and unzip the new version, just replace the files in your plugins/Neatline directory with the files you just unzipped. Once you do that, log in to your Omeka installation’s admin panel, then navigate to Settings &gt; Plugins, and click the “Upgrade” button beside your Neatline plugin. Many thanks for all the praise, feature requests, and bug reports that have come in since we first released Neatline! As always, keep sending us those through our issue tracker on Github. "
        }, {
        "id": 101,
        "url": "https://neatline.org//2012/07/19/parent-child-relationships-in-neatline/",
        "title": "Parent-child relationships in Neatline",
        "body": "2012/07/19 - One of the most powerful features in Neatline, our newly-released Omeka-based tool for geo-temporal interpretation of humanities collections, is the ability to create parent-child relationships between records in an exhibit. Any record can be the parent of any other record, and there are no limits on the depth of the nesting – a parent record can itself have a parent record, and so on and so forth. This relationship is established from the child to the parent. To set a parent record, click into the “Relations” fieldset and use the dropdown to select a record: What’s the point of this? When you set a parent record, the child automatically inherits all of the styling and visibility settings of the parent. In a nutshell, this makes it possible to create “batches” of records that share a common set of styles and phase in and out of visibility in unison. For example, imagine that you need to split the records in your exhibit into two a “blue” category and a “red” category. Instead of combing through each record and typing in the exact same lineup of styles for all the records in each of the categories, you can just create two abstract “template” records that contain the style defaults for each group and associate each of the content records with one of the templates. With six records, three blue and three red, that would look like this: Blue 1, Blue 2, and Blue 3 are children of [Blue Parent], and Red 1, Red 2, and Red 3 are children of [Red Parent]: And in the final exhibit, the colors are rendered correctly without ever having to set a single style on Blue 1, Blue 2, Blue 3, Red 1, Red 2, or Red 3: Powered by Neatline | View fullscreen This also works for the record visibility settings that control the date range on the timeline during which the a record is visible – the “Start Visible Date” and “End Visible Date” fields in the “Temporal” fieldset. In the example above, say that you want the blue points to be visible from 1900-1960, and the red points from 1940-2000. Set these visibility intervals on the parent records, and the child records will phase in and out of visibility in unison: Powered by Neatline | View fullscreen What if you need to selectively override the defaults, though? What if you want a record to inherit most style and visibility settings from upstream in the inheritance chain, but you want to adjust one or two settings to differentiate the record? For example, imagine you want one of the blue points to be yellow – but you still want it to phase in and out of view with the other blue points. Instead of having to break away the record and re-set all of the settings just in order to make the color change, you can just directly change the color setting on the record, and all of the other unchanged settings will continue to inherit from upwards in the chain: Powered by Neatline | View fullscreen Neatline always tries to find record-specific value first, meaning that an inherited value can always be clobbered by a locally-set value (think of it as !important in CSS). If Neatline doesn’t find a record-specific value, it starts to traverse up the inheritance chain to the parent record(s), and stops when it finds a record-specific value on one of the parents. If none of the parents have a value for the attribute in question, then Neatline falls back on the exhibit default values, which can be configured in the “Map Settings” dropdown tab. Parent records in action How does this work with real content? The Battle of Chancellorsville demo exhibit makes heavy use of parent records. This is a complex exhibit with a lot of moving parts. There are three separate base maps, one for each of the three days of the battle – May 2, May 3, and May 4, 1863. Each of the maps has a large collection of spatial annotations and numbered waypoints that are relevant to just one of the maps – as the map switches out in response to the position of the timeline, the corresponding set of annotations and waypoints needs to phase into view at the same time. Meanwhile, the spatial vectors can be broken down into categories that should share similar styles – the Union and Confederate lines should all share the same shades of blue and red. You could just go through and directly set the correct colors and visibility dates on each individual record. This is labor-intensive, though, and it tends to lock you into design decisions that you make at the beginning of the process – if you change your mind down the road and want to adjust the Union blue, you’d have to work through 50-odd records and update them individually. Parent records make it possible to formalize the conceptual relationships and manipulate the groupings in bulk – once the correct inheritance chain is set up, you can set the style and visibility settings a single time at the top of the stack and the settings will cascade downwards to all of the children. For this exhibit, the inheritance structure looks like this: &lt;/p&gt;&lt;p&gt;&lt;strong&gt;May 2, 1863&lt;/strong&gt; (visible: May 2 - May 3)&lt;br /&gt;--- &lt;strong&gt;[may 2 condeferate lines]&lt;/strong&gt; (color: #b52f2f)&lt;br /&gt;-------- May annotation 1 &lt;span style= color:gray &gt;(visible: May 2 - May 3; color: #b52f2f)&lt;/span&gt;&lt;br /&gt;-------- May annotation 2 &lt;span style= color:gray &gt;(   )&lt;/span&gt;&lt;br /&gt;-------- May annotation 3 &lt;span style= color:gray &gt;(   )&lt;/span&gt;&lt;br /&gt;-------- (. . . )&lt;br /&gt;--- &lt;strong&gt;[may 2 union lines]&lt;/strong&gt; (color: #093696)&lt;br /&gt;-------- May annotation 4 &lt;span style= color:gray &gt;(visible  May 2 - May 3; color: #093696)&lt;/span&gt;&lt;br /&gt;-------- May annotation 5 &lt;span style= color:gray &gt;(   )&lt;/span&gt;&lt;br /&gt;-------- May annotation 6 &lt;span style= color:gray &gt;(   )&lt;/span&gt;&lt;br /&gt;-------- (. . . )&lt;/p&gt;&lt;p&gt;&lt;strong&gt;May 3, 1863&lt;/strong&gt; (visible: May 3 - May 4)&lt;br /&gt;--- &lt;strong&gt;[may 3 condeferate lines]&lt;/strong&gt; (color: #b52f2f)&lt;br /&gt;-------- May annotation 7 &lt;span style= color:gray &gt;(visible: May 3 - May 4; color: #b52f2f)&lt;/span&gt;&lt;br /&gt;-------- May annotation 8 &lt;span style= color:gray &gt;(   )&lt;/span&gt;&lt;br /&gt;-------- May annotation 9 &lt;span style= color:gray &gt;(   )&lt;/span&gt;&lt;br /&gt;-------- (. . . )&lt;br /&gt;--- &lt;strong&gt;[may 3 union lines]&lt;/strong&gt; (color: #093696)&lt;br /&gt;------ May annotation 10 &lt;span style= color:gray &gt;(visible: May 3 - May 4; color: #093696)&lt;/span&gt;&lt;br /&gt;------ May annotation 11 &lt;span style= color:gray &gt;(   )&lt;/span&gt;&lt;br /&gt;------ May annotation 12 &lt;span style= color:gray &gt;(   )&lt;/span&gt;&lt;br /&gt;------ (. . . )&lt;/p&gt;&lt;p&gt;&lt;strong&gt;May 4, 1863&lt;/strong&gt; (visible: May 4 - May 5)&lt;br /&gt;--- &lt;strong&gt;[may 4 condeferate lines]&lt;/strong&gt; (color: #b52f2f)&lt;br /&gt;-------- May annotation 13 &lt;span style= color:gray &gt;(visible: May 4 - May 5; color: #b52f2f)&lt;/span&gt;&lt;br /&gt;-------- May annotation 14 &lt;span style= color:gray &gt;(   )&lt;/span&gt;&lt;br /&gt;-------- May annotation 15 &lt;span style= color:gray &gt;(   )&lt;/span&gt;&lt;br /&gt;-------- (. . . )&lt;br /&gt;--- &lt;strong&gt;[may 4 union lines]&lt;/strong&gt; (color: #093696)&lt;br /&gt;-------- May annotation 16 &lt;span style= color:gray &gt;(visible: May 4 - May 5; color: #093696)&lt;/span&gt;&lt;br /&gt;-------- May annotation 17 &lt;span style= color:gray &gt;(   )&lt;/span&gt;&lt;br /&gt;-------- May annotation 18 &lt;span style= color:gray &gt;(   )&lt;/span&gt;&lt;br /&gt;-------- (. . . )&lt;/p&gt;&lt;p&gt; The top-level visibility dates are set on the three records that house the base maps. Under each of the three map records, abstract style records define the colors and opacities for the Union and Confederate lines. The actual content records then inherit from these records, receiving both the top-level visibility parameters on the map records and the styles on the abstract records. Now, there is some duplication of content here – the colors for Union blue and Confederate red have to be set separately in each of the three sets of abstract styling records. This is because all of the styles/visibilities on record can only be a part of a single inheritance chain, making it necessary to “split” each of the three chains under the top-level map records. Originally, I toyed around with the idea of making it possible to create “style-specific” inheritance chains – so, for example, a record could inherit its fill color from one record, its line width from another, its visibility from another, etc. In the end, though, this would have required a large amount of added UI overhead, and the same results can be achieved with a minimal amount of extra work with the technique used here. "
        }, {
        "id": 102,
        "url": "https://neatline.org//2012/07/19/neatline-and-the-framework-challenge/",
        "title": "Neatline and the framework challenge",
        "body": "2012/07/19 - With the first public release of Neatline out the door, I’ve had the chance to take a short break from programming and think back over the nine-month development cycle that led up to the launch. In retrospect, I think that a lot of the exciting challenges we ran up against – the big, difficult questions about what to program, as opposed to how to program – emerged from tensions that are inherent in the task of creating frameworks as opposed to conventional applications. What’s a framework? As an experiment, I’ll define the term broadly to mean applications that make it possible to create things, as opposed to applications that make it possible to accomplish tasks. Frameworks are generative in a way that normal applications are not. Instead of controlling systems, crunching numbers, automating processes, boosting efficiency, or providing entertainment, frameworks are set apart by the fact that the allow the user to spawn off new things that are independent of the software itself. Microsoft Word is used to create documents; WordPress is used to create blogs and blog posts; Drupal is used to create websites; Ruby on Rails is used to build web applications; Illustrator is used to create vector graphics; Maya is used to create 3d models and animations. Omeka and Neatline fit straightforwardly into this definition. Omeka is used to build online digital collections; Neatline, a framework-within-a-framework built on top of Omeka, is used to create interactive maps and timelines. In each case, the final unit of analysis is some sort of discrete, addressable thing that is generated with the assistance of the software. It can be viewed, visited, or printed. Frameworks empower users to create things that would be difficult or completely impossible to create without the assistance of the software. The paradox, though, is that frameworks have to simultaneously constrict the user’s agency in the act of expanding it. Barring some kind of mythological ur-framework that would allow for direct, unmediated, and unbounded realization of thought (Prospero’s book of magic), all frameworks, whether implicitly or explicitly, have to define a range of final outputs that will be “supported” by the software. In practice, this means paring down the supported outputs to a vanishingly small subset of the original possibility space. Frameworks are defined as much by what they disallow as by what they allow. For the developer, deciding on the “range” of the framework is a difficult and sometimes agonizing process because it involves a fundamental tradeoff between power and accessibility – and, by extension, the size of the potential audience. As a framework becomes more powerful and allows a wider range of possible outputs, it also becomes more complex and locks out users who aren’t willing to invest the effort to become proficient with the tool. As a framework becomes more narrow and focused, a larger number of people will be able and willing to use it, but the diversity of the final outputs drops, and the tool becomes suitable for a much smaller range of use cases. It’s a zero-sum game. Over the course of the last couple months, I’ve realized that this opposition between power and ease-of-use provides an interesting vocabulary for defining Neatline and situating it in the ecosystem of existing geospatial tools. Up until now, it seems to me that existing frameworks have clustered around the two ends of the power / ease-of-use spectrum. Consumer web applications like the Google mapmaker allow the user to drop pins and annotate them with short captions. This is delightfully easy, but all of the end-products look the same, and the tool doesn’t really provide a critical mass of flexibility and the opportunity for real intellectual ownership that’s required for serious scholarly use. Meanwhile, at the other end of the spectrum, desktop GIS applications like ArcMap provide an incredibly powerful and feature-rich platforms for analyzing geospatial data and creating visualizations. For projects that have access to custom software development, programming libraries like OpenLayers, Leaflet, PolyMaps, and Timeglider provide flexible, highly-customizable toolkits for creating interactive maps and timeline – but only at the level of code. There’s been an underpopulated zone in the middle the spectrum, though – not many spatio-temporal tools have tried to more evenly balance power and accessibility. Neatline tries to land in a “goldilocks” zone between the two poles. It tries to be simple enough out-of-the-box that it can be used by a large majority of scholars and students who do not have programming experience or advanced GIS expertise, but still complex enough to allow for significant diversity in the structure and style of the final output. This means, of course, that Neatline could be more powerful and could be easier to use. My argument, though, is that it couldn’t both – at least, not without tripping over itself and breaking apart into incoherence. Instead of choosing one pole at the expense of the other, we decided to make a studious attempt to balance the two. This is difficult to do – perhaps more difficult than committing wholesale to one or the other, which can often have the effect of locking in a cascading series of almost automatic design decisions leading towards a more singular objective. Building “middle-ground” frameworks requires a constant (re-)calibration of the feature set over the course of the development process, a sort of gyroscopic vigilance to keep the software perched in the tricky zone between flexibility and accessibility. Like all real challenges, though, this one was also fantastically exciting to tackle. Now that Neatline is out in the wild, I can’t wait to see what people create with it. "
        }, {
        "id": 103,
        "url": "https://neatline.org//2012/07/02/announcing-neatline/",
        "title": "Announcing Neatline!",
        "body": "2012/07/02 - What do you get when you cross archives and artifacts with timelines, modern and historical maps, and an appreciation for the interpretive aims of humanities scholarship? Today, the Scholars’ Lab is proud to announce the launch of Neatline, our set of Omeka plugins for hand-crafted geo-temporal visualization and interpretation. Here, you can download the 1. 0 software, see sample exhibits or play in the sandbox, and read more about the project, including news and history. Neatline is a geotemporal exhibit-builder that allows you to create beautiful, complex maps and narrative sequences from collections of archives and artifacts, and to connect your maps and narratives with timelines that are more-than-usually sensitive to ambiguity and nuance. In other words, Neatline lets you make hand-crafted, interactive stories as interpretive expressions of an archival or cultural heritage collection. Every Neatline exhibit can be your own close reading of a humanities collection — expressed in the visual vernacular. Ours is a small-data approach in a “big data” world. Stay tuned to the Scholars’ Lab blog and to this site for a series of posts and screencasts to be shared over the course of the next two weeks. We’ll be providing support for this open-source software on the Omeka forums and dev list. "
        }, {
        "id": 104,
        "url": "https://neatline.org//2012/06/30/neatline-sneak-peek/",
        "title": "Neatline Sneak-Peek",
        "body": "2012/06/30 - The R&amp;D team here at the lab has been quiet over the course of the last couple weeks, but there’s been a flurry of activity under the surface – we’ve been hard at work putting the finishing touches on Neatline, a geotemporal exhibit-building framework that makes it possible to plot archival collections, narratives, texts, and concepts on interactive maps and timelines. Neatline is built as a collection of plugins for Omeka, a digital archive-building framework developed by our partners at the Roy Rosenzweig Center for History and New Media at George Mason University. If you already have an Omeka collection, Neatline provides a deeply integrated, plug-and-play mapping solution that lets you create interpretive views on your archive. If you don’t have an Omeka collection, though (or if it doesn’t make sense represent your material as a collection of archival objects), Neatline can also be used as an effectively standalone application from within the Omeka administrative interface. If you haven’t been following the project, check out the podcast of the workshop that Eric Rochester and I gave at THATCamp Virginia 2012 and read the announcement about our partnership with RRCHNM.    So, what kinds of things can you do with Neatline? Here are a few:  Create records and plot them on interlinked maps and timelines with complex vector drawings, points, and spans. Set colors, opacities, line thicknesses, point radii, and gradients.  Add popup bubbles and define interactions among the map, timeline, and a record-browser viewport, which can display everything from short snippets and captions to long-format interpretive prose.  Connect your exhibits with web map services delivered by Geoserver, which makes it possible to create rich displays of historical maps.  Drag the viewports around to create custom layouts.  Set visibility intervals on a per-item basis, making it possible to create complex time-series animations.  Create hierarchical relationships among items, making it possible to curate &#8220;batches&#8221; of elements in an exhibit that can be manipulated as a group.  (Using the Neatline Editions plugin, which is still in alpha and won&#8217;t be ready until later in the summer) Create interactive editions of texts by connecting individual paragraphs, sentences, or words with locations on maps and timelines. Watch this space in the first week of July for the full public release with the dedicated website, code, documentation, and a hosted “sandbox” version of the application that will let you register and experiment with creating exhibits before downloading the software. Until then, here are a handful of screenshots from some of the demo exhibits we’re working on:     "
        }, {
        "id": 105,
        "url": "https://neatline.org//2012/05/23/749/",
        "title": "Neatline workshop podcast",
        "body": "2012/05/23 - On April 20, 2012, software developers David McClure and Eric Rochester gave a workshop for interested attendees of THATCAmpVA, our annual digital humanities un-conference. The workshop introduced Neatline and updated participants on project developments. An audio recording is available on the Scholars’ Lab blog. You can listen to (or subscribe to) our podcasts on the SLab blog, or on iTunesU. "
        }, {
        "id": 106,
        "url": "https://neatline.org//2011/02/15/scholars-lab-and-chnm-partner-on-omeka-neatline/",
        "title": "Scholars&#8217; Lab and the Center for History and New Media Partner on &#8220;Omeka + Neatline&#8221;",
        "body": "2011/02/15 - The Scholars’ Lab at the University of Virginia Library and the Center for History and New Media (CHNM) at George Mason University, are pleased to announce a collaborative “Omeka + Neatline” initiative, supported by $665,248 in funding from the Library of Congress. The Omeka + Neatline project’s goal is to enable scholars, students, and library and museum professionals to create geospatial and temporal visualizations of archival collections using a Neatline toolset within CHNM’s popular, open source Omeka exhibition platform. Neatline, a “contribution to interpretive humanities scholarship in the visual vernacular,” is a project of the UVa Library Scholars’ Lab, originally bolstered by a Start-Up Grant from the Office of Digital Humanities at the National Endowment for the Humanities. Omeka is an award-winning web-publishing platform for the display of cultural heritage and scholarly collections and exhibits, funded by the Institute of Museum and Library Services, Alfred P. Sloan Foundation, Andrew W. Mellon Foundation, and Samuel H. Kress Foundation. This two-year initiative will allow CHNM and the Scholars’ Lab to expand and regularize a partnership that developed informally between the two centers over the course of the past year. Collaboration has already resulted in improvements to the core functionality of Omeka by CHNM and has led the Scholars’ Lab to produce a number of prototype plugins making Omeka a more attractive and viable option for scholarly partnerships with larger libraries and cultural heritage institutions. These include: improved data import (including EAD, a common archival standard); Solr-powered searching and browsing; and Fedora-based repository services. Further development will improve existing plugins, add preservation workflows, and refine the Neatline toolset for integration and sophisticated editing and scholarly annotation of historical maps, GIS layers, and timelines. Enhancements to Omeka’s core APIs, improved documentation, regular “point” releases, and a new Exhibit Builder will strengthen Omeka’s already large and robust user and developer communities. Omeka + Neatline is one of six contract awards made by the Library of Congress in a program that aims both to improve the Library’s own content management and content delivery infrastructure and to contribute to collaborative knowledge sharing among broader communities concerned with the sustainability and accessibility of digital content. In July of 2010, the Library of Congress targeted approximately $3,000,000 toward Broad Agency Announcements covering three areas of research interest related to these goals. Technical proposals were openly solicited from expert, multi-disciplinary communities in both academic and commercial settings in three areas: Ingest for Digital Content, Data Modeling of Legislative Information, and Open Source Software for Digital Content Delivery. In addition to guiding software development work at the Scholars’ Lab and CHNM, project directors Tom Scheinfeldt and Bethany Nowviskie will use the Omeka + Neatline project as an opportunity to document and disseminate a model for open source, developer-level collaborations among library labs and digital humanities centers. "
        }, {
        "id": 107,
        "url": "https://neatline.org//2010/06/30/wms-vs-tile-caching/",
        "title": "WMS vs. tile-caching",
        "body": "2010/06/30 - [This is a re-posting of content from the Scholars’ Lab blog by Adam Soroka. ] In our work on Neatline, we have made a deliberate choice to start by constraining ourselves to map-sources that are quickly and easily provided through WMS. This leaves out (for now) two popular sources of map imagery; Google Maps and Open Street Map. I’m going to explain why we made that choice, and why, when we do come to make these sources usable with Neatline, we will do so with great care and with an eye to scholarly method. All two-dimensional maps (as opposed to globes) are projected. That is, the curved three-dimensional surface of the Earth is transformed onto a flat two-dimensional surface. This can be done in an infinite variety of ways, many of which have been mathematically characterized and named by cartographers, for whom they are necessary tools. We must note, however, that no such transform can obtain a perfect representation of a section of the Earth. The mapmaker must choose which qualities to preserve and in what measures. Is it more important to provide an accurate depiction of relative areas or of relative lengths? Is the area around Greenland to be kept in the focus of accuracy, or that around New Zealand? Each map therefore carries with it from its creation certain choices like these, part of the arguments the map makes about the world by its very construction. We chose WMS on which to start building our tools because, amongst other reasons, it allows for the transmission of projection information as part of its operation. This fact allows us to produce imagery from historical maps (themselves in any number of projections) and maintain the original choices the mapmaker made. Google Maps and Open Street Map are not WMS sources. They can be described as tile caches, huge reservoirs of rendered imagery. As such, they offer their own choices about how the world is to be projected. (Google’s choice has become so closely associated with Google that it is known widely as “the Google projection”. ) Now we come to an important technical distinction; WMS services are able (depending on the capabilities of the specific software in use) to reproject their contents. That is, in response to a specific request for imagery, they can produce the imagery in a projection different from the one in which it was stored. GeoServer, the software we are using for Neatline, has a library of thousands of projections to which users can add more as desired. This allows us to take imagery from a WMS source and lay it under a historical map layer while maintaining the original projection for that of the map as a whole. Tile caches, by and large, do not allow for this. (Google Maps offers its one projection, and Open Street Map offers two. ) This means that in order to lay historical map imagery over a layer from one of these sources, we would have to reproject the foreground (historical imagery) overriding the choices of the mapmaker and introducing additional choices of our own about what facets of the geographies at stake are to be preserved and which abandoned. (Neogeographers will remark that georectifying a digital image introduces similar issues. This is true, but unavoidable for our purposes. We would like to avoid compounding the matter in a way that is subtle and hard to detect. ) We are working out means by which we can provide the undeniable utility of popular tilecaching services in a way that is respectful of the historical context and story of map artifacts. Until we do, we will continue to concentrate on the more flexible and sophisticated apparatus provided by WMS. "
        }, {
        "id": 108,
        "url": "https://neatline.org//2010/04/14/fringe-benefits/",
        "title": "Fringe benefits",
        "body": "2010/04/14 - A lot of extra (detachable-from-Neatline) goodness is resulting from our decision to reconceive this project as an approach rather than a stand-alone tool — and therefore as a collection of Omeka plugins. One example of this is the recent release for testing, by Scholars’ Lab R&amp;D, of a SIMILE Timeline plugin for Omeka. Wayne Graham, who heads our R&amp;D unit, takes the opportunity to describe the creation process on the Scholars’ Lab blog, in a very useful post (very creatively) titled, “Omeka Timeline Plugin. ”– Bethany "
        }, {
        "id": 109,
        "url": "https://neatline.org//2010/03/04/omeka-plugins-burning-like-meteors/",
        "title": "Omeka plugins burning like meteors",
        "body": "2010/03/04 - [As Adam Soroka described in his last post, we made a shift to Omeka early in the Neatline project in order to speed development and put our work in the hands of end users already thinking about the relationship of archival collections to scholarly analysis and presentation. Omeka’s plugin architecture also allows us to share individual components of the project (such as EAD import or robust SIMILE Timeline integration) with people who might not be interested in the whole geospatial workflow of Neatline proper, and to capitalize on other Omeka-related work happening in the Scholars’ Lab. Here, Adam gives a quick update on work in progress. In a future post I’ll describe the kinds of iterative scholarly work and geo-temporal interpretive activity that Neatline is designed to promote. – Bethany] The Neatline technical crew is hurtling onwards in our Omeka plugin rampage. Ethan Gruber is now finishing work on his EAD Importer. This will allow folks to bring an Encoded Archival Description XML finding aid to an Omeka instance and have the documents in that archival description sprout right into the Omeka field as manipulable, annotate-able, curate-able items. We’ve successfully applied it to our two test cases (H. P. Lovecraft and Jedediah Hotchkiss) and are working through other examples. I have been madly thrashing a geospatially-enabled duo of plugins: Neatline Maps and Neatline Features. Neatline Maps connects the powerful open-source Web GIS engine GeoServer to Omeka. It permits a user to upload georeferenced images and have them immediately available as interactive maps. Neatline Features allows users to use a simple but powerful graphical editor built on the OpenLayers library to attach sophisticated georeferenced shape information to Omeka items. This could include anything from an outline of a building to the path taken by an army brigade through a battle. Lastly, we’ve participated in CHNM‘s Omeka plugin rush and written a new Timeline plugin to replace an obsolete design. We hope to have it published within a few days. We’re well on our way to our expected May public release. — Adam "
        }, {
        "id": 110,
        "url": "https://neatline.org//2009/12/15/an-update-the-shift-to-omeka/",
        "title": "An update: the shift to Omeka",
        "body": "2009/12/15 - Over the past few months, we have drastically altered the technical undergirding of Neatline for three reasons. Our new plan will produce tools that more people will be able to use. The new style of development will permit faster, better work. Lastly, we will be developing in concert with a much larger community. Our new technical plan replaces a large number of components with one: Omeka. Omeka is a software framework for collections-based research and Web-based exhibitions created by historians at George Mason University. It will provide us several of the key technical facilities we require for our work. For example, the suite of simple Web-forms to facilitate the ingestion of EAD documents and historical raster-imagery data that we have undertaken to create are now backed by Omeka, which offers generic forms for similar needs that can be customized to our specific plan. It will take only a few weeks to create them by building on Omeka, whereas it would have taken several months to do “from scratch”. By creating our new software tools as “plugins” to the Omeka machinery, we are taking advantage of many such efficiencies. What is more, we are allowing for our future user-community to use our Neatline software in conjunction with a large and growing suite of other Omeka plugins for such tasks as media playback, sophisticated indexing, inter al. Our software development effort is being partially hosted by the Omeka development group at GMU, which not only eliminates the small overhead we would incur to host it locally, but provides us with visibility in a large a growing community of Omeka users. We have accomplished several milestones in recent weeks. An Omeka plugin for managing georeferenced historic maps has been created and made public to the Omeka community. It has garnered considerable interest. We have accomplished much of the modeling and basic engineering for another Omeka plugin which will manage geographic features. We are currently working on a third which will accomplish the import of EAD into a Neatline project. This component, in particular,will be useful to many people who have no special interest in maps or geography. It will provide a useful and simple way to open archives onto the Web and create curated exhibitions of archival material. — Adam "
        }, {
        "id": 111,
        "url": "https://neatline.org//2009/12/01/neatline-notes/",
        "title": "Neatline notes",
        "body": "2009/12/01 - I’ve called Neatline, the Digital Humanities Start-Up project Adam Soroka and I began developing in September, a “contribution to interpretive humanities scholarship in the visual vernacular. ” Huh? This project will allow scholars (and other stewards of cultural heritage) to create Web-based geospatial and temporal visualizations that build on the rich EAD metadata libraries produce in describing their archival collections and making them more discoverable — but the crucial twist is that we didn’t want to think of our Neatline visualizations as products of the metadata. They’re not brain-dead algorithmic output or some kind of thoughtless expression of the archivist’s (nuanced, but necessarily broad) stance toward historical or literary documents of interest. (Yes, I’m asking for it; bring it on!) In other words, Neatline isn’t about the parsing of placenames and automated population of timelines with data. Rather, we’ve conceived this tool (really, as development proceeds, this approach, because Neatline is emerging as an arrangement of instruments and an attitude toward their use) as a kind of playspace for the scholarly interpretative act. In future posts, we’ll describe our development effort and I’ll delve a little into the conceptual background for Neatline in the Temporal Modelling project I undertook several years ago with Johanna Drucker. In the meantime, you can read about how we’re employing the Omeka plugin framework as a way to handle GIS services for scanned historical maps on the ScholarsLab. org project pages for Neatline-in-progress and our larger Omeka plugin work, or you can check out our dedicated project blog. — Bethany "
        }, {
        "id": 112,
        "url": "https://neatline.org//2009/08/20/and-were-off/",
        "title": "And we&#8217;re off!",
        "body": "2009/08/20 - The public announcement has been made, so Adam Soroka and I can now share the news that we’ve been funded by the NEH’s Office of Digital Humanities and the IMLS to pursue our “Neatline” project.   We’ll begin working again in September in earnest, on a tool that Adam prototyped in support of a code4lib pre-conference workshop he gave earlier this year.   Look to this site for updates along the way, and for a full description of the project (including notes on our test cases — horror writer H. P. Lovecraft and Civil War mapmaker Jedediah Hotchkiss — and our advisory board and collaborators) to be posted soon.  — Bethany "
        }];

    var idx = lunr(function () {
        this.ref('id')
        this.field('title')
        this.field('body')

        documents.forEach(function (doc) {
            this.add(doc)
        }, this)
    });
    function lunr_search(term) {
        document.getElementById('lunrsearchresults').innerHTML = '<ul></ul>';
        if(term) {
            document.getElementById('lunrsearchresults').innerHTML = "<p>Search results for '" + term + "'</p>" + document.getElementById('lunrsearchresults').innerHTML;
            //put results on the screen.
            var results = idx.search(term);
            if(results.length>0){
                //console.log(idx.search(term));
                //if results
                for (var i = 0; i < results.length; i++) {
                    // more statements
                    var ref = results[i]['ref'];
                    var url = documents[ref]['url'];
                    var title = documents[ref]['title'];
                    var body = documents[ref]['body'].substring(0,160)+'...';
                    document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></a></li>";
                }
            } else {
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>No results found...</li>";
            }
        }
        return false;
    }
    </script>
  </head>
  <body>
    <a href="#main" id="skipnav">Skip to main content</a>
    <header role="banner">
<div class="flexnav-wrapper">
	<div class="flexnav-main">
		<div class="flexnav__home-icon">
			<a href="https://neatline.org/" title="Neatline"> 
				<img class="logo" src="https://neatline.org//assets/images/neatline-logo-rgb.png" alt="Neatline"/>
			</a>  
		</div>

		
		<ul class="flexnav-main-grid">
			
			
			<li class="flexnav__item"><a href="/about/">What is Neatline?</a></li>
			

			

			
			
			<li class="flexnav__item"><a href="/showcase/">Showcase</a></li>
			

			

			
			
			<li class="flexnav__item"><a href="/plugins/">Add-Ons</a></li>
			

			

			
			

			
			<li class="flexnav__item dropdown" id="dropdown">
				<a class="dropdown-toggle" href="#" id="navbarDropdownMenuLink" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">User Guides<span>&rsaquo;</span></a>
				<div class="dropdown-menu" aria-labelledby="navbarDropdownMenuLink">
					
					<a class="dropdown-item" href="/docs/">Neatline Classic</a>
					
					<a class="dropdown-item" href="/docs-s/">Neatline S</a>
					
					<a class="dropdown-item" href="/use-cases/">Use Cases</a>
					
				</div>
				</li>  
			

			
			
			<li class="flexnav__item"><a href="/news/">News</a></li>
			

			

			
			
			<li class="flexnav__item"><a href="/publications/">Publications</a></li>
			

			

			
			
			<li class="flexnav__item"><a href="/credits/">Credits</a></li>
			

			

			
			
			<li class="flexnav__item"><a href="/search/">Search</a></li>
			

			

			
			<li class="flexnav__more-menu">
				<div class="flexnav-more__prompt" aria-label="More menu items">More<span>&rsaquo;</span></div>
				<ul class="flexnav-more__wrapper">
				
				
				<a href="/about/"><li class="flexnav-more__item">What is Neatline?</li></a>
					
							
				
				
				<a href="/showcase/"><li class="flexnav-more__item">Showcase</li></a>
					
							
				
				
				<a href="/plugins/"><li class="flexnav-more__item">Add-Ons</li></a>
					
							
				
					
				
				
					
					<a href="/docs/" id="subnav">
						<li class="flexnav-more__item">User Guides: Neatline Classic</li>
					</a>
					
					<a href="/docs-s/" id="subnav">
						<li class="flexnav-more__item">User Guides: Neatline S</li>
					</a>
					
					<a href="/use-cases/" id="subnav">
						<li class="flexnav-more__item">User Guides: Use Cases</li>
					</a>
					
				</li>
							
				
				
				<a href="/news/"><li class="flexnav-more__item">News</li></a>
					
							
				
				
				<a href="/publications/"><li class="flexnav-more__item">Publications</li></a>
					
							
				
				
				<a href="/credits/"><li class="flexnav-more__item">Credits</li></a>
					
							
				
				
				<a href="/search/"><li class="flexnav-more__item">Search</li></a>
					
							
				
				</ul>
			</li>
		</ul>
		
		
	</div> <!-- end content -->
</div> 
<!-- end wrapper -->
</header>
    <div class="wrapper">
    <main id="main" class="main-content" role="main" >
        <header class="post-header">
          <h1>Search</h1>
        </header>
        <article class="post-content">
        <div class="container">
<form class="input-group mb-3" onSubmit="return lunr_search(document.getElementById('lunrsearch').value);">
    <label class="sr-only" for="lunrsearch">Site Search</label>
    <input type="text" class="form-control" id="lunrsearch" name="q" value="" placeholder="Search neatline.org" aria-label="Search neatline.org" aria-describedby="button-search"/>
    <div class="input-group-append">
        <input class="btn btn-outline" type="submit" value="search" id="button-search">
    </div>
</form>
<div id="lunrsearchresults">
    <ul></ul>
</div>
</div>
        </article>
    </main>
    </div>
    <footer role="contentinfo">
      
 <div class="container">
    <div class="row ">
      <div class="col-md-6">
        <p class="fs-2">
            Neatline is a project of the <a href="https://scholarslab.lib.virginia.edu/">Scholars' Lab</a> at the University of Virginia Library. It has benefited from the generous support of the <a href="http://lib.virginia.edu">UVa Library</a>, the <a href="http://neh.gov">National Endowment for the Humanities</a>, the <a href="http://imls.gov">Institute of Museum and Library Services</a>, and the <a href="http://loc.gov">Library of Congress</a>.
        </p>
      </div>
      <div class="col">
        <ul class="fs-2 list-style-none">
          <li><a href="https://forum.omeka.org/">Contact Us</a></li>
          <li><a rel="license" class="license" href="http://creativecommons.org/licenses/by/3.0/">CC-BY 3.0</a></li>
        </ul>
      </div>
      <div class="col">
          <a href="https://scholarslab.lib.virginia.edu/" id="slab-link" title="Scholars Lab logo link" aria-label="Scholars Lab logo link">
          <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
          viewBox="0 0 438.9 87.8" style="enable-background:new 0 0 438.9 87.8;" xml:space="preserve">
         <path d="M29.3,63.1c0,12.3-7.7,20.5-23.1,24.6l-5.1-11c4.8-1.4,8.2-2.8,10.4-4.3c3.4-2.4,5-5.5,5-9.3c0-2.9-1.4-6.5-4.3-10.7
           C9.6,48.5,7,44.6,4.4,40.7c-2.9-5-4.3-9.9-4.3-14.7c0-6.2,2.5-11.7,7.6-16.7C12.4,4.6,18,1.5,24.7,0l3.8,11.8
           C18.1,14.6,13,19.3,13,25.9c0,3.5,1.4,7.5,4.3,11.8c2.6,3.8,5.2,7.6,7.8,11.4C27.9,54,29.3,58.6,29.3,63.1L29.3,63.1z"/>
         <path d="M61.2,85.1c-3.6,1.1-6.2,1.7-7.8,1.7c-7.2,0-12.8-3.4-16.8-10.2c-4-6.8-6-16.4-6-28.7c0-12.3,2-21.9,6-28.7
           c4-6.8,9.6-10.2,16.8-10.2c1.6,0,4.2,0.6,7.8,1.7L58,19.7c-1.6-0.6-3.1-0.8-4.5-0.8c-7.6,0-11.4,9.7-11.4,29c0,19.3,3.8,29,11.4,29
           c1.5,0,3-0.3,4.5-0.8L61.2,85.1z"/>
         <path d="M100.2,85.9H88.7V55.3H77.6v30.7H66.1V55.3h-3.9v-9.9h3.9V9.8h11.5v35.6h11.1V9.8h11.5C100.2,9.8,100.2,85.9,100.2,85.9z"
           />
         <path d="M140.4,47.8c0,25.9-5.8,38.9-17.5,38.9c-11.7,0-17.6-13-17.6-38.9c0-12.6,1.1-21.8,3.3-27.8c2.7-7.4,7.5-11.1,14.3-11.1
           c6.6,0,11.3,3.7,14.1,11.1C139.3,26.1,140.4,35.4,140.4,47.8L140.4,47.8z M129,47.8c0-19.3-2.1-29-6.2-29c-4.1,0-6.2,9.7-6.2,29
           c0,19.3,2,29,6.2,29C127,76.8,129,67.2,129,47.8L129,47.8z"/>
         <path d="M169.4,85.9h-23.1V9.8h11.5V76h11.6V85.9z"/>
         <path d="M213.2,85.9h-11.9l-1.3-6.8H189l-1.3,6.8h-11.9l1.5-6.8h-4.5l2.3-9.9h4.4l13.5-61.1h3.3L213.2,85.9z M198,69.2l-3.5-18.9
           l-3.7,18.9H198z"/>
         <path d="M248.5,83.7l-11.2,3.4l-10.6-31.2v30h-11.5V9.8h11.5c6.7,0,11.8,2.5,15.3,7.4c3.2,4.5,4.7,10.5,4.7,18.1
           c0,8.1-2.5,14.7-7.6,20L248.5,83.7z M234.8,35.3c0-10.4-2.7-15.6-8.1-15.6v32.6c2.4,0,4.4-1.6,5.9-4.7
           C234.1,44.4,234.8,40.3,234.8,35.3L234.8,35.3z"/>
         <path d="M276,64.9c0,10.8-6.9,18.1-20.6,21.8l-4.5-9.7c4.2-1.2,7.3-2.5,9.2-3.9c3-2,4.5-4.8,4.5-8.2c0-2.6-1.3-5.8-3.8-9.5
           c-2.3-3.5-4.7-6.9-7-10.4c-2.5-4.5-3.8-8.8-3.8-13.1c0-5.5,2.2-10.5,6.7-14.9c4.2-4.1,9.2-6.9,15.1-8.2l3.4,10.5
           c-9.2,2.5-13.7,6.7-13.7,12.5c0,3.1,1.2,6.6,3.7,10.5c2.3,3.3,4.7,6.7,7,10.1C274.8,56.8,276,60.9,276,64.9L276,64.9z"/>
         <path d="M298.9,3.7l-12.2,29.8l-6.8-2l6.8-31.4L298.9,3.7z"/>
         <path d="M357.1,85.9h-26V0.5h12.8v74.3h13.2L357.1,85.9L357.1,85.9z"/>
         <path d="M401.6,85.9h-11.9l-1.3-6.8h-10.9l-1.3,6.8h-11.9l1.5-6.8h-4.5l2.3-9.9h4.4l13.5-61.1h3.3L401.6,85.9z M386.4,69.2
           l-3.5-18.9l-3.7,18.9H386.4z"/>
         <path d="M438.9,66.1c0,6.3-1.7,11.1-5,14.6c-3.5,3.5-8.6,5.3-15.3,5.3h-11.5V9.8h11.5c6.6,0,11.7,2,15.3,6c3.3,3.8,5,9.2,5,16
           c0,8.6-2.2,14.4-6.7,17.4C436.6,52.9,438.9,58.6,438.9,66.1L438.9,66.1z M427.8,31.8c0-8-3.1-12.1-9.2-12.1v25.6c3.2,0,5.5-1,7-3.1
           C427,40.2,427.8,36.7,427.8,31.8L427.8,31.8z M427.8,66.1c0-7.2-3.1-10.8-9.2-10.8V76C424.7,76,427.8,72.7,427.8,66.1L427.8,66.1z"
           />
       </svg>
      </a>
      </div>
      <div class="col to-top">
        <a class="fs-2" href="#main" aria-label="Back to top">
          <svg id="Capa_1" data-name="Capa 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 17.39 32.63"><defs></defs><title>thin-up-arrow-white</title><path class="cls-1" d="M8.68,0a.5.5,0,0,1,.5.5V32.13a.5.5,0,0,1-.5.5.5.5,0,0,1-.5-.5V.5A.5.5,0,0,1,8.68,0Z"/><path class="cls-1" d="M8.68,0h0A.49.49,0,0,1,9,.15L17.29,8.4h0c.19.19.1.43-.09.62a.48.48,0,0,1-.7,0L8.68,1.21.87,9A.54.54,0,0,1,.12,9,.53.53,0,0,1,.17,8.3h0L8.33.15A.47.47,0,0,1,8.68,0Z"/></svg>
          <span>Back<br/>to top</span>
        </a>
      </div>
    </div>
  </div>

    </footer>
		<script src="/assets/js/flex-nav.js" type="text/javascript" charset="utf-8"></script>
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://neatline.org//assets/js/bootstrap/bootstrap.bundle.min.js"></script>
  </body>
</html>
